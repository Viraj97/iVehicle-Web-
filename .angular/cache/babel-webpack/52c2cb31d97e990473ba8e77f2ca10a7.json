{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.mqtt = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      } // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        } // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      } // base64 is 4/3 + up to two characters of the original data\n\n\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i;\n\n        for (i = 0; i < len; i += 4) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n        // go through the array every three bytes, we'll deal with trailing stuff later\n\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n        }\n\n        return parts.join('');\n      }\n    }, {}],\n    2: [function (require, module, exports) {}, {}],\n    3: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          /*!\n           * The buffer module from node.js, for the browser.\n           *\n           * @author   Feross Aboukhadijeh <https://feross.org>\n           * @license  MIT\n           */\n\n          /* eslint-disable no-proto */\n          'use strict';\n\n          var base64 = require('base64-js');\n\n          var ieee754 = require('ieee754');\n\n          exports.Buffer = Buffer;\n          exports.SlowBuffer = SlowBuffer;\n          exports.INSPECT_MAX_BYTES = 50;\n          var K_MAX_LENGTH = 0x7fffffff;\n          exports.kMaxLength = K_MAX_LENGTH;\n          /**\n           * If `Buffer.TYPED_ARRAY_SUPPORT`:\n           *   === true    Use Uint8Array implementation (fastest)\n           *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n           *               implementation (most compatible, even IE6)\n           *\n           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n           * Opera 11.6+, iOS 4.2+.\n           *\n           * We report that the browser does not support typed arrays if the are not subclassable\n           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n           * for __proto__ and has a buggy typed array implementation.\n           */\n\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n          }\n\n          function typedArraySupport() {\n            // Can typed array instances can be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              arr.__proto__ = {\n                __proto__: Uint8Array.prototype,\n                foo: function () {\n                  return 42;\n                }\n              };\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          Object.defineProperty(Buffer.prototype, 'parent', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.buffer;\n            }\n          });\n          Object.defineProperty(Buffer.prototype, 'offset', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.byteOffset;\n            }\n          });\n\n          function createBuffer(length) {\n            if (length > K_MAX_LENGTH) {\n              throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n            } // Return an augmented `Uint8Array` instance\n\n\n            var buf = new Uint8Array(length);\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n          /**\n           * The Buffer constructor returns instances of `Uint8Array` that have their\n           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n           * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n           * returns a single octet.\n           *\n           * The `Uint8Array` prototype remains unmodified.\n           */\n\n\n          function Buffer(arg, encodingOrOffset, length) {\n            // Common case.\n            if (typeof arg === 'number') {\n              if (typeof encodingOrOffset === 'string') {\n                throw new TypeError('The \"string\" argument must be of type string. Received type number');\n              }\n\n              return allocUnsafe(arg);\n            }\n\n            return from(arg, encodingOrOffset, length);\n          } // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\n\n          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true,\n              enumerable: false,\n              writable: false\n            });\n          }\n\n          Buffer.poolSize = 8192; // not used by this implementation\n\n          function from(value, encodingOrOffset, length) {\n            if (typeof value === 'string') {\n              return fromString(value, encodingOrOffset);\n            }\n\n            if (ArrayBuffer.isView(value)) {\n              return fromArrayLike(value);\n            }\n\n            if (value == null) {\n              throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n            }\n\n            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n\n            if (typeof value === 'number') {\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            }\n\n            var valueOf = value.valueOf && value.valueOf();\n\n            if (valueOf != null && valueOf !== value) {\n              return Buffer.from(valueOf, encodingOrOffset, length);\n            }\n\n            var b = fromObject(value);\n            if (b) return b;\n\n            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n            }\n\n            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n          }\n          /**\n           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n           * if value is a number.\n           * Buffer.from(str[, encoding])\n           * Buffer.from(array)\n           * Buffer.from(buffer)\n           * Buffer.from(arrayBuffer[, byteOffset[, length]])\n           **/\n\n\n          Buffer.from = function (value, encodingOrOffset, length) {\n            return from(value, encodingOrOffset, length);\n          }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n          // https://github.com/feross/buffer/pull/148\n\n\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          function assertSize(size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('\"size\" argument must be of type number');\n            } else if (size < 0) {\n              throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n            }\n          }\n\n          function alloc(size, fill, encoding) {\n            assertSize(size);\n\n            if (size <= 0) {\n              return createBuffer(size);\n            }\n\n            if (fill !== undefined) {\n              // Only pay attention to encoding if it's a string. This\n              // prevents accidentally sending in a number that would\n              // be interpretted as a start offset.\n              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n            }\n\n            return createBuffer(size);\n          }\n          /**\n           * Creates a new filled Buffer instance.\n           * alloc(size[, fill[, encoding]])\n           **/\n\n\n          Buffer.alloc = function (size, fill, encoding) {\n            return alloc(size, fill, encoding);\n          };\n\n          function allocUnsafe(size) {\n            assertSize(size);\n            return createBuffer(size < 0 ? 0 : checked(size) | 0);\n          }\n          /**\n           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n           * */\n\n\n          Buffer.allocUnsafe = function (size) {\n            return allocUnsafe(size);\n          };\n          /**\n           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n           */\n\n\n          Buffer.allocUnsafeSlow = function (size) {\n            return allocUnsafe(size);\n          };\n\n          function fromString(string, encoding) {\n            if (typeof encoding !== 'string' || encoding === '') {\n              encoding = 'utf8';\n            }\n\n            if (!Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n\n            var length = byteLength(string, encoding) | 0;\n            var buf = createBuffer(length);\n            var actual = buf.write(string, encoding);\n\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n\n            return buf;\n          }\n\n          function fromArrayLike(array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(length);\n\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n\n            return buf;\n          }\n\n          function fromArrayBuffer(array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\"offset\" is outside of buffer bounds');\n            }\n\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\"length\" is outside of buffer bounds');\n            }\n\n            var buf;\n\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            } // Return an augmented `Uint8Array` instance\n\n\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n\n          function fromObject(obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(len);\n\n              if (buf.length === 0) {\n                return buf;\n              }\n\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n\n            if (obj.length !== undefined) {\n              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n                return createBuffer(0);\n              }\n\n              return fromArrayLike(obj);\n            }\n\n            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n              return fromArrayLike(obj.data);\n            }\n          }\n\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n\n            return length | 0;\n          }\n\n          function SlowBuffer(length) {\n            if (+length != length) {\n              // eslint-disable-line eqeqeq\n              length = 0;\n            }\n\n            return Buffer.alloc(+length);\n          }\n\n          Buffer.isBuffer = function isBuffer(b) {\n            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n          };\n\n          Buffer.compare = function compare(a, b) {\n            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n              throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n            }\n\n            if (a === b) return 0;\n            var x = a.length;\n            var y = b.length;\n\n            for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n              if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n\n          Buffer.isEncoding = function isEncoding(encoding) {\n            switch (String(encoding).toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return true;\n\n              default:\n                return false;\n            }\n          };\n\n          Buffer.concat = function concat(list, length) {\n            if (!Array.isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            if (list.length === 0) {\n              return Buffer.alloc(0);\n            }\n\n            var i;\n\n            if (length === undefined) {\n              length = 0;\n\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n\n            var buffer = Buffer.allocUnsafe(length);\n            var pos = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n\n              if (isInstance(buf, Uint8Array)) {\n                buf = Buffer.from(buf);\n              }\n\n              if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n\n              buf.copy(buffer, pos);\n              pos += buf.length;\n            }\n\n            return buffer;\n          };\n\n          function byteLength(string, encoding) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n\n            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n              return string.byteLength;\n            }\n\n            if (typeof string !== 'string') {\n              throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n            }\n\n            var len = string.length;\n            var mustMatch = arguments.length > 2 && arguments[2] === true;\n            if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return len;\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8ToBytes(string).length;\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return len * 2;\n\n                case 'hex':\n                  return len >>> 1;\n\n                case 'base64':\n                  return base64ToBytes(string).length;\n\n                default:\n                  if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                  }\n\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n\n          Buffer.byteLength = byteLength;\n\n          function slowToString(encoding, start, end) {\n            var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n            // property of a typed array.\n            // This behaves neither like String nor Uint8Array in that we set start/end\n            // to their upper/lower bounds if the value passed is out of range.\n            // undefined is handled specially as per ECMA-262 6th Edition,\n            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n            if (start === undefined || start < 0) {\n              start = 0;\n            } // Return early if start > this.length. Done here to prevent potential uint32\n            // coercion fail below.\n\n\n            if (start > this.length) {\n              return '';\n            }\n\n            if (end === undefined || end > this.length) {\n              end = this.length;\n            }\n\n            if (end <= 0) {\n              return '';\n            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n            end >>>= 0;\n            start >>>= 0;\n\n            if (end <= start) {\n              return '';\n            }\n\n            if (!encoding) encoding = 'utf8';\n\n            while (true) {\n              switch (encoding) {\n                case 'hex':\n                  return hexSlice(this, start, end);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Slice(this, start, end);\n\n                case 'ascii':\n                  return asciiSlice(this, start, end);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Slice(this, start, end);\n\n                case 'base64':\n                  return base64Slice(this, start, end);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return utf16leSlice(this, start, end);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = (encoding + '').toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n          // reliably in a browserify context because there could be multiple different\n          // copies of the 'buffer' package in use. This method works even for Buffer\n          // instances that were created from another copy of the `buffer` package.\n          // See: https://github.com/feross/buffer/issues/154\n\n\n          Buffer.prototype._isBuffer = true;\n\n          function swap(b, n, m) {\n            var i = b[n];\n            b[n] = b[m];\n            b[m] = i;\n          }\n\n          Buffer.prototype.swap16 = function swap16() {\n            var len = this.length;\n\n            if (len % 2 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 16-bits');\n            }\n\n            for (var i = 0; i < len; i += 2) {\n              swap(this, i, i + 1);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap32 = function swap32() {\n            var len = this.length;\n\n            if (len % 4 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 32-bits');\n            }\n\n            for (var i = 0; i < len; i += 4) {\n              swap(this, i, i + 3);\n              swap(this, i + 1, i + 2);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap64 = function swap64() {\n            var len = this.length;\n\n            if (len % 8 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 64-bits');\n            }\n\n            for (var i = 0; i < len; i += 8) {\n              swap(this, i, i + 7);\n              swap(this, i + 1, i + 6);\n              swap(this, i + 2, i + 5);\n              swap(this, i + 3, i + 4);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.toString = function toString() {\n            var length = this.length;\n            if (length === 0) return '';\n            if (arguments.length === 0) return utf8Slice(this, 0, length);\n            return slowToString.apply(this, arguments);\n          };\n\n          Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n          Buffer.prototype.equals = function equals(b) {\n            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n            if (this === b) return true;\n            return Buffer.compare(this, b) === 0;\n          };\n\n          Buffer.prototype.inspect = function inspect() {\n            var str = '';\n            var max = exports.INSPECT_MAX_BYTES;\n            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n            if (this.length > max) str += ' ... ';\n            return '<Buffer ' + str + '>';\n          };\n\n          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n            if (isInstance(target, Uint8Array)) {\n              target = Buffer.from(target, target.offset, target.byteLength);\n            }\n\n            if (!Buffer.isBuffer(target)) {\n              throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n            }\n\n            if (start === undefined) {\n              start = 0;\n            }\n\n            if (end === undefined) {\n              end = target ? target.length : 0;\n            }\n\n            if (thisStart === undefined) {\n              thisStart = 0;\n            }\n\n            if (thisEnd === undefined) {\n              thisEnd = this.length;\n            }\n\n            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n              throw new RangeError('out of range index');\n            }\n\n            if (thisStart >= thisEnd && start >= end) {\n              return 0;\n            }\n\n            if (thisStart >= thisEnd) {\n              return -1;\n            }\n\n            if (start >= end) {\n              return 1;\n            }\n\n            start >>>= 0;\n            end >>>= 0;\n            thisStart >>>= 0;\n            thisEnd >>>= 0;\n            if (this === target) return 0;\n            var x = thisEnd - thisStart;\n            var y = end - start;\n            var len = Math.min(x, y);\n            var thisCopy = this.slice(thisStart, thisEnd);\n            var targetCopy = target.slice(start, end);\n\n            for (var i = 0; i < len; ++i) {\n              if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n          //\n          // Arguments:\n          // - buffer - a Buffer to search\n          // - val - a string, Buffer, or number\n          // - byteOffset - an index into `buffer`; will be clamped to an int32\n          // - encoding - an optional encoding, relevant is val is a string\n          // - dir - true for indexOf, false for lastIndexOf\n\n\n          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n            // Empty buffer means no match\n            if (buffer.length === 0) return -1; // Normalize byteOffset\n\n            if (typeof byteOffset === 'string') {\n              encoding = byteOffset;\n              byteOffset = 0;\n            } else if (byteOffset > 0x7fffffff) {\n              byteOffset = 0x7fffffff;\n            } else if (byteOffset < -0x80000000) {\n              byteOffset = -0x80000000;\n            }\n\n            byteOffset = +byteOffset; // Coerce to Number.\n\n            if (numberIsNaN(byteOffset)) {\n              // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n              byteOffset = dir ? 0 : buffer.length - 1;\n            } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n            if (byteOffset >= buffer.length) {\n              if (dir) return -1;else byteOffset = buffer.length - 1;\n            } else if (byteOffset < 0) {\n              if (dir) byteOffset = 0;else return -1;\n            } // Normalize val\n\n\n            if (typeof val === 'string') {\n              val = Buffer.from(val, encoding);\n            } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n            if (Buffer.isBuffer(val)) {\n              // Special case: looking for empty string/buffer always fails\n              if (val.length === 0) {\n                return -1;\n              }\n\n              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n            } else if (typeof val === 'number') {\n              val = val & 0xFF; // Search for a byte value [0-255]\n\n              if (typeof Uint8Array.prototype.indexOf === 'function') {\n                if (dir) {\n                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                } else {\n                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                }\n              }\n\n              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n            }\n\n            throw new TypeError('val must be string, number or Buffer');\n          }\n\n          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n            var indexSize = 1;\n            var arrLength = arr.length;\n            var valLength = val.length;\n\n            if (encoding !== undefined) {\n              encoding = String(encoding).toLowerCase();\n\n              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n                if (arr.length < 2 || val.length < 2) {\n                  return -1;\n                }\n\n                indexSize = 2;\n                arrLength /= 2;\n                valLength /= 2;\n                byteOffset /= 2;\n              }\n            }\n\n            function read(buf, i) {\n              if (indexSize === 1) {\n                return buf[i];\n              } else {\n                return buf.readUInt16BE(i * indexSize);\n              }\n            }\n\n            var i;\n\n            if (dir) {\n              var foundIndex = -1;\n\n              for (i = byteOffset; i < arrLength; i++) {\n                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                  if (foundIndex === -1) foundIndex = i;\n                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n                } else {\n                  if (foundIndex !== -1) i -= i - foundIndex;\n                  foundIndex = -1;\n                }\n              }\n            } else {\n              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n              for (i = byteOffset; i >= 0; i--) {\n                var found = true;\n\n                for (var j = 0; j < valLength; j++) {\n                  if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                  }\n                }\n\n                if (found) return i;\n              }\n            }\n\n            return -1;\n          }\n\n          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n            return this.indexOf(val, byteOffset, encoding) !== -1;\n          };\n\n          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n          };\n\n          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n          };\n\n          function hexWrite(buf, string, offset, length) {\n            offset = Number(offset) || 0;\n            var remaining = buf.length - offset;\n\n            if (!length) {\n              length = remaining;\n            } else {\n              length = Number(length);\n\n              if (length > remaining) {\n                length = remaining;\n              }\n            }\n\n            var strLen = string.length;\n\n            if (length > strLen / 2) {\n              length = strLen / 2;\n            }\n\n            for (var i = 0; i < length; ++i) {\n              var parsed = parseInt(string.substr(i * 2, 2), 16);\n              if (numberIsNaN(parsed)) return i;\n              buf[offset + i] = parsed;\n            }\n\n            return i;\n          }\n\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          function asciiWrite(buf, string, offset, length) {\n            return blitBuffer(asciiToBytes(string), buf, offset, length);\n          }\n\n          function latin1Write(buf, string, offset, length) {\n            return asciiWrite(buf, string, offset, length);\n          }\n\n          function base64Write(buf, string, offset, length) {\n            return blitBuffer(base64ToBytes(string), buf, offset, length);\n          }\n\n          function ucs2Write(buf, string, offset, length) {\n            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          Buffer.prototype.write = function write(string, offset, length, encoding) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              encoding = 'utf8';\n              length = this.length;\n              offset = 0; // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              encoding = offset;\n              length = this.length;\n              offset = 0; // Buffer#write(string, offset[, length][, encoding])\n            } else if (isFinite(offset)) {\n              offset = offset >>> 0;\n\n              if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined) encoding = 'utf8';\n              } else {\n                encoding = length;\n                length = undefined;\n              }\n            } else {\n              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n            }\n\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n\n            if (!encoding) encoding = 'utf8';\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'hex':\n                  return hexWrite(this, string, offset, length);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Write(this, string, offset, length);\n\n                case 'ascii':\n                  return asciiWrite(this, string, offset, length);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Write(this, string, offset, length);\n\n                case 'base64':\n                  // Warning: maxLength not taken into account in base64Write\n                  return base64Write(this, string, offset, length);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return ucs2Write(this, string, offset, length);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          };\n\n          Buffer.prototype.toJSON = function toJSON() {\n            return {\n              type: 'Buffer',\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n\n          function base64Slice(buf, start, end) {\n            if (start === 0 && end === buf.length) {\n              return base64.fromByteArray(buf);\n            } else {\n              return base64.fromByteArray(buf.slice(start, end));\n            }\n          }\n\n          function utf8Slice(buf, start, end) {\n            end = Math.min(buf.length, end);\n            var res = [];\n            var i = start;\n\n            while (i < end) {\n              var firstByte = buf[i];\n              var codePoint = null;\n              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n              if (i + bytesPerSequence <= end) {\n                var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n                switch (bytesPerSequence) {\n                  case 1:\n                    if (firstByte < 0x80) {\n                      codePoint = firstByte;\n                    }\n\n                    break;\n\n                  case 2:\n                    secondByte = buf[i + 1];\n\n                    if ((secondByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                      if (tempCodePoint > 0x7F) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                }\n              }\n\n              if (codePoint === null) {\n                // we did not generate a valid codePoint so insert a\n                // replacement char (U+FFFD) and advance only 1 byte\n                codePoint = 0xFFFD;\n                bytesPerSequence = 1;\n              } else if (codePoint > 0xFFFF) {\n                // encode to utf16 (surrogate pair dance)\n                codePoint -= 0x10000;\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n                codePoint = 0xDC00 | codePoint & 0x3FF;\n              }\n\n              res.push(codePoint);\n              i += bytesPerSequence;\n            }\n\n            return decodeCodePointsArray(res);\n          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n          // the lowest limit is Chrome, with 0x10000 args.\n          // We go 1 magnitude less, for safety\n\n\n          var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n          function decodeCodePointsArray(codePoints) {\n            var len = codePoints.length;\n\n            if (len <= MAX_ARGUMENTS_LENGTH) {\n              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n            } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n            var res = '';\n            var i = 0;\n\n            while (i < len) {\n              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n            }\n\n            return res;\n          }\n\n          function asciiSlice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i] & 0x7F);\n            }\n\n            return ret;\n          }\n\n          function latin1Slice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i]);\n            }\n\n            return ret;\n          }\n\n          function hexSlice(buf, start, end) {\n            var len = buf.length;\n            if (!start || start < 0) start = 0;\n            if (!end || end < 0 || end > len) end = len;\n            var out = '';\n\n            for (var i = start; i < end; ++i) {\n              out += toHex(buf[i]);\n            }\n\n            return out;\n          }\n\n          function utf16leSlice(buf, start, end) {\n            var bytes = buf.slice(start, end);\n            var res = '';\n\n            for (var i = 0; i < bytes.length; i += 2) {\n              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n            }\n\n            return res;\n          }\n\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n\n            if (end < start) end = start;\n            var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n            newBuf.__proto__ = Buffer.prototype;\n            return newBuf;\n          };\n          /*\n           * Need to make sure that buffer isn't trying to write out of bounds.\n           */\n\n\n          function checkOffset(offset, ext, length) {\n            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n          }\n\n          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              checkOffset(offset, byteLength, this.length);\n            }\n\n            var val = this[offset + --byteLength];\n            var mul = 1;\n\n            while (byteLength > 0 && (mul *= 0x100)) {\n              val += this[offset + --byteLength] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            return this[offset];\n          };\n\n          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] | this[offset + 1] << 8;\n          };\n\n          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] << 8 | this[offset + 1];\n          };\n\n          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n          };\n\n          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n          };\n\n          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var i = byteLength;\n            var mul = 1;\n            var val = this[offset + --i];\n\n            while (i > 0 && (mul *= 0x100)) {\n              val += this[offset + --i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            if (!(this[offset] & 0x80)) return this[offset];\n            return (0xff - this[offset] + 1) * -1;\n          };\n\n          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset] | this[offset + 1] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset + 1] | this[offset] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n          };\n\n          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n          };\n\n          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, true, 23, 4);\n          };\n\n          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, false, 23, 4);\n          };\n\n          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, true, 52, 8);\n          };\n\n          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, false, 52, 8);\n          };\n\n          function checkInt(buf, value, offset, ext, max, min) {\n            if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n            if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          }\n\n          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var mul = 1;\n            var i = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = 0;\n            var mul = 1;\n            var sub = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            var sub = 0;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n            if (value < 0) value = 0xff + value + 1;\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            if (value < 0) value = 0xffffffff + value + 1;\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          function checkIEEE754(buf, value, offset, ext, max, min) {\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n            if (offset < 0) throw new RangeError('Index out of range');\n          }\n\n          function writeFloat(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 23, 4);\n            return offset + 4;\n          }\n\n          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, false, noAssert);\n          };\n\n          function writeDouble(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 52, 8);\n            return offset + 8;\n          }\n\n          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, false, noAssert);\n          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n\n            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n            if (end > this.length) end = this.length;\n\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n\n            var len = end - start;\n\n            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n              // Use built-in when available, missing from IE11\n              this.copyWithin(targetStart, start, end);\n            } else if (this === target && start < targetStart && targetStart < end) {\n              // descending copy from end\n              for (var i = len - 1; i >= 0; --i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n            }\n\n            return len;\n          }; // Usage:\n          //    buffer.fill(number[, offset[, end]])\n          //    buffer.fill(buffer[, offset[, end]])\n          //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n          Buffer.prototype.fill = function fill(val, start, end, encoding) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n              }\n\n              if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n              }\n\n              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError('Unknown encoding: ' + encoding);\n              }\n\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n\n                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                  // Fast path: If `val` fits into a single byte, use that numeric value.\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            } // Invalid ranges are not set to a default, so can range check early.\n\n\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n\n            if (end <= start) {\n              return this;\n            }\n\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n              var len = bytes.length;\n\n              if (len === 0) {\n                throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n              }\n\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n\n            return this;\n          }; // HELPER FUNCTIONS\n          // ================\n\n\n          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n          function base64clean(str) {\n            // Node takes equal signs as end of the Base64 encoding\n            str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n            str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n            while (str.length % 4 !== 0) {\n              str = str + '=';\n            }\n\n            return str;\n          }\n\n          function toHex(n) {\n            if (n < 16) return '0' + n.toString(16);\n            return n.toString(16);\n          }\n\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i); // is surrogate component\n\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } // valid lead\n\n\n                  leadSurrogate = codePoint;\n                  continue;\n                } // 2 leads in a row\n\n\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                } // valid surrogate pair\n\n\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n\n              leadSurrogate = null; // encode utf8\n\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n\n            return bytes;\n          }\n\n          function asciiToBytes(str) {\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              // Node's code seems to be doing this and not & 0x7F..\n              byteArray.push(str.charCodeAt(i) & 0xFF);\n            }\n\n            return byteArray;\n          }\n\n          function utf16leToBytes(str, units) {\n            var c, hi, lo;\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              if ((units -= 2) < 0) break;\n              c = str.charCodeAt(i);\n              hi = c >> 8;\n              lo = c % 256;\n              byteArray.push(lo);\n              byteArray.push(hi);\n            }\n\n            return byteArray;\n          }\n\n          function base64ToBytes(str) {\n            return base64.toByteArray(base64clean(str));\n          }\n\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n\n            return i;\n          } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n          // the `instanceof` check but they should be treated as of that type.\n          // See: https://github.com/feross/buffer/issues/166\n\n\n          function isInstance(obj, type) {\n            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n          }\n\n          function numberIsNaN(obj) {\n            // For IE11 support\n            return obj !== obj; // eslint-disable-line no-self-compare\n          }\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 1,\n      \"buffer\": 3,\n      \"ieee754\": 5\n    }],\n    4: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var R = typeof Reflect === 'object' ? Reflect : null;\n      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n      };\n      var ReflectOwnKeys;\n\n      if (R && typeof R.ownKeys === 'function') {\n        ReflectOwnKeys = R.ownKeys;\n      } else if (Object.getOwnPropertySymbols) {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n        };\n      } else {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n          return Object.getOwnPropertyNames(target);\n        };\n      }\n\n      function ProcessEmitWarning(warning) {\n        if (console && console.warn) console.warn(warning);\n      }\n\n      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n        return value !== value;\n      };\n\n      function EventEmitter() {\n        EventEmitter.init.call(this);\n      }\n\n      module.exports = EventEmitter;\n      module.exports.once = once; // Backwards-compat with node 0.10.x\n\n      EventEmitter.EventEmitter = EventEmitter;\n      EventEmitter.prototype._events = undefined;\n      EventEmitter.prototype._eventsCount = 0;\n      EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n      // added to it. This is a useful default which helps finding memory leaks.\n\n      var defaultMaxListeners = 10;\n\n      function checkListener(listener) {\n        if (typeof listener !== 'function') {\n          throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n        }\n      }\n\n      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n        enumerable: true,\n        get: function () {\n          return defaultMaxListeners;\n        },\n        set: function (arg) {\n          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n          }\n\n          defaultMaxListeners = arg;\n        }\n      });\n\n      EventEmitter.init = function () {\n        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        }\n\n        this._maxListeners = this._maxListeners || undefined;\n      }; // Obviously not all Emitters should be limited to 10. This function allows\n      // that to be increased. Set to zero for unlimited.\n\n\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n          throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n        }\n\n        this._maxListeners = n;\n        return this;\n      };\n\n      function _getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n      }\n\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return _getMaxListeners(this);\n      };\n\n      EventEmitter.prototype.emit = function emit(type) {\n        var args = [];\n\n        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n        var doError = type === 'error';\n        var events = this._events;\n        if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n        if (doError) {\n          var er;\n          if (args.length > 0) er = args[0];\n\n          if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n          } // At least give some kind of context to the user\n\n\n          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n          err.context = er;\n          throw err; // Unhandled 'error' event\n        }\n\n        var handler = events[type];\n        if (handler === undefined) return false;\n\n        if (typeof handler === 'function') {\n          ReflectApply(handler, this, args);\n        } else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n\n          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n        }\n\n        return true;\n      };\n\n      function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        checkListener(listener);\n        events = target._events;\n\n        if (events === undefined) {\n          events = target._events = Object.create(null);\n          target._eventsCount = 0;\n        } else {\n          // To avoid recursion in the case that type === \"newListener\"! Before\n          // adding it to the listeners, first emit \"newListener\".\n          if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n\n            events = target._events;\n          }\n\n          existing = events[type];\n        }\n\n        if (existing === undefined) {\n          // Optimize the case of one listener. Don't need the extra array object.\n          existing = events[type] = listener;\n          ++target._eventsCount;\n        } else {\n          if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n          } else if (prepend) {\n            existing.unshift(listener);\n          } else {\n            existing.push(listener);\n          } // Check for listener leak\n\n\n          m = _getMaxListeners(target);\n\n          if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true; // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n          }\n        }\n\n        return target;\n      }\n\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n      };\n\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n      EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n\n      function onceWrapper() {\n        if (!this.fired) {\n          this.target.removeListener(this.type, this.wrapFn);\n          this.fired = true;\n          if (arguments.length === 0) return this.listener.call(this.target);\n          return this.listener.apply(this.target, arguments);\n        }\n      }\n\n      function _onceWrap(target, type, listener) {\n        var state = {\n          fired: false,\n          wrapFn: undefined,\n          target: target,\n          type: type,\n          listener: listener\n        };\n        var wrapped = onceWrapper.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n      }\n\n      EventEmitter.prototype.once = function once(type, listener) {\n        checkListener(listener);\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        checkListener(listener);\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n      EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        checkListener(listener);\n        events = this._events;\n        if (events === undefined) return this;\n        list = events[type];\n        if (list === undefined) return this;\n\n        if (list === listener || list.listener === listener) {\n          if (--this._eventsCount === 0) this._events = Object.create(null);else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n\n          for (i = list.length - 1; i >= 0; i--) {\n            if (list[i] === listener || list[i].listener === listener) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n\n          if (position < 0) return this;\n          if (position === 0) list.shift();else {\n            spliceOne(list, position);\n          }\n          if (list.length === 1) events[type] = list[0];\n          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n        }\n\n        return this;\n      };\n\n      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n        if (events.removeListener === undefined) {\n          if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n          } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n          }\n\n          return this;\n        } // emit removeListener for all listeners on all events\n\n\n        if (arguments.length === 0) {\n          var keys = Object.keys(events);\n          var key;\n\n          for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n\n          this.removeAllListeners('removeListener');\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n          return this;\n        }\n\n        listeners = events[type];\n\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners !== undefined) {\n          // LIFO order\n          for (i = listeners.length - 1; i >= 0; i--) {\n            this.removeListener(type, listeners[i]);\n          }\n        }\n\n        return this;\n      };\n\n      function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (events === undefined) return [];\n        var evlistener = events[type];\n        if (evlistener === undefined) return [];\n        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n      }\n\n      EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n      };\n\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n      };\n\n      EventEmitter.listenerCount = function (emitter, type) {\n        if (typeof emitter.listenerCount === 'function') {\n          return emitter.listenerCount(type);\n        } else {\n          return listenerCount.call(emitter, type);\n        }\n      };\n\n      EventEmitter.prototype.listenerCount = listenerCount;\n\n      function listenerCount(type) {\n        var events = this._events;\n\n        if (events !== undefined) {\n          var evlistener = events[type];\n\n          if (typeof evlistener === 'function') {\n            return 1;\n          } else if (evlistener !== undefined) {\n            return evlistener.length;\n          }\n        }\n\n        return 0;\n      }\n\n      EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n      };\n\n      function arrayClone(arr, n) {\n        var copy = new Array(n);\n\n        for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n        return copy;\n      }\n\n      function spliceOne(list, index) {\n        for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n\n        list.pop();\n      }\n\n      function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n\n        for (var i = 0; i < ret.length; ++i) {\n          ret[i] = arr[i].listener || arr[i];\n        }\n\n        return ret;\n      }\n\n      function once(emitter, name) {\n        return new Promise(function (resolve, reject) {\n          function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n          }\n\n          function resolver() {\n            if (typeof emitter.removeListener === 'function') {\n              emitter.removeListener('error', errorListener);\n            }\n\n            resolve([].slice.call(arguments));\n          }\n\n          ;\n          eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n          });\n\n          if (name !== 'error') {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n              once: true\n            });\n          }\n        });\n      }\n\n      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n        if (typeof emitter.on === 'function') {\n          eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n        }\n      }\n\n      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n        if (typeof emitter.on === 'function') {\n          if (flags.once) {\n            emitter.once(name, listener);\n          } else {\n            emitter.on(name, listener);\n          }\n        } else if (typeof emitter.addEventListener === 'function') {\n          // EventTarget does not have `error` event semantics like Node\n          // EventEmitters, we do not listen for `error` events here.\n          emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n              emitter.removeEventListener(name, wrapListener);\n            }\n\n            listener(arg);\n          });\n        } else {\n          throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n        }\n      }\n    }, {}],\n    5: [function (require, module, exports) {\n      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n    }, {}],\n    6: [function (require, module, exports) {\n      /*!\n       * Determine if an object is a Buffer\n       *\n       * @author   Feross Aboukhadijeh <https://feross.org>\n       * @license  MIT\n       */\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      } // For Node v0.10 support. Remove this eventually.\n\n\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n    }, {}],\n    7: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n          /**\n           * Module dependencies\n           */\n\n          var EventEmitter = require('events').EventEmitter;\n\n          var Store = require('./store');\n\n          var mqttPacket = require('mqtt-packet');\n\n          var Writable = require('readable-stream').Writable;\n\n          var inherits = require('inherits');\n\n          var reInterval = require('reinterval');\n\n          var validations = require('./validations');\n\n          var xtend = require('xtend');\n\n          var debug = require('debug')('mqttjs:client');\n\n          var nextTick = process ? process.nextTick : function (callback) {\n            setTimeout(callback, 0);\n          };\n\n          var setImmediate = global.setImmediate || function (callback) {\n            // works in node v0.8\n            nextTick(callback);\n          };\n\n          var defaultConnectOptions = {\n            keepalive: 60,\n            reschedulePings: true,\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            reconnectPeriod: 1000,\n            connectTimeout: 30 * 1000,\n            clean: true,\n            resubscribe: true\n          };\n          var socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND']; // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\n          var errors = {\n            0: '',\n            1: 'Unacceptable protocol version',\n            2: 'Identifier rejected',\n            3: 'Server unavailable',\n            4: 'Bad username or password',\n            5: 'Not authorized',\n            16: 'No matching subscribers',\n            17: 'No subscription existed',\n            128: 'Unspecified error',\n            129: 'Malformed Packet',\n            130: 'Protocol Error',\n            131: 'Implementation specific error',\n            132: 'Unsupported Protocol Version',\n            133: 'Client Identifier not valid',\n            134: 'Bad User Name or Password',\n            135: 'Not authorized',\n            136: 'Server unavailable',\n            137: 'Server busy',\n            138: 'Banned',\n            139: 'Server shutting down',\n            140: 'Bad authentication method',\n            141: 'Keep Alive timeout',\n            142: 'Session taken over',\n            143: 'Topic Filter invalid',\n            144: 'Topic Name invalid',\n            145: 'Packet identifier in use',\n            146: 'Packet Identifier not found',\n            147: 'Receive Maximum exceeded',\n            148: 'Topic Alias invalid',\n            149: 'Packet too large',\n            150: 'Message rate too high',\n            151: 'Quota exceeded',\n            152: 'Administrative action',\n            153: 'Payload format invalid',\n            154: 'Retain not supported',\n            155: 'QoS not supported',\n            156: 'Use another server',\n            157: 'Server moved',\n            158: 'Shared Subscriptions not supported',\n            159: 'Connection rate exceeded',\n            160: 'Maximum connect time',\n            161: 'Subscription Identifiers not supported',\n            162: 'Wildcard Subscriptions not supported'\n          };\n\n          function defaultId() {\n            return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n          }\n\n          function sendPacket(client, packet, cb) {\n            debug('sendPacket :: packet: %O', packet);\n            debug('sendPacket :: emitting `packetsend`');\n            client.emit('packetsend', packet);\n            debug('sendPacket :: writing to stream');\n            var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n            debug('sendPacket :: writeToStream result %s', result);\n\n            if (!result && cb) {\n              debug('sendPacket :: handle events on `drain` once through callback.');\n              client.stream.once('drain', cb);\n            } else if (cb) {\n              debug('sendPacket :: invoking cb');\n              cb();\n            }\n          }\n\n          function flush(queue) {\n            if (queue) {\n              debug('flush: queue exists? %b', !!queue);\n              Object.keys(queue).forEach(function (messageId) {\n                if (typeof queue[messageId].cb === 'function') {\n                  queue[messageId].cb(new Error('Connection closed'));\n                  delete queue[messageId];\n                }\n              });\n            }\n          }\n\n          function flushVolatile(queue) {\n            if (queue) {\n              debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n              Object.keys(queue).forEach(function (messageId) {\n                if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n                  queue[messageId].cb(new Error('Connection closed'));\n                  delete queue[messageId];\n                }\n              });\n            }\n          }\n\n          function storeAndSend(client, packet, cb, cbStorePut) {\n            debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n            client.outgoingStore.put(packet, function storedPacket(err) {\n              if (err) {\n                return cb && cb(err);\n              }\n\n              cbStorePut();\n              sendPacket(client, packet, cb);\n            });\n          }\n\n          function nop(error) {\n            debug('nop ::', error);\n          }\n          /**\n           * MqttClient constructor\n           *\n           * @param {Stream} stream - stream\n           * @param {Object} [options] - connection options\n           * (see Connection#connect)\n           */\n\n\n          function MqttClient(streamBuilder, options) {\n            var k;\n            var that = this;\n\n            if (!(this instanceof MqttClient)) {\n              return new MqttClient(streamBuilder, options);\n            }\n\n            this.options = options || {}; // Defaults\n\n            for (k in defaultConnectOptions) {\n              if (typeof this.options[k] === 'undefined') {\n                this.options[k] = defaultConnectOptions[k];\n              } else {\n                this.options[k] = options[k];\n              }\n            }\n\n            debug('MqttClient :: options.protocol', options.protocol);\n            debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n            debug('MqttClient :: options.username', options.username);\n            debug('MqttClient :: options.keepalive', options.keepalive);\n            debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n            debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n            this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n            debug('MqttClient :: clientId', this.options.clientId);\n            this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n              arguments[3](0);\n            };\n            this.streamBuilder = streamBuilder; // Inflight message storages\n\n            this.outgoingStore = options.outgoingStore || new Store();\n            this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n            this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n            this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n            this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n            this.pingTimer = null; // Is the client connected?\n\n            this.connected = false; // Are we disconnecting?\n\n            this.disconnecting = false; // Packet queue\n\n            this.queue = []; // connack timer\n\n            this.connackTimer = null; // Reconnect timer\n\n            this.reconnectTimer = null; // Is processing store?\n\n            this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n            this._packetIdsDuringStoreProcessing = {};\n            /**\n             * MessageIDs starting with 1\n             * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n             */\n\n            this.nextId = Math.max(1, Math.floor(Math.random() * 65535)); // Inflight callbacks\n\n            this.outgoing = {}; // True if connection is first time.\n\n            this._firstConnection = true; // Send queued packets\n\n            this.on('connect', function () {\n              var queue = this.queue;\n\n              function deliver() {\n                var entry = queue.shift();\n                debug('deliver :: entry %o', entry);\n                var packet = null;\n\n                if (!entry) {\n                  return;\n                }\n\n                packet = entry.packet;\n                debug('deliver :: call _sendPacket for %o', packet);\n\n                that._sendPacket(packet, function (err) {\n                  if (entry.cb) {\n                    entry.cb(err);\n                  }\n\n                  deliver();\n                });\n              }\n\n              debug('connect :: sending queued packets');\n              deliver();\n            });\n            this.on('close', function () {\n              debug('close :: connected set to `false`');\n              this.connected = false;\n              debug('close :: clearing connackTimer');\n              clearTimeout(this.connackTimer);\n              debug('close :: clearing ping timer');\n\n              if (that.pingTimer !== null) {\n                that.pingTimer.clear();\n                that.pingTimer = null;\n              }\n\n              debug('close :: calling _setupReconnect');\n\n              this._setupReconnect();\n            });\n            EventEmitter.call(this);\n            debug('MqttClient :: setting up stream');\n\n            this._setupStream();\n          }\n\n          inherits(MqttClient, EventEmitter);\n          /**\n           * setup the event handlers in the inner stream.\n           *\n           * @api private\n           */\n\n          MqttClient.prototype._setupStream = function () {\n            var connectPacket;\n            var that = this;\n            var writable = new Writable();\n            var parser = mqttPacket.parser(this.options);\n            var completeParse = null;\n            var packets = [];\n            debug('_setupStream :: calling method to clear reconnect');\n\n            this._clearReconnect();\n\n            debug('_setupStream :: using streamBuilder provided to client to create stream');\n            this.stream = this.streamBuilder(this);\n            parser.on('packet', function (packet) {\n              debug('parser :: on packet push to packets array.');\n              packets.push(packet);\n            });\n\n            function nextTickWork() {\n              if (packets.length) {\n                nextTick(work);\n              } else {\n                var done = completeParse;\n                completeParse = null;\n                done();\n              }\n            }\n\n            function work() {\n              debug('work :: getting next packet in queue');\n              var packet = packets.shift();\n\n              if (packet) {\n                debug('work :: packet pulled from queue');\n\n                that._handlePacket(packet, nextTickWork);\n              } else {\n                debug('work :: no packets in queue');\n                var done = completeParse;\n                completeParse = null;\n                debug('work :: done flag is %s', !!done);\n                if (done) done();\n              }\n            }\n\n            writable._write = function (buf, enc, done) {\n              completeParse = done;\n              debug('writable stream :: parsing buffer');\n              parser.parse(buf);\n              work();\n            };\n\n            function streamErrorHandler(error) {\n              debug('streamErrorHandler :: error', error.message);\n\n              if (socketErrors.includes(error.code)) {\n                // handle error\n                debug('streamErrorHandler :: emitting error');\n                that.emit('error', error);\n              } else {\n                nop(error);\n              }\n            }\n\n            debug('_setupStream :: pipe stream to writable stream');\n            this.stream.pipe(writable); // Suppress connection errors\n\n            this.stream.on('error', streamErrorHandler); // Echo stream close\n\n            this.stream.on('close', function () {\n              debug('(%s)stream :: on close', that.options.clientId);\n              flushVolatile(that.outgoing);\n              debug('stream: emit close to MqttClient');\n              that.emit('close');\n            }); // Send a connect packet\n\n            debug('_setupStream: sending packet `connect`');\n            connectPacket = Object.create(this.options);\n            connectPacket.cmd = 'connect'; // avoid message queue\n\n            sendPacket(this, connectPacket); // Echo connection errors\n\n            parser.on('error', this.emit.bind(this, 'error')); // auth\n\n            if (this.options.properties) {\n              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n                that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n                return this;\n              }\n\n              if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n                var authPacket = xtend({\n                  cmd: 'auth',\n                  reasonCode: 0\n                }, this.options.authPacket);\n                sendPacket(this, authPacket);\n              }\n            } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n            this.stream.setMaxListeners(1000);\n            clearTimeout(this.connackTimer);\n            this.connackTimer = setTimeout(function () {\n              debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n\n              that._cleanUp(true);\n            }, this.options.connectTimeout);\n          };\n\n          MqttClient.prototype._handlePacket = function (packet, done) {\n            var options = this.options;\n\n            if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n              this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n              this.end({\n                reasonCode: 149,\n                properties: {\n                  reasonString: 'Maximum packet size was exceeded'\n                }\n              });\n              return this;\n            }\n\n            debug('_handlePacket :: emitting packetreceive');\n            this.emit('packetreceive', packet);\n\n            switch (packet.cmd) {\n              case 'publish':\n                this._handlePublish(packet, done);\n\n                break;\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubcomp':\n              case 'suback':\n              case 'unsuback':\n                this._handleAck(packet);\n\n                done();\n                break;\n\n              case 'pubrel':\n                this._handlePubrel(packet, done);\n\n                break;\n\n              case 'connack':\n                this._handleConnack(packet);\n\n                done();\n                break;\n\n              case 'pingresp':\n                this._handlePingresp(packet);\n\n                done();\n                break;\n\n              case 'disconnect':\n                this._handleDisconnect(packet);\n\n                done();\n                break;\n\n              default:\n                // do nothing\n                // maybe we should do an error handling\n                // or just log it\n                break;\n            }\n          };\n\n          MqttClient.prototype._checkDisconnecting = function (callback) {\n            if (this.disconnecting) {\n              if (callback) {\n                callback(new Error('client disconnecting'));\n              } else {\n                this.emit('error', new Error('client disconnecting'));\n              }\n            }\n\n            return this.disconnecting;\n          };\n          /**\n           * publish - publish <message> to <topic>\n           *\n           * @param {String} topic - topic to publish to\n           * @param {String, Buffer} message - message to publish\n           * @param {Object} [opts] - publish options, includes:\n           *    {Number} qos - qos level to publish on\n           *    {Boolean} retain - whether or not to retain the message\n           *    {Boolean} dup - whether or not mark a message as duplicate\n           *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n           * @param {Function} [callback] - function(err){}\n           *    called when publish succeeds or fails\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           *\n           * @example client.publish('topic', 'message');\n           * @example\n           *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n           * @example client.publish('topic', 'message', console.log);\n           */\n\n\n          MqttClient.prototype.publish = function (topic, message, opts, callback) {\n            debug('publish :: message `%s` to topic `%s`', message, topic);\n            var packet;\n            var options = this.options; // .publish(topic, payload, cb);\n\n            if (typeof opts === 'function') {\n              callback = opts;\n              opts = null;\n            } // default opts\n\n\n            var defaultOpts = {\n              qos: 0,\n              retain: false,\n              dup: false\n            };\n            opts = xtend(defaultOpts, opts);\n\n            if (this._checkDisconnecting(callback)) {\n              return this;\n            }\n\n            packet = {\n              cmd: 'publish',\n              topic: topic,\n              payload: message,\n              qos: opts.qos,\n              retain: opts.retain,\n              messageId: this._nextId(),\n              dup: opts.dup\n            };\n\n            if (options.protocolVersion === 5) {\n              packet.properties = opts.properties;\n\n              if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n                /*\n                if we are don`t setup topic alias or\n                topic alias maximum less than topic alias or\n                server don`t give topic alias maximum,\n                we are removing topic alias from packet\n                */\n                delete packet.properties.topicAlias;\n              }\n            }\n\n            debug('publish :: qos', opts.qos);\n\n            switch (opts.qos) {\n              case 1:\n              case 2:\n                // Add to callbacks\n                this.outgoing[packet.messageId] = {\n                  volatile: false,\n                  cb: callback || nop\n                };\n\n                if (this._storeProcessing) {\n                  debug('_storeProcessing enabled');\n                  this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n\n                  this._storePacket(packet, undefined, opts.cbStorePut);\n                } else {\n                  debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n                  this._sendPacket(packet, undefined, opts.cbStorePut);\n                }\n\n                break;\n\n              default:\n                if (this._storeProcessing) {\n                  debug('_storeProcessing enabled');\n\n                  this._storePacket(packet, callback, opts.cbStorePut);\n                } else {\n                  debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n                  this._sendPacket(packet, callback, opts.cbStorePut);\n                }\n\n                break;\n            }\n\n            return this;\n          };\n          /**\n           * subscribe - subscribe to <topic>\n           *\n           * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n           * @param {Object} [opts] - optional subscription options, includes:\n           *    {Number} qos - subscribe qos level\n           * @param {Function} [callback] - function(err, granted){} where:\n           *    {Error} err - subscription error (none at the moment!)\n           *    {Array} granted - array of {topic: 't', qos: 0}\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           * @example client.subscribe('topic');\n           * @example client.subscribe('topic', {qos: 1});\n           * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n           * @example client.subscribe('topic', console.log);\n           */\n\n\n          MqttClient.prototype.subscribe = function () {\n            var packet;\n            var args = new Array(arguments.length);\n\n            for (var i = 0; i < arguments.length; i++) {\n              args[i] = arguments[i];\n            }\n\n            var subs = [];\n            var obj = args.shift();\n            var resubscribe = obj.resubscribe;\n            var callback = args.pop() || nop;\n            var opts = args.pop();\n            var invalidTopic;\n            var that = this;\n            var version = this.options.protocolVersion;\n            delete obj.resubscribe;\n\n            if (typeof obj === 'string') {\n              obj = [obj];\n            }\n\n            if (typeof callback !== 'function') {\n              opts = callback;\n              callback = nop;\n            }\n\n            invalidTopic = validations.validateTopics(obj);\n\n            if (invalidTopic !== null) {\n              setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n              return this;\n            }\n\n            if (this._checkDisconnecting(callback)) {\n              debug('subscribe: discconecting true');\n              return this;\n            }\n\n            var defaultOpts = {\n              qos: 0\n            };\n\n            if (version === 5) {\n              defaultOpts.nl = false;\n              defaultOpts.rap = false;\n              defaultOpts.rh = 0;\n            }\n\n            opts = xtend(defaultOpts, opts);\n\n            if (Array.isArray(obj)) {\n              obj.forEach(function (topic) {\n                debug('subscribe: array topic %s', topic);\n\n                if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n                  var currentOpts = {\n                    topic: topic,\n                    qos: opts.qos\n                  };\n\n                  if (version === 5) {\n                    currentOpts.nl = opts.nl;\n                    currentOpts.rap = opts.rap;\n                    currentOpts.rh = opts.rh;\n                    currentOpts.properties = opts.properties;\n                  }\n\n                  debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n                  subs.push(currentOpts);\n                }\n              });\n            } else {\n              Object.keys(obj).forEach(function (k) {\n                debug('subscribe: object topic %s', k);\n\n                if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n                  var currentOpts = {\n                    topic: k,\n                    qos: obj[k].qos\n                  };\n\n                  if (version === 5) {\n                    currentOpts.nl = obj[k].nl;\n                    currentOpts.rap = obj[k].rap;\n                    currentOpts.rh = obj[k].rh;\n                    currentOpts.properties = opts.properties;\n                  }\n\n                  debug('subscribe: pushing `%s` to subs list', currentOpts);\n                  subs.push(currentOpts);\n                }\n              });\n            }\n\n            packet = {\n              cmd: 'subscribe',\n              subscriptions: subs,\n              qos: 1,\n              retain: false,\n              dup: false,\n              messageId: this._nextId()\n            };\n\n            if (opts.properties) {\n              packet.properties = opts.properties;\n            }\n\n            if (!subs.length) {\n              callback(null, []);\n              return;\n            } // subscriptions to resubscribe to in case of disconnect\n\n\n            if (this.options.resubscribe) {\n              debug('subscribe :: resubscribe true');\n              var topics = [];\n              subs.forEach(function (sub) {\n                if (that.options.reconnectPeriod > 0) {\n                  var topic = {\n                    qos: sub.qos\n                  };\n\n                  if (version === 5) {\n                    topic.nl = sub.nl || false;\n                    topic.rap = sub.rap || false;\n                    topic.rh = sub.rh || 0;\n                    topic.properties = sub.properties;\n                  }\n\n                  that._resubscribeTopics[sub.topic] = topic;\n                  topics.push(sub.topic);\n                }\n              });\n              that.messageIdToTopic[packet.messageId] = topics;\n            }\n\n            this.outgoing[packet.messageId] = {\n              volatile: true,\n              cb: function (err, packet) {\n                if (!err) {\n                  var granted = packet.granted;\n\n                  for (var i = 0; i < granted.length; i += 1) {\n                    subs[i].qos = granted[i];\n                  }\n                }\n\n                callback(err, subs);\n              }\n            };\n            debug('subscribe :: call _sendPacket');\n\n            this._sendPacket(packet);\n\n            return this;\n          };\n          /**\n           * unsubscribe - unsubscribe from topic(s)\n           *\n           * @param {String, Array} topic - topics to unsubscribe from\n           * @param {Object} [opts] - optional subscription options, includes:\n           *    {Object} properties - properties of unsubscribe packet\n           * @param {Function} [callback] - callback fired on unsuback\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           * @example client.unsubscribe('topic');\n           * @example client.unsubscribe('topic', console.log);\n           */\n\n\n          MqttClient.prototype.unsubscribe = function () {\n            var packet = {\n              cmd: 'unsubscribe',\n              qos: 1,\n              messageId: this._nextId()\n            };\n            var that = this;\n            var args = new Array(arguments.length);\n\n            for (var i = 0; i < arguments.length; i++) {\n              args[i] = arguments[i];\n            }\n\n            var topic = args.shift();\n            var callback = args.pop() || nop;\n            var opts = args.pop();\n\n            if (typeof topic === 'string') {\n              topic = [topic];\n            }\n\n            if (typeof callback !== 'function') {\n              opts = callback;\n              callback = nop;\n            }\n\n            if (this._checkDisconnecting(callback)) {\n              return this;\n            }\n\n            if (typeof topic === 'string') {\n              packet.unsubscriptions = [topic];\n            } else if (Array.isArray(topic)) {\n              packet.unsubscriptions = topic;\n            }\n\n            if (this.options.resubscribe) {\n              packet.unsubscriptions.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n\n            if (typeof opts === 'object' && opts.properties) {\n              packet.properties = opts.properties;\n            }\n\n            this.outgoing[packet.messageId] = {\n              volatile: true,\n              cb: callback\n            };\n            debug('unsubscribe: call _sendPacket');\n\n            this._sendPacket(packet);\n\n            return this;\n          };\n          /**\n           * end - close connection\n           *\n           * @returns {MqttClient} this - for chaining\n           * @param {Boolean} force - do not wait for all in-flight messages to be acked\n           * @param {Object} opts - added to the disconnect packet\n           * @param {Function} cb - called when the client has been closed\n           *\n           * @api public\n           */\n\n\n          MqttClient.prototype.end = function (force, opts, cb) {\n            var that = this;\n            debug('end :: (%s)', this.options.clientId);\n\n            if (force == null || typeof force !== 'boolean') {\n              cb = opts || nop;\n              opts = force;\n              force = false;\n\n              if (typeof opts !== 'object') {\n                cb = opts;\n                opts = null;\n\n                if (typeof cb !== 'function') {\n                  cb = nop;\n                }\n              }\n            }\n\n            if (typeof opts !== 'object') {\n              cb = opts;\n              opts = null;\n            }\n\n            debug('end :: cb? %s', !!cb);\n            cb = cb || nop;\n\n            function closeStores() {\n              debug('end :: closeStores: closing incoming and outgoing stores');\n              that.disconnected = true;\n              that.incomingStore.close(function (e1) {\n                that.outgoingStore.close(function (e2) {\n                  debug('end :: closeStores: emitting end');\n                  that.emit('end');\n\n                  if (cb) {\n                    let err = e1 || e2;\n                    debug('end :: closeStores: invoking callback with args');\n                    cb(err);\n                  }\n                });\n              });\n\n              if (that._deferredReconnect) {\n                that._deferredReconnect();\n              }\n            }\n\n            function finish() {\n              // defer closesStores of an I/O cycle,\n              // just to make sure things are\n              // ok for websockets\n              debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n\n              that._cleanUp(force, () => {\n                debug('end :: finish :: calling process.nextTick on closeStores'); // var boundProcess = nextTick.bind(null, closeStores)\n\n                nextTick(closeStores.bind(that));\n              }, opts);\n            }\n\n            if (this.disconnecting) {\n              cb();\n              return this;\n            }\n\n            this._clearReconnect();\n\n            this.disconnecting = true;\n\n            if (!force && Object.keys(this.outgoing).length > 0) {\n              // wait 10ms, just to be sure we received all of it\n              debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n              this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n            } else {\n              debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n              finish();\n            }\n\n            return this;\n          };\n          /**\n           * removeOutgoingMessage - remove a message in outgoing store\n           * the outgoing callback will be called withe Error('Message removed') if the message is removed\n           *\n           * @param {Number} messageId - messageId to remove message\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           *\n           * @example client.removeOutgoingMessage(client.getLastMessageId());\n           */\n\n\n          MqttClient.prototype.removeOutgoingMessage = function (messageId) {\n            var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n            delete this.outgoing[messageId];\n            this.outgoingStore.del({\n              messageId: messageId\n            }, function () {\n              cb(new Error('Message removed'));\n            });\n            return this;\n          };\n          /**\n           * reconnect - connect again using the same options as connect()\n           *\n           * @param {Object} [opts] - optional reconnect options, includes:\n           *    {Store} incomingStore - a store for the incoming packets\n           *    {Store} outgoingStore - a store for the outgoing packets\n           *    if opts is not given, current stores are used\n           * @returns {MqttClient} this - for chaining\n           *\n           * @api public\n           */\n\n\n          MqttClient.prototype.reconnect = function (opts) {\n            debug('client reconnect');\n            var that = this;\n\n            var f = function () {\n              if (opts) {\n                that.options.incomingStore = opts.incomingStore;\n                that.options.outgoingStore = opts.outgoingStore;\n              } else {\n                that.options.incomingStore = null;\n                that.options.outgoingStore = null;\n              }\n\n              that.incomingStore = that.options.incomingStore || new Store();\n              that.outgoingStore = that.options.outgoingStore || new Store();\n              that.disconnecting = false;\n              that.disconnected = false;\n              that._deferredReconnect = null;\n\n              that._reconnect();\n            };\n\n            if (this.disconnecting && !this.disconnected) {\n              this._deferredReconnect = f;\n            } else {\n              f();\n            }\n\n            return this;\n          };\n          /**\n           * _reconnect - implement reconnection\n           * @api privateish\n           */\n\n\n          MqttClient.prototype._reconnect = function () {\n            debug('_reconnect: emitting reconnect to client');\n            this.emit('reconnect');\n\n            if (this.connected) {\n              this.end(() => {\n                this._setupStream();\n              });\n              debug('client already connected. disconnecting first.');\n            } else {\n              debug('_reconnect: calling _setupStream');\n\n              this._setupStream();\n            }\n          };\n          /**\n           * _setupReconnect - setup reconnect timer\n           */\n\n\n          MqttClient.prototype._setupReconnect = function () {\n            var that = this;\n\n            if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n              if (!this.reconnecting) {\n                debug('_setupReconnect :: emit `offline` state');\n                this.emit('offline');\n                debug('_setupReconnect :: set `reconnecting` to `true`');\n                this.reconnecting = true;\n              }\n\n              debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n              that.reconnectTimer = setInterval(function () {\n                debug('reconnectTimer :: reconnect triggered!');\n\n                that._reconnect();\n              }, that.options.reconnectPeriod);\n            } else {\n              debug('_setupReconnect :: doing nothing...');\n            }\n          };\n          /**\n           * _clearReconnect - clear the reconnect timer\n           */\n\n\n          MqttClient.prototype._clearReconnect = function () {\n            debug('_clearReconnect : clearing reconnect timer');\n\n            if (this.reconnectTimer) {\n              clearInterval(this.reconnectTimer);\n              this.reconnectTimer = null;\n            }\n          };\n          /**\n           * _cleanUp - clean up on connection end\n           * @api private\n           */\n\n\n          MqttClient.prototype._cleanUp = function (forced, done) {\n            var opts = arguments[2];\n\n            if (done) {\n              debug('_cleanUp :: done callback provided for on stream close');\n              this.stream.on('close', done);\n            }\n\n            debug('_cleanUp :: forced? %s', forced);\n\n            if (forced) {\n              if (this.options.reconnectPeriod === 0 && this.options.clean) {\n                flush(this.outgoing);\n              }\n\n              debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n              this.stream.destroy();\n            } else {\n              var packet = xtend({\n                cmd: 'disconnect'\n              }, opts);\n              debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n\n              this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n            }\n\n            if (!this.disconnecting) {\n              debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n\n              this._clearReconnect();\n\n              this._setupReconnect();\n            }\n\n            if (this.pingTimer !== null) {\n              debug('_cleanUp :: clearing pingTimer');\n              this.pingTimer.clear();\n              this.pingTimer = null;\n            }\n\n            if (done && !this.connected) {\n              debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n              this.stream.removeListener('close', done);\n              done();\n            }\n          };\n          /**\n           * _sendPacket - send or queue a packet\n           * @param {Object} packet - packet options\n           * @param {Function} cb - callback when the packet is sent\n           * @param {Function} cbStorePut - called when message is put into outgoingStore\n           * @api private\n           */\n\n\n          MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n            debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n            cbStorePut = cbStorePut || nop;\n\n            if (!this.connected) {\n              debug('_sendPacket :: client not connected. Storing packet offline.');\n\n              this._storePacket(packet, cb, cbStorePut);\n\n              return;\n            } // When sending a packet, reschedule the ping timer\n\n\n            this._shiftPingInterval();\n\n            switch (packet.cmd) {\n              case 'publish':\n                break;\n\n              case 'pubrel':\n                storeAndSend(this, packet, cb, cbStorePut);\n                return;\n\n              default:\n                sendPacket(this, packet, cb);\n                return;\n            }\n\n            switch (packet.qos) {\n              case 2:\n              case 1:\n                storeAndSend(this, packet, cb, cbStorePut);\n                break;\n\n              /**\n               * no need of case here since it will be caught by default\n               * and jshint comply that before default it must be a break\n               * anyway it will result in -1 evaluation\n               */\n\n              case 0:\n              /* falls through */\n\n              default:\n                sendPacket(this, packet, cb);\n                break;\n            }\n\n            debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n          };\n          /**\n           * _storePacket - queue a packet\n           * @param {Object} packet - packet options\n           * @param {Function} cb - callback when the packet is sent\n           * @param {Function} cbStorePut - called when message is put into outgoingStore\n           * @api private\n           */\n\n\n          MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n            debug('_storePacket :: packet: %o', packet);\n            debug('_storePacket :: cb? %s', !!cb);\n            cbStorePut = cbStorePut || nop; // check that the packet is not a qos of 0, or that the command is not a publish\n\n            if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n              this.queue.push({\n                packet: packet,\n                cb: cb\n              });\n            } else if (packet.qos > 0) {\n              cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n              this.outgoingStore.put(packet, function (err) {\n                if (err) {\n                  return cb && cb(err);\n                }\n\n                cbStorePut();\n              });\n            } else if (cb) {\n              cb(new Error('No connection to broker'));\n            }\n          };\n          /**\n           * _setupPingTimer - setup the ping timer\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._setupPingTimer = function () {\n            debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n            var that = this;\n\n            if (!this.pingTimer && this.options.keepalive) {\n              this.pingResp = true;\n              this.pingTimer = reInterval(function () {\n                that._checkPing();\n              }, this.options.keepalive * 1000);\n            }\n          };\n          /**\n           * _shiftPingInterval - reschedule the ping interval\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._shiftPingInterval = function () {\n            if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n              this.pingTimer.reschedule(this.options.keepalive * 1000);\n            }\n          };\n          /**\n           * _checkPing - check if a pingresp has come back, and ping the server again\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._checkPing = function () {\n            debug('_checkPing :: checking ping...');\n\n            if (this.pingResp) {\n              debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n              this.pingResp = false;\n\n              this._sendPacket({\n                cmd: 'pingreq'\n              });\n            } else {\n              // do a forced cleanup since socket will be in bad shape\n              debug('_checkPing :: calling _cleanUp with force true');\n\n              this._cleanUp(true);\n            }\n          };\n          /**\n           * _handlePingresp - handle a pingresp\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._handlePingresp = function () {\n            this.pingResp = true;\n          };\n          /**\n           * _handleConnack\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleConnack = function (packet) {\n            debug('_handleConnack');\n            var options = this.options;\n            var version = options.protocolVersion;\n            var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n            clearTimeout(this.connackTimer);\n\n            if (packet.properties) {\n              if (packet.properties.topicAliasMaximum) {\n                if (!options.properties) {\n                  options.properties = {};\n                }\n\n                options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n              }\n\n              if (packet.properties.serverKeepAlive && options.keepalive) {\n                options.keepalive = packet.properties.serverKeepAlive;\n\n                this._shiftPingInterval();\n              }\n\n              if (packet.properties.maximumPacketSize) {\n                if (!options.properties) {\n                  options.properties = {};\n                }\n\n                options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n              }\n            }\n\n            if (rc === 0) {\n              this.reconnecting = false;\n\n              this._onConnect(packet);\n            } else if (rc > 0) {\n              var err = new Error('Connection refused: ' + errors[rc]);\n              err.code = rc;\n              this.emit('error', err);\n            }\n          };\n          /**\n           * _handlePublish\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n          /*\n          those late 2 case should be rewrite to comply with coding style:\n          \n          case 1:\n          case 0:\n            // do not wait sending a puback\n            // no callback passed\n            if (1 === qos) {\n              this._sendPacket({\n                cmd: 'puback',\n                messageId: messageId\n              });\n            }\n            // emit the message event for both qos 1 and 0\n            this.emit('message', topic, message, packet);\n            this.handleMessage(packet, done);\n            break;\n          default:\n            // do nothing but every switch mus have a default\n            // log or throw an error about unknown qos\n            break;\n          \n          for now i just suppressed the warnings\n          */\n\n\n          MqttClient.prototype._handlePublish = function (packet, done) {\n            debug('_handlePublish: packet %o', packet);\n            done = typeof done !== 'undefined' ? done : nop;\n            var topic = packet.topic.toString();\n            var message = packet.payload;\n            var qos = packet.qos;\n            var messageId = packet.messageId;\n            var that = this;\n            var options = this.options;\n            var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n            debug('_handlePublish: qos %d', qos);\n\n            switch (qos) {\n              case 2:\n                {\n                  options.customHandleAcks(topic, message, packet, function (error, code) {\n                    if (!(error instanceof Error)) {\n                      code = error;\n                      error = null;\n                    }\n\n                    if (error) {\n                      return that.emit('error', error);\n                    }\n\n                    if (validReasonCodes.indexOf(code) === -1) {\n                      return that.emit('error', new Error('Wrong reason code for pubrec'));\n                    }\n\n                    if (code) {\n                      that._sendPacket({\n                        cmd: 'pubrec',\n                        messageId: messageId,\n                        reasonCode: code\n                      }, done);\n                    } else {\n                      that.incomingStore.put(packet, function () {\n                        that._sendPacket({\n                          cmd: 'pubrec',\n                          messageId: messageId\n                        }, done);\n                      });\n                    }\n                  });\n                  break;\n                }\n\n              case 1:\n                {\n                  // emit the message event\n                  options.customHandleAcks(topic, message, packet, function (error, code) {\n                    if (!(error instanceof Error)) {\n                      code = error;\n                      error = null;\n                    }\n\n                    if (error) {\n                      return that.emit('error', error);\n                    }\n\n                    if (validReasonCodes.indexOf(code) === -1) {\n                      return that.emit('error', new Error('Wrong reason code for puback'));\n                    }\n\n                    if (!code) {\n                      that.emit('message', topic, message, packet);\n                    }\n\n                    that.handleMessage(packet, function (err) {\n                      if (err) {\n                        return done && done(err);\n                      }\n\n                      that._sendPacket({\n                        cmd: 'puback',\n                        messageId: messageId,\n                        reasonCode: code\n                      }, done);\n                    });\n                  });\n                  break;\n                }\n\n              case 0:\n                // emit the message event\n                this.emit('message', topic, message, packet);\n                this.handleMessage(packet, done);\n                break;\n\n              default:\n                // do nothing\n                debug('_handlePublish: unknown QoS. Doing nothing.'); // log or throw an error about unknown qos\n\n                break;\n            }\n          };\n          /**\n           * Handle messages with backpressure support, one at a time.\n           * Override at will.\n           *\n           * @param Packet packet the packet\n           * @param Function callback call when finished\n           * @api public\n           */\n\n\n          MqttClient.prototype.handleMessage = function (packet, callback) {\n            callback();\n          };\n          /**\n           * _handleAck\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleAck = function (packet) {\n            /* eslint no-fallthrough: \"off\" */\n            var messageId = packet.messageId;\n            var type = packet.cmd;\n            var response = null;\n            var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n            var that = this;\n            var err;\n\n            if (!cb) {\n              debug('_handleAck :: Server sent an ack in error. Ignoring.'); // Server sent an ack in error, ignore it.\n\n              return;\n            } // Process\n\n\n            debug('_handleAck :: packet type', type);\n\n            switch (type) {\n              case 'pubcomp': // same thing as puback for QoS 2\n\n              case 'puback':\n                var pubackRC = packet.reasonCode; // Callback - we're done\n\n                if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n                  err = new Error('Publish error: ' + errors[pubackRC]);\n                  err.code = pubackRC;\n                  cb(err, packet);\n                }\n\n                delete this.outgoing[messageId];\n                this.outgoingStore.del(packet, cb);\n                break;\n\n              case 'pubrec':\n                response = {\n                  cmd: 'pubrel',\n                  qos: 2,\n                  messageId: messageId\n                };\n                var pubrecRC = packet.reasonCode;\n\n                if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n                  err = new Error('Publish error: ' + errors[pubrecRC]);\n                  err.code = pubrecRC;\n                  cb(err, packet);\n                } else {\n                  this._sendPacket(response);\n                }\n\n                break;\n\n              case 'suback':\n                delete this.outgoing[messageId];\n\n                for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n                  if ((packet.granted[grantedI] & 0x80) !== 0) {\n                    // suback with Failure status\n                    var topics = this.messageIdToTopic[messageId];\n\n                    if (topics) {\n                      topics.forEach(function (topic) {\n                        delete that._resubscribeTopics[topic];\n                      });\n                    }\n                  }\n                }\n\n                cb(null, packet);\n                break;\n\n              case 'unsuback':\n                delete this.outgoing[messageId];\n                cb(null);\n                break;\n\n              default:\n                that.emit('error', new Error('unrecognized packet type'));\n            }\n\n            if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n              this.emit('outgoingEmpty');\n            }\n          };\n          /**\n           * _handlePubrel\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handlePubrel = function (packet, callback) {\n            debug('handling pubrel packet');\n            callback = typeof callback !== 'undefined' ? callback : nop;\n            var messageId = packet.messageId;\n            var that = this;\n            var comp = {\n              cmd: 'pubcomp',\n              messageId: messageId\n            };\n            that.incomingStore.get(packet, function (err, pub) {\n              if (!err) {\n                that.emit('message', pub.topic, pub.payload, pub);\n                that.handleMessage(pub, function (err) {\n                  if (err) {\n                    return callback(err);\n                  }\n\n                  that.incomingStore.del(pub, nop);\n\n                  that._sendPacket(comp, callback);\n                });\n              } else {\n                that._sendPacket(comp, callback);\n              }\n            });\n          };\n          /**\n           * _handleDisconnect\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleDisconnect = function (packet) {\n            this.emit('disconnect', packet);\n          };\n          /**\n           * _nextId\n           * @return unsigned int\n           */\n\n\n          MqttClient.prototype._nextId = function () {\n            // id becomes current state of this.nextId and increments afterwards\n            var id = this.nextId++; // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n\n            if (this.nextId === 65536) {\n              this.nextId = 1;\n            }\n\n            return id;\n          };\n          /**\n           * getLastMessageId\n           * @return unsigned int\n           */\n\n\n          MqttClient.prototype.getLastMessageId = function () {\n            return this.nextId === 1 ? 65535 : this.nextId - 1;\n          };\n          /**\n           * _resubscribe\n           * @api private\n           */\n\n\n          MqttClient.prototype._resubscribe = function (connack) {\n            debug('_resubscribe');\n\n            var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n            if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n              if (this.options.resubscribe) {\n                if (this.options.protocolVersion === 5) {\n                  debug('_resubscribe: protocolVersion 5');\n\n                  for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n                    var resubscribeTopic = {};\n                    resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n                    resubscribeTopic.resubscribe = true;\n                    this.subscribe(resubscribeTopic, {\n                      properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n                    });\n                  }\n                } else {\n                  this._resubscribeTopics.resubscribe = true;\n                  this.subscribe(this._resubscribeTopics);\n                }\n              } else {\n                this._resubscribeTopics = {};\n              }\n            }\n\n            this._firstConnection = false;\n          };\n          /**\n           * _onConnect\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._onConnect = function (packet) {\n            if (this.disconnected) {\n              this.emit('connect', packet);\n              return;\n            }\n\n            var that = this;\n\n            this._setupPingTimer();\n\n            this._resubscribe(packet);\n\n            this.connected = true;\n\n            function startStreamProcess() {\n              var outStore = that.outgoingStore.createStream();\n\n              function clearStoreProcessing() {\n                that._storeProcessing = false;\n                that._packetIdsDuringStoreProcessing = {};\n              }\n\n              that.once('close', remove);\n              outStore.on('error', function (err) {\n                clearStoreProcessing();\n                that.removeListener('close', remove);\n                that.emit('error', err);\n              });\n\n              function remove() {\n                outStore.destroy();\n                outStore = null;\n                clearStoreProcessing();\n              }\n\n              function storeDeliver() {\n                // edge case, we wrapped this twice\n                if (!outStore) {\n                  return;\n                }\n\n                that._storeProcessing = true;\n                var packet = outStore.read(1);\n                var cb;\n\n                if (!packet) {\n                  // read when data is available in the future\n                  outStore.once('readable', storeDeliver);\n                  return;\n                } // Skip already processed store packets\n\n\n                if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n                  storeDeliver();\n                  return;\n                } // Avoid unnecessary stream read operations when disconnected\n\n\n                if (!that.disconnecting && !that.reconnectTimer) {\n                  cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n                  that.outgoing[packet.messageId] = {\n                    volatile: false,\n                    cb: function (err, status) {\n                      // Ensure that the original callback passed in to publish gets invoked\n                      if (cb) {\n                        cb(err, status);\n                      }\n\n                      storeDeliver();\n                    }\n                  };\n                  that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n                  that._sendPacket(packet);\n                } else if (outStore.destroy) {\n                  outStore.destroy();\n                }\n              }\n\n              outStore.on('end', function () {\n                var allProcessed = true;\n\n                for (var id in that._packetIdsDuringStoreProcessing) {\n                  if (!that._packetIdsDuringStoreProcessing[id]) {\n                    allProcessed = false;\n                    break;\n                  }\n                }\n\n                if (allProcessed) {\n                  clearStoreProcessing();\n                  that.removeListener('close', remove);\n                  that.emit('connect', packet);\n                } else {\n                  startStreamProcess();\n                }\n              });\n              storeDeliver();\n            } // start flowing\n\n\n            startStreamProcess();\n          };\n\n          module.exports = MqttClient;\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./store\": 13,\n      \"./validations\": 14,\n      \"_process\": 69,\n      \"debug\": 19,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"mqtt-packet\": 38,\n      \"readable-stream\": 60,\n      \"reinterval\": 61,\n      \"xtend\": 68\n    }],\n    8: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          'use strict';\n\n          var Transform = require('readable-stream').Transform;\n\n          var duplexify = require('duplexify');\n          /* global FileReader */\n\n\n          var my;\n          var proxy;\n          var stream;\n          var isInitialized = false;\n\n          function buildProxy() {\n            var proxy = new Transform();\n\n            proxy._write = function (chunk, encoding, next) {\n              my.sendSocketMessage({\n                data: chunk.buffer,\n                success: function () {\n                  next();\n                },\n                fail: function () {\n                  next(new Error());\n                }\n              });\n            };\n\n            proxy._flush = function socketEnd(done) {\n              my.closeSocket({\n                success: function () {\n                  done();\n                }\n              });\n            };\n\n            return proxy;\n          }\n\n          function setDefaultOpts(opts) {\n            if (!opts.hostname) {\n              opts.hostname = 'localhost';\n            }\n\n            if (!opts.path) {\n              opts.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              opts.wsOptions = {};\n            }\n          }\n\n          function buildUrl(opts, client) {\n            var protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n            var url = protocol + '://' + opts.hostname + opts.path;\n\n            if (opts.port && opts.port !== 80 && opts.port !== 443) {\n              url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n            }\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function bindEventHandler() {\n            if (isInitialized) return;\n            isInitialized = true;\n            my.onSocketOpen(function () {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            });\n            my.onSocketMessage(function (res) {\n              if (typeof res.data === 'string') {\n                var buffer = Buffer.from(res.data, 'base64');\n                proxy.push(buffer);\n              } else {\n                var reader = new FileReader();\n                reader.addEventListener('load', function () {\n                  var data = reader.result;\n                  if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n                  proxy.push(data);\n                });\n                reader.readAsArrayBuffer(res.data);\n              }\n            });\n            my.onSocketClose(function () {\n              stream.end();\n              stream.destroy();\n            });\n            my.onSocketError(function (res) {\n              stream.destroy(res);\n            });\n          }\n\n          function buildStream(client, opts) {\n            opts.hostname = opts.hostname || opts.host;\n\n            if (!opts.hostname) {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n\n            var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            setDefaultOpts(opts);\n            var url = buildUrl(opts, client);\n            my = opts.my;\n            my.connectSocket({\n              url: url,\n              protocols: websocketSubProtocol\n            });\n            proxy = buildProxy();\n            stream = duplexify.obj();\n            bindEventHandler();\n            return stream;\n          }\n\n          module.exports = buildStream;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3,\n      \"duplexify\": 21,\n      \"readable-stream\": 60\n    }],\n    9: [function (require, module, exports) {\n      'use strict';\n\n      var net = require('net');\n\n      var debug = require('debug')('mqttjs:tcp');\n      /*\n        variables port and host can be removed since\n        you have all required information in opts object\n      */\n\n\n      function streamBuilder(client, opts) {\n        var port, host;\n        opts.port = opts.port || 1883;\n        opts.hostname = opts.hostname || opts.host || 'localhost';\n        port = opts.port;\n        host = opts.hostname;\n        debug('port %d and host %s', port, host);\n        return net.createConnection(port, host);\n      }\n\n      module.exports = streamBuilder;\n    }, {\n      \"debug\": 19,\n      \"net\": 2\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      var tls = require('tls');\n\n      var debug = require('debug')('mqttjs:tls');\n\n      function buildBuilder(mqttClient, opts) {\n        var connection;\n        opts.port = opts.port || 8883;\n        opts.host = opts.hostname || opts.host || 'localhost';\n        opts.servername = opts.host;\n        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n        delete opts.path;\n        debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);\n        connection = tls.connect(opts);\n        /* eslint no-use-before-define: [2, \"nofunc\"] */\n\n        connection.on('secureConnect', function () {\n          if (opts.rejectUnauthorized && !connection.authorized) {\n            connection.emit('error', new Error('TLS not authorized'));\n          } else {\n            connection.removeListener('error', handleTLSerrors);\n          }\n        });\n\n        function handleTLSerrors(err) {\n          // How can I get verify this error is a tls error?\n          if (opts.rejectUnauthorized) {\n            mqttClient.emit('error', err);\n          } // close this connection to match the behaviour of net\n          // otherwise all we get is an error from the connection\n          // and close event doesn't fire. This is a work around\n          // to enable the reconnect code to work the same as with\n          // net.createConnection\n\n\n          connection.end();\n        }\n\n        connection.on('error', handleTLSerrors);\n        return connection;\n      }\n\n      module.exports = buildBuilder;\n    }, {\n      \"debug\": 19,\n      \"tls\": 2\n    }],\n    11: [function (require, module, exports) {\n      (function (process, Buffer) {\n        (function () {\n          'use strict';\n\n          const WS = require('ws');\n\n          const debug = require('debug')('mqttjs:ws');\n\n          const duplexify = require('duplexify');\n\n          const Transform = require('readable-stream').Transform;\n\n          let WSS_OPTIONS = ['rejectUnauthorized', 'ca', 'cert', 'key', 'pfx', 'passphrase']; // eslint-disable-next-line camelcase\n\n          const IS_BROWSER = typeof process !== 'undefined' && process.title === 'browser' || typeof __webpack_require__ === 'function';\n\n          function buildUrl(opts, client) {\n            let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function setDefaultOpts(opts) {\n            let options = opts;\n\n            if (!opts.hostname) {\n              options.hostname = 'localhost';\n            }\n\n            if (!opts.port) {\n              if (opts.protocol === 'wss') {\n                options.port = 443;\n              } else {\n                options.port = 80;\n              }\n            }\n\n            if (!opts.path) {\n              options.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              options.wsOptions = {};\n            }\n\n            if (!IS_BROWSER && opts.protocol === 'wss') {\n              // Add cert/key/ca etc options\n              WSS_OPTIONS.forEach(function (prop) {\n                if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n                  options.wsOptions[prop] = opts[prop];\n                }\n              });\n            }\n\n            return options;\n          }\n\n          function setDefaultBrowserOpts(opts) {\n            let options = setDefaultOpts(opts);\n\n            if (!options.hostname) {\n              options.hostname = options.host;\n            }\n\n            if (!options.hostname) {\n              // Throwing an error in a Web Worker if no `hostname` is given, because we\n              // can not determine the `hostname` automatically.  If connecting to\n              // localhost, please supply the `hostname` as an argument.\n              if (typeof document === 'undefined') {\n                throw new Error('Could not determine host. Specify host manually.');\n              }\n\n              const parsed = new URL(document.URL);\n              options.hostname = parsed.hostname;\n\n              if (!options.port) {\n                options.port = parsed.port;\n              }\n            } // objectMode should be defined for logic\n\n\n            if (options.objectMode === undefined) {\n              options.objectMode = !(options.binary === true || options.binary === undefined);\n            }\n\n            return options;\n          }\n\n          function createWebSocket(client, url, opts) {\n            debug('createWebSocket');\n            debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion);\n            const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol);\n            let socket = new WS(url, [websocketSubProtocol], opts.wsOptions);\n            return socket;\n          }\n\n          function createBrowserWebSocket(client, opts) {\n            const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            let url = buildUrl(opts, client);\n            /* global WebSocket */\n\n            let socket = new WebSocket(url, [websocketSubProtocol]);\n            socket.binaryType = 'arraybuffer';\n            return socket;\n          }\n\n          function streamBuilder(client, opts) {\n            debug('streamBuilder');\n            let options = setDefaultOpts(opts);\n            const url = buildUrl(options, client);\n            let socket = createWebSocket(client, url, options);\n            let webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);\n            webSocketStream.url = url;\n            return webSocketStream;\n          }\n\n          function browserStreamBuilder(client, opts) {\n            debug('browserStreamBuilder');\n            let stream;\n            let options = setDefaultBrowserOpts(opts); // sets the maximum socket buffer size before throttling\n\n            const bufferSize = options.browserBufferSize || 1024 * 512;\n            const bufferTimeout = opts.browserBufferTimeout || 1000;\n            const coerceToBuffer = !opts.objectMode;\n            let socket = createBrowserWebSocket(client, opts);\n            let proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);\n\n            if (!opts.objectMode) {\n              proxy._writev = writev;\n            }\n\n            proxy.on('close', () => {\n              socket.close();\n            });\n            const eventListenerSupport = typeof socket.addEventListener === 'undefined'; // was already open when passed in\n\n            if (socket.readyState === socket.OPEN) {\n              stream = proxy;\n            } else {\n              stream = stream = duplexify(undefined, undefined, opts);\n\n              if (!opts.objectMode) {\n                stream._writev = writev;\n              }\n\n              if (eventListenerSupport) {\n                socket.addEventListener('open', onopen);\n              } else {\n                socket.onopen = onopen;\n              }\n            }\n\n            stream.socket = socket;\n\n            if (eventListenerSupport) {\n              socket.addEventListener('close', onclose);\n              socket.addEventListener('error', onerror);\n              socket.addEventListener('message', onmessage);\n            } else {\n              socket.onclose = onclose;\n              socket.onerror = onerror;\n              socket.onmessage = onmessage;\n            } // methods for browserStreamBuilder\n\n\n            function buildProxy(options, socketWrite, socketEnd) {\n              let proxy = new Transform({\n                objectModeMode: options.objectMode\n              });\n              proxy._write = socketWrite;\n              proxy._flush = socketEnd;\n              return proxy;\n            }\n\n            function onopen() {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            }\n\n            function onclose() {\n              stream.end();\n              stream.destroy();\n            }\n\n            function onerror(err) {\n              stream.destroy(err);\n            }\n\n            function onmessage(event) {\n              let data = event.data;\n              if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n              proxy.push(data);\n            } // this is to be enabled only if objectMode is false\n\n\n            function writev(chunks, cb) {\n              const buffers = new Array(chunks.length);\n\n              for (let i = 0; i < chunks.length; i++) {\n                if (typeof chunks[i].chunk === 'string') {\n                  buffers[i] = Buffer.from(chunks[i], 'utf8');\n                } else {\n                  buffers[i] = chunks[i].chunk;\n                }\n              }\n\n              this._write(Buffer.concat(buffers), 'binary', cb);\n            }\n\n            function socketWriteBrowser(chunk, enc, next) {\n              if (socket.bufferedAmount > bufferSize) {\n                // throttle data until buffered amount is reduced.\n                setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n              }\n\n              if (coerceToBuffer && typeof chunk === 'string') {\n                chunk = Buffer.from(chunk, 'utf8');\n              }\n\n              try {\n                socket.send(chunk);\n              } catch (err) {\n                return next(err);\n              }\n\n              next();\n            }\n\n            function socketEndBrowser(done) {\n              socket.close();\n              done();\n            } // end methods for browserStreamBuilder\n\n\n            return stream;\n          }\n\n          if (IS_BROWSER) {\n            module.exports = browserStreamBuilder;\n          } else {\n            module.exports = streamBuilder;\n          }\n        }).call(this);\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"debug\": 19,\n      \"duplexify\": 21,\n      \"readable-stream\": 60,\n      \"ws\": 67\n    }],\n    12: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          'use strict';\n\n          var Transform = require('readable-stream').Transform;\n\n          var duplexify = require('duplexify');\n          /* global wx */\n\n\n          var socketTask;\n          var proxy;\n          var stream;\n\n          function buildProxy() {\n            var proxy = new Transform();\n\n            proxy._write = function (chunk, encoding, next) {\n              socketTask.send({\n                data: chunk.buffer,\n                success: function () {\n                  next();\n                },\n                fail: function (errMsg) {\n                  next(new Error(errMsg));\n                }\n              });\n            };\n\n            proxy._flush = function socketEnd(done) {\n              socketTask.close({\n                success: function () {\n                  done();\n                }\n              });\n            };\n\n            return proxy;\n          }\n\n          function setDefaultOpts(opts) {\n            if (!opts.hostname) {\n              opts.hostname = 'localhost';\n            }\n\n            if (!opts.path) {\n              opts.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              opts.wsOptions = {};\n            }\n          }\n\n          function buildUrl(opts, client) {\n            var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';\n            var url = protocol + '://' + opts.hostname + opts.path;\n\n            if (opts.port && opts.port !== 80 && opts.port !== 443) {\n              url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n            }\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function bindEventHandler() {\n            socketTask.onOpen(function () {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            });\n            socketTask.onMessage(function (res) {\n              var data = res.data;\n              if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n              proxy.push(data);\n            });\n            socketTask.onClose(function () {\n              stream.end();\n              stream.destroy();\n            });\n            socketTask.onError(function (res) {\n              stream.destroy(new Error(res.errMsg));\n            });\n          }\n\n          function buildStream(client, opts) {\n            opts.hostname = opts.hostname || opts.host;\n\n            if (!opts.hostname) {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n\n            var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            setDefaultOpts(opts);\n            var url = buildUrl(opts, client);\n            socketTask = wx.connectSocket({\n              url: url,\n              protocols: [websocketSubProtocol]\n            });\n            proxy = buildProxy();\n            stream = duplexify.obj();\n\n            stream._destroy = function (err, cb) {\n              socketTask.close({\n                success: function () {\n                  cb && cb(err);\n                }\n              });\n            };\n\n            var destroyRef = stream.destroy;\n\n            stream.destroy = function () {\n              stream.destroy = destroyRef;\n              var self = this;\n              setTimeout(function () {\n                socketTask.close({\n                  fail: function () {\n                    self._destroy(new Error());\n                  }\n                });\n              }, 0);\n            }.bind(stream);\n\n            bindEventHandler();\n            return stream;\n          }\n\n          module.exports = buildStream;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3,\n      \"duplexify\": 21,\n      \"readable-stream\": 60\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n      /**\n       * Module dependencies\n       */\n\n      var xtend = require('xtend');\n\n      var Readable = require('readable-stream').Readable;\n\n      var streamsOpts = {\n        objectMode: true\n      };\n      var defaultStoreOptions = {\n        clean: true\n      };\n      /**\n       * In-memory implementation of the message store\n       * This can actually be saved into files.\n       *\n       * @param {Object} [options] - store options\n       */\n\n      function Store(options) {\n        if (!(this instanceof Store)) {\n          return new Store(options);\n        }\n\n        this.options = options || {}; // Defaults\n\n        this.options = xtend(defaultStoreOptions, options);\n        this._inflights = new Map();\n      }\n      /**\n       * Adds a packet to the store, a packet is\n       * anything that has a messageId property.\n       *\n       */\n\n\n      Store.prototype.put = function (packet, cb) {\n        this._inflights.set(packet.messageId, packet);\n\n        if (cb) {\n          cb();\n        }\n\n        return this;\n      };\n      /**\n       * Creates a stream with all the packets in the store\n       *\n       */\n\n\n      Store.prototype.createStream = function () {\n        var stream = new Readable(streamsOpts);\n        var destroyed = false;\n        var values = [];\n        var i = 0;\n\n        this._inflights.forEach(function (value, key) {\n          values.push(value);\n        });\n\n        stream._read = function () {\n          if (!destroyed && i < values.length) {\n            this.push(values[i++]);\n          } else {\n            this.push(null);\n          }\n        };\n\n        stream.destroy = function () {\n          if (destroyed) {\n            return;\n          }\n\n          var self = this;\n          destroyed = true;\n          setTimeout(function () {\n            self.emit('close');\n          }, 0);\n        };\n\n        return stream;\n      };\n      /**\n       * deletes a packet from the store.\n       */\n\n\n      Store.prototype.del = function (packet, cb) {\n        packet = this._inflights.get(packet.messageId);\n\n        if (packet) {\n          this._inflights.delete(packet.messageId);\n\n          cb(null, packet);\n        } else if (cb) {\n          cb(new Error('missing packet'));\n        }\n\n        return this;\n      };\n      /**\n       * get a packet from the store.\n       */\n\n\n      Store.prototype.get = function (packet, cb) {\n        packet = this._inflights.get(packet.messageId);\n\n        if (packet) {\n          cb(null, packet);\n        } else if (cb) {\n          cb(new Error('missing packet'));\n        }\n\n        return this;\n      };\n      /**\n       * Close the store\n       */\n\n\n      Store.prototype.close = function (cb) {\n        if (this.options.clean) {\n          this._inflights = null;\n        }\n\n        if (cb) {\n          cb();\n        }\n      };\n\n      module.exports = Store;\n    }, {\n      \"readable-stream\": 60,\n      \"xtend\": 68\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n      /**\n       * Validate a topic to see if it's valid or not.\n       * A topic is valid if it follow below rules:\n       * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n       * - Rule #2: Part `#` must be located at the end of the mailbox\n       *\n       * @param {String} topic - A topic\n       * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n       */\n\n      function validateTopic(topic) {\n        var parts = topic.split('/');\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] === '+') {\n            continue;\n          }\n\n          if (parts[i] === '#') {\n            // for Rule #2\n            return i === parts.length - 1;\n          }\n\n          if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      /**\n       * Validate an array of topics to see if any of them is valid or not\n        * @param {Array} topics - Array of topics\n       * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n       */\n\n\n      function validateTopics(topics) {\n        if (topics.length === 0) {\n          return 'empty_topic_list';\n        }\n\n        for (var i = 0; i < topics.length; i++) {\n          if (!validateTopic(topics[i])) {\n            return topics[i];\n          }\n        }\n\n        return null;\n      }\n\n      module.exports = {\n        validateTopics: validateTopics\n      };\n    }, {}],\n    15: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var MqttClient = require('../client');\n\n          var Store = require('../store');\n\n          var url = require('url');\n\n          var xtend = require('xtend');\n\n          var debug = require('debug')('mqttjs');\n\n          var protocols = {}; // eslint-disable-next-line camelcase\n\n          if (typeof process !== 'undefined' && process.title !== 'browser' || typeof __webpack_require__ !== 'function') {\n            protocols.mqtt = require('./tcp');\n            protocols.tcp = require('./tcp');\n            protocols.ssl = require('./tls');\n            protocols.tls = require('./tls');\n            protocols.mqtts = require('./tls');\n          } else {\n            protocols.wx = require('./wx');\n            protocols.wxs = require('./wx');\n            protocols.ali = require('./ali');\n            protocols.alis = require('./ali');\n          }\n\n          protocols.ws = require('./ws');\n          protocols.wss = require('./ws');\n          /**\n           * Parse the auth attribute and merge username and password in the options object.\n           *\n           * @param {Object} [opts] option object\n           */\n\n          function parseAuthOptions(opts) {\n            var matches;\n\n            if (opts.auth) {\n              matches = opts.auth.match(/^(.+):(.+)$/);\n\n              if (matches) {\n                opts.username = matches[1];\n                opts.password = matches[2];\n              } else {\n                opts.username = opts.auth;\n              }\n            }\n          }\n          /**\n           * connect - connect to an MQTT broker.\n           *\n           * @param {String} [brokerUrl] - url of the broker, optional\n           * @param {Object} opts - see MqttClient#constructor\n           */\n\n\n          function connect(brokerUrl, opts) {\n            debug('connecting to an MQTT broker...');\n\n            if (typeof brokerUrl === 'object' && !opts) {\n              opts = brokerUrl;\n              brokerUrl = null;\n            }\n\n            opts = opts || {};\n\n            if (brokerUrl) {\n              var parsed = url.parse(brokerUrl, true);\n\n              if (parsed.port != null) {\n                parsed.port = Number(parsed.port);\n              }\n\n              opts = xtend(parsed, opts);\n\n              if (opts.protocol === null) {\n                throw new Error('Missing protocol');\n              }\n\n              opts.protocol = opts.protocol.replace(/:$/, '');\n            } // merge in the auth options if supplied\n\n\n            parseAuthOptions(opts); // support clientId passed in the query string of the url\n\n            if (opts.query && typeof opts.query.clientId === 'string') {\n              opts.clientId = opts.query.clientId;\n            }\n\n            if (opts.cert && opts.key) {\n              if (opts.protocol) {\n                if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n                  switch (opts.protocol) {\n                    case 'mqtt':\n                      opts.protocol = 'mqtts';\n                      break;\n\n                    case 'ws':\n                      opts.protocol = 'wss';\n                      break;\n\n                    case 'wx':\n                      opts.protocol = 'wxs';\n                      break;\n\n                    case 'ali':\n                      opts.protocol = 'alis';\n                      break;\n\n                    default:\n                      throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');\n                  }\n                }\n              } else {\n                // A cert and key was provided, however no protocol was specified, so we will throw an error.\n                throw new Error('Missing secure protocol key');\n              }\n            }\n\n            if (!protocols[opts.protocol]) {\n              var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n              opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs', 'ali', 'alis'].filter(function (key, index) {\n                if (isSecure && index % 2 === 0) {\n                  // Skip insecure protocols when requesting a secure one.\n                  return false;\n                }\n\n                return typeof protocols[key] === 'function';\n              })[0];\n            }\n\n            if (opts.clean === false && !opts.clientId) {\n              throw new Error('Missing clientId for unclean clients');\n            }\n\n            if (opts.protocol) {\n              opts.defaultProtocol = opts.protocol;\n            }\n\n            function wrapper(client) {\n              if (opts.servers) {\n                if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n                  client._reconnectCount = 0;\n                }\n\n                opts.host = opts.servers[client._reconnectCount].host;\n                opts.port = opts.servers[client._reconnectCount].port;\n                opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n                opts.hostname = opts.host;\n                client._reconnectCount++;\n              }\n\n              debug('calling streambuilder for', opts.protocol);\n              return protocols[opts.protocol](client, opts);\n            }\n\n            var client = new MqttClient(wrapper, opts);\n            client.on('error', function () {\n              /* Automatically set up client error handling */\n            });\n            return client;\n          }\n\n          module.exports = connect;\n          module.exports.connect = connect;\n          module.exports.MqttClient = MqttClient;\n          module.exports.Store = Store;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"../client\": 7,\n      \"../store\": 13,\n      \"./ali\": 8,\n      \"./tcp\": 9,\n      \"./tls\": 10,\n      \"./ws\": 11,\n      \"./wx\": 12,\n      \"_process\": 69,\n      \"debug\": 19,\n      \"url\": 75,\n      \"xtend\": 68\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      const {\n        Buffer\n      } = require('buffer');\n\n      const symbol = Symbol.for('BufferList');\n\n      function BufferList(buf) {\n        if (!(this instanceof BufferList)) {\n          return new BufferList(buf);\n        }\n\n        BufferList._init.call(this, buf);\n      }\n\n      BufferList._init = function _init(buf) {\n        Object.defineProperty(this, symbol, {\n          value: true\n        });\n        this._bufs = [];\n        this.length = 0;\n\n        if (buf) {\n          this.append(buf);\n        }\n      };\n\n      BufferList.prototype._new = function _new(buf) {\n        return new BufferList(buf);\n      };\n\n      BufferList.prototype._offset = function _offset(offset) {\n        if (offset === 0) {\n          return [0, 0];\n        }\n\n        let tot = 0;\n\n        for (let i = 0; i < this._bufs.length; i++) {\n          const _t = tot + this._bufs[i].length;\n\n          if (offset < _t || i === this._bufs.length - 1) {\n            return [i, offset - tot];\n          }\n\n          tot = _t;\n        }\n      };\n\n      BufferList.prototype._reverseOffset = function (blOffset) {\n        const bufferId = blOffset[0];\n        let offset = blOffset[1];\n\n        for (let i = 0; i < bufferId; i++) {\n          offset += this._bufs[i].length;\n        }\n\n        return offset;\n      };\n\n      BufferList.prototype.get = function get(index) {\n        if (index > this.length || index < 0) {\n          return undefined;\n        }\n\n        const offset = this._offset(index);\n\n        return this._bufs[offset[0]][offset[1]];\n      };\n\n      BufferList.prototype.slice = function slice(start, end) {\n        if (typeof start === 'number' && start < 0) {\n          start += this.length;\n        }\n\n        if (typeof end === 'number' && end < 0) {\n          end += this.length;\n        }\n\n        return this.copy(null, 0, start, end);\n      };\n\n      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n        if (typeof srcStart !== 'number' || srcStart < 0) {\n          srcStart = 0;\n        }\n\n        if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n          srcEnd = this.length;\n        }\n\n        if (srcStart >= this.length) {\n          return dst || Buffer.alloc(0);\n        }\n\n        if (srcEnd <= 0) {\n          return dst || Buffer.alloc(0);\n        }\n\n        const copy = !!dst;\n\n        const off = this._offset(srcStart);\n\n        const len = srcEnd - srcStart;\n        let bytes = len;\n        let bufoff = copy && dstStart || 0;\n        let start = off[1]; // copy/slice everything\n\n        if (srcStart === 0 && srcEnd === this.length) {\n          if (!copy) {\n            // slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n          } // copy, need to copy individual buffers\n\n\n          for (let i = 0; i < this._bufs.length; i++) {\n            this._bufs[i].copy(dst, bufoff);\n\n            bufoff += this._bufs[i].length;\n          }\n\n          return dst;\n        } // easy, cheap case where it's a subset of one of the buffers\n\n\n        if (bytes <= this._bufs[off[0]].length - start) {\n          return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);\n        }\n\n        if (!copy) {\n          // a slice, we need something to copy in to\n          dst = Buffer.allocUnsafe(len);\n        }\n\n        for (let i = off[0]; i < this._bufs.length; i++) {\n          const l = this._bufs[i].length - start;\n\n          if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n\n            bufoff += l;\n          } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n\n            bufoff += l;\n            break;\n          }\n\n          bytes -= l;\n\n          if (start) {\n            start = 0;\n          }\n        } // safeguard so that we don't return uninitialized memory\n\n\n        if (dst.length > bufoff) return dst.slice(0, bufoff);\n        return dst;\n      };\n\n      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n        start = start || 0;\n        end = typeof end !== 'number' ? this.length : end;\n\n        if (start < 0) {\n          start += this.length;\n        }\n\n        if (end < 0) {\n          end += this.length;\n        }\n\n        if (start === end) {\n          return this._new();\n        }\n\n        const startOffset = this._offset(start);\n\n        const endOffset = this._offset(end);\n\n        const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n\n        if (endOffset[1] === 0) {\n          buffers.pop();\n        } else {\n          buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n        }\n\n        if (startOffset[1] !== 0) {\n          buffers[0] = buffers[0].slice(startOffset[1]);\n        }\n\n        return this._new(buffers);\n      };\n\n      BufferList.prototype.toString = function toString(encoding, start, end) {\n        return this.slice(start, end).toString(encoding);\n      };\n\n      BufferList.prototype.consume = function consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes); // do nothing if not a positive number\n\n        if (Number.isNaN(bytes) || bytes <= 0) return this;\n\n        while (this._bufs.length) {\n          if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n\n            this._bufs.shift();\n          } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n          }\n        }\n\n        return this;\n      };\n\n      BufferList.prototype.duplicate = function duplicate() {\n        const copy = this._new();\n\n        for (let i = 0; i < this._bufs.length; i++) {\n          copy.append(this._bufs[i]);\n        }\n\n        return copy;\n      };\n\n      BufferList.prototype.append = function append(buf) {\n        if (buf == null) {\n          return this;\n        }\n\n        if (buf.buffer) {\n          // append a view of the underlying ArrayBuffer\n          this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));\n        } else if (Array.isArray(buf)) {\n          for (let i = 0; i < buf.length; i++) {\n            this.append(buf[i]);\n          }\n        } else if (this._isBufferList(buf)) {\n          // unwrap argument into individual BufferLists\n          for (let i = 0; i < buf._bufs.length; i++) {\n            this.append(buf._bufs[i]);\n          }\n        } else {\n          // coerce number arguments to strings, since Buffer(number) does\n          // uninitialized memory allocation\n          if (typeof buf === 'number') {\n            buf = buf.toString();\n          }\n\n          this._appendBuffer(Buffer.from(buf));\n        }\n\n        return this;\n      };\n\n      BufferList.prototype._appendBuffer = function appendBuffer(buf) {\n        this._bufs.push(buf);\n\n        this.length += buf.length;\n      };\n\n      BufferList.prototype.indexOf = function (search, offset, encoding) {\n        if (encoding === undefined && typeof offset === 'string') {\n          encoding = offset;\n          offset = undefined;\n        }\n\n        if (typeof search === 'function' || Array.isArray(search)) {\n          throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');\n        } else if (typeof search === 'number') {\n          search = Buffer.from([search]);\n        } else if (typeof search === 'string') {\n          search = Buffer.from(search, encoding);\n        } else if (this._isBufferList(search)) {\n          search = search.slice();\n        } else if (Array.isArray(search.buffer)) {\n          search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);\n        } else if (!Buffer.isBuffer(search)) {\n          search = Buffer.from(search);\n        }\n\n        offset = Number(offset || 0);\n\n        if (isNaN(offset)) {\n          offset = 0;\n        }\n\n        if (offset < 0) {\n          offset = this.length + offset;\n        }\n\n        if (offset < 0) {\n          offset = 0;\n        }\n\n        if (search.length === 0) {\n          return offset > this.length ? this.length : offset;\n        }\n\n        const blOffset = this._offset(offset);\n\n        let blIndex = blOffset[0]; // index of which internal buffer we're working on\n\n        let buffOffset = blOffset[1]; // offset of the internal buffer we're working on\n        // scan over each buffer\n\n        for (; blIndex < this._bufs.length; blIndex++) {\n          const buff = this._bufs[blIndex];\n\n          while (buffOffset < buff.length) {\n            const availableWindow = buff.length - buffOffset;\n\n            if (availableWindow >= search.length) {\n              const nativeSearchResult = buff.indexOf(search, buffOffset);\n\n              if (nativeSearchResult !== -1) {\n                return this._reverseOffset([blIndex, nativeSearchResult]);\n              }\n\n              buffOffset = buff.length - search.length + 1; // end of native search window\n            } else {\n              const revOffset = this._reverseOffset([blIndex, buffOffset]);\n\n              if (this._match(revOffset, search)) {\n                return revOffset;\n              }\n\n              buffOffset++;\n            }\n          }\n\n          buffOffset = 0;\n        }\n\n        return -1;\n      };\n\n      BufferList.prototype._match = function (offset, search) {\n        if (this.length - offset < search.length) {\n          return false;\n        }\n\n        for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n          if (this.get(offset + searchOffset) !== search[searchOffset]) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      (function () {\n        const methods = {\n          readDoubleBE: 8,\n          readDoubleLE: 8,\n          readFloatBE: 4,\n          readFloatLE: 4,\n          readInt32BE: 4,\n          readInt32LE: 4,\n          readUInt32BE: 4,\n          readUInt32LE: 4,\n          readInt16BE: 2,\n          readInt16LE: 2,\n          readUInt16BE: 2,\n          readUInt16LE: 2,\n          readInt8: 1,\n          readUInt8: 1,\n          readIntBE: null,\n          readIntLE: null,\n          readUIntBE: null,\n          readUIntLE: null\n        };\n\n        for (const m in methods) {\n          (function (m) {\n            if (methods[m] === null) {\n              BufferList.prototype[m] = function (offset, byteLength) {\n                return this.slice(offset, offset + byteLength)[m](0, byteLength);\n              };\n            } else {\n              BufferList.prototype[m] = function (offset = 0) {\n                return this.slice(offset, offset + methods[m])[m](0);\n              };\n            }\n          })(m);\n        }\n      })(); // Used internally by the class and also as an indicator of this object being\n      // a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n      // environment because there could be multiple different copies of the\n      // BufferList class and some `BufferList`s might be `BufferList`s.\n\n\n      BufferList.prototype._isBufferList = function _isBufferList(b) {\n        return b instanceof BufferList || BufferList.isBufferList(b);\n      };\n\n      BufferList.isBufferList = function isBufferList(b) {\n        return b != null && b[symbol];\n      };\n\n      module.exports = BufferList;\n    }, {\n      \"buffer\": 3\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      const DuplexStream = require('readable-stream').Duplex;\n\n      const inherits = require('inherits');\n\n      const BufferList = require('./BufferList');\n\n      function BufferListStream(callback) {\n        if (!(this instanceof BufferListStream)) {\n          return new BufferListStream(callback);\n        }\n\n        if (typeof callback === 'function') {\n          this._callback = callback;\n\n          const piper = function piper(err) {\n            if (this._callback) {\n              this._callback(err);\n\n              this._callback = null;\n            }\n          }.bind(this);\n\n          this.on('pipe', function onPipe(src) {\n            src.on('error', piper);\n          });\n          this.on('unpipe', function onUnpipe(src) {\n            src.removeListener('error', piper);\n          });\n          callback = null;\n        }\n\n        BufferList._init.call(this, callback);\n\n        DuplexStream.call(this);\n      }\n\n      inherits(BufferListStream, DuplexStream);\n      Object.assign(BufferListStream.prototype, BufferList.prototype);\n\n      BufferListStream.prototype._new = function _new(callback) {\n        return new BufferListStream(callback);\n      };\n\n      BufferListStream.prototype._write = function _write(buf, encoding, callback) {\n        this._appendBuffer(buf);\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n\n      BufferListStream.prototype._read = function _read(size) {\n        if (!this.length) {\n          return this.push(null);\n        }\n\n        size = Math.min(size, this.length);\n        this.push(this.slice(0, size));\n        this.consume(size);\n      };\n\n      BufferListStream.prototype.end = function end(chunk) {\n        DuplexStream.prototype.end.call(this, chunk);\n\n        if (this._callback) {\n          this._callback(null, this.slice());\n\n          this._callback = null;\n        }\n      };\n\n      BufferListStream.prototype._destroy = function _destroy(err, cb) {\n        this._bufs.length = 0;\n        this.length = 0;\n        cb(err);\n      };\n\n      BufferListStream.prototype._isBufferList = function _isBufferList(b) {\n        return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);\n      };\n\n      BufferListStream.isBufferList = BufferList.isBufferList;\n      module.exports = BufferListStream;\n      module.exports.BufferListStream = BufferListStream;\n      module.exports.BufferList = BufferList;\n    }, {\n      \"./BufferList\": 16,\n      \"inherits\": 34,\n      \"readable-stream\": 60\n    }],\n    18: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // NOTE: These type checking functions intentionally don't use `instanceof`\n          // because it is fragile and can be easily faked with `Object.create()`.\n          function isArray(arg) {\n            if (Array.isArray) {\n              return Array.isArray(arg);\n            }\n\n            return objectToString(arg) === '[object Array]';\n          }\n\n          exports.isArray = isArray;\n\n          function isBoolean(arg) {\n            return typeof arg === 'boolean';\n          }\n\n          exports.isBoolean = isBoolean;\n\n          function isNull(arg) {\n            return arg === null;\n          }\n\n          exports.isNull = isNull;\n\n          function isNullOrUndefined(arg) {\n            return arg == null;\n          }\n\n          exports.isNullOrUndefined = isNullOrUndefined;\n\n          function isNumber(arg) {\n            return typeof arg === 'number';\n          }\n\n          exports.isNumber = isNumber;\n\n          function isString(arg) {\n            return typeof arg === 'string';\n          }\n\n          exports.isString = isString;\n\n          function isSymbol(arg) {\n            return typeof arg === 'symbol';\n          }\n\n          exports.isSymbol = isSymbol;\n\n          function isUndefined(arg) {\n            return arg === void 0;\n          }\n\n          exports.isUndefined = isUndefined;\n\n          function isRegExp(re) {\n            return objectToString(re) === '[object RegExp]';\n          }\n\n          exports.isRegExp = isRegExp;\n\n          function isObject(arg) {\n            return typeof arg === 'object' && arg !== null;\n          }\n\n          exports.isObject = isObject;\n\n          function isDate(d) {\n            return objectToString(d) === '[object Date]';\n          }\n\n          exports.isDate = isDate;\n\n          function isError(e) {\n            return objectToString(e) === '[object Error]' || e instanceof Error;\n          }\n\n          exports.isError = isError;\n\n          function isFunction(arg) {\n            return typeof arg === 'function';\n          }\n\n          exports.isFunction = isFunction;\n\n          function isPrimitive(arg) {\n            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n            typeof arg === 'undefined';\n          }\n\n          exports.isPrimitive = isPrimitive;\n          exports.isBuffer = Buffer.isBuffer;\n\n          function objectToString(o) {\n            return Object.prototype.toString.call(o);\n          }\n        }).call(this);\n      }).call(this, {\n        \"isBuffer\": require(\"../../../../is-buffer/index.js\")\n      });\n    }, {\n      \"../../../../is-buffer/index.js\": 6\n    }],\n    19: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          /* eslint-env browser */\n\n          /**\n           * This is the web browser implementation of `debug()`.\n           */\n          exports.formatArgs = formatArgs;\n          exports.save = save;\n          exports.load = load;\n          exports.useColors = useColors;\n          exports.storage = localstorage();\n\n          exports.destroy = (() => {\n            let warned = false;\n            return () => {\n              if (!warned) {\n                warned = true;\n                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n              }\n            };\n          })();\n          /**\n           * Colors.\n           */\n\n\n          exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n          /**\n           * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n           * and the Firebug extension (any Firefox version) are known\n           * to support \"%c\" CSS customizations.\n           *\n           * TODO: add a `localStorage` variable to explicitly enable/disable colors\n           */\n          // eslint-disable-next-line complexity\n\n          function useColors() {\n            // NB: In an Electron preload script, document will be defined but not fully\n            // initialized. Since we know we're in Chrome, we'll just detect this case\n            // explicitly\n            if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n              return true;\n            } // Internet Explorer and Edge do not support colors.\n\n\n            if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n              return false;\n            } // Is webkit? http://stackoverflow.com/a/16459606/376773\n            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n            return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n            typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n            typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n          }\n          /**\n           * Colorize log arguments if enabled.\n           *\n           * @api public\n           */\n\n\n          function formatArgs(args) {\n            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n            if (!this.useColors) {\n              return;\n            }\n\n            const c = 'color: ' + this.color;\n            args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n            // arguments passed either before or after the %c, so we need to\n            // figure out the correct index to insert the CSS into\n\n            let index = 0;\n            let lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, match => {\n              if (match === '%%') {\n                return;\n              }\n\n              index++;\n\n              if (match === '%c') {\n                // We only are interested in the *last* %c\n                // (the user may have provided their own)\n                lastC = index;\n              }\n            });\n            args.splice(lastC, 0, c);\n          }\n          /**\n           * Invokes `console.debug()` when available.\n           * No-op when `console.debug` is not a \"function\".\n           * If `console.debug` is not available, falls back\n           * to `console.log`.\n           *\n           * @api public\n           */\n\n\n          exports.log = console.debug || console.log || (() => {});\n          /**\n           * Save `namespaces`.\n           *\n           * @param {String} namespaces\n           * @api private\n           */\n\n\n          function save(namespaces) {\n            try {\n              if (namespaces) {\n                exports.storage.setItem('debug', namespaces);\n              } else {\n                exports.storage.removeItem('debug');\n              }\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n          /**\n           * Load `namespaces`.\n           *\n           * @return {String} returns the previously persisted debug modes\n           * @api private\n           */\n\n\n          function load() {\n            let r;\n\n            try {\n              r = exports.storage.getItem('debug');\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n            if (!r && typeof process !== 'undefined' && 'env' in process) {\n              r = process.env.DEBUG;\n            }\n\n            return r;\n          }\n          /**\n           * Localstorage attempts to return the localstorage.\n           *\n           * This is necessary because safari throws\n           * when a user disables cookies/localstorage\n           * and you attempt to access it.\n           *\n           * @return {LocalStorage}\n           * @api private\n           */\n\n\n          function localstorage() {\n            try {\n              // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n              // The Browser also has localStorage in the global context.\n              return localStorage;\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n\n          module.exports = require('./common')(exports);\n          const {\n            formatters\n          } = module.exports;\n          /**\n           * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n           */\n\n          formatters.j = function (v) {\n            try {\n              return JSON.stringify(v);\n            } catch (error) {\n              return '[UnexpectedJSONParseError]: ' + error.message;\n            }\n          };\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./common\": 20,\n      \"_process\": 69\n    }],\n    20: [function (require, module, exports) {\n      /**\n       * This is the common logic for both the Node.js and web browser\n       * implementations of `debug()`.\n       */\n      function setup(env) {\n        createDebug.debug = createDebug;\n        createDebug.default = createDebug;\n        createDebug.coerce = coerce;\n        createDebug.disable = disable;\n        createDebug.enable = enable;\n        createDebug.enabled = enabled;\n        createDebug.humanize = require('ms');\n        createDebug.destroy = destroy;\n        Object.keys(env).forEach(key => {\n          createDebug[key] = env[key];\n        });\n        /**\n        * The currently active debug mode names, and names to skip.\n        */\n\n        createDebug.names = [];\n        createDebug.skips = [];\n        /**\n        * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n        *\n        * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n        */\n\n        createDebug.formatters = {};\n        /**\n        * Selects a color for a debug namespace\n        * @param {String} namespace The namespace string for the for the debug instance to be colored\n        * @return {Number|String} An ANSI color code for the given namespace\n        * @api private\n        */\n\n        function selectColor(namespace) {\n          let hash = 0;\n\n          for (let i = 0; i < namespace.length; i++) {\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n          }\n\n          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n        }\n\n        createDebug.selectColor = selectColor;\n        /**\n        * Create a debugger with the given `namespace`.\n        *\n        * @param {String} namespace\n        * @return {Function}\n        * @api public\n        */\n\n        function createDebug(namespace) {\n          let prevTime;\n          let enableOverride = null;\n\n          function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n              return;\n            }\n\n            const self = debug; // Set `diff` timestamp\n\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n\n            if (typeof args[0] !== 'string') {\n              // Anything else let's inspect with %O\n              args.unshift('%O');\n            } // Apply any `formatters` transformations\n\n\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n              // If we encounter an escaped % then don't increase the array index\n              if (match === '%%') {\n                return '%';\n              }\n\n              index++;\n              const formatter = createDebug.formatters[format];\n\n              if (typeof formatter === 'function') {\n                const val = args[index];\n                match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n                args.splice(index, 1);\n                index--;\n              }\n\n              return match;\n            }); // Apply env-specific formatting (colors, etc.)\n\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n          }\n\n          debug.namespace = namespace;\n          debug.useColors = createDebug.useColors();\n          debug.color = createDebug.selectColor(namespace);\n          debug.extend = extend;\n          debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n          Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n            set: v => {\n              enableOverride = v;\n            }\n          }); // Env-specific initialization logic for debug instances\n\n          if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n          }\n\n          return debug;\n        }\n\n        function extend(namespace, delimiter) {\n          const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n          newDebug.log = this.log;\n          return newDebug;\n        }\n        /**\n        * Enables a debug mode by namespaces. This can include modes\n        * separated by a colon and wildcards.\n        *\n        * @param {String} namespaces\n        * @api public\n        */\n\n\n        function enable(namespaces) {\n          createDebug.save(namespaces);\n          createDebug.names = [];\n          createDebug.skips = [];\n          let i;\n          const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n          const len = split.length;\n\n          for (i = 0; i < len; i++) {\n            if (!split[i]) {\n              // ignore empty strings\n              continue;\n            }\n\n            namespaces = split[i].replace(/\\*/g, '.*?');\n\n            if (namespaces[0] === '-') {\n              createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            } else {\n              createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n          }\n        }\n        /**\n        * Disable debug output.\n        *\n        * @return {String} namespaces\n        * @api public\n        */\n\n\n        function disable() {\n          const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');\n          createDebug.enable('');\n          return namespaces;\n        }\n        /**\n        * Returns true if the given mode name is enabled, false otherwise.\n        *\n        * @param {String} name\n        * @return {Boolean}\n        * @api public\n        */\n\n\n        function enabled(name) {\n          if (name[name.length - 1] === '*') {\n            return true;\n          }\n\n          let i;\n          let len;\n\n          for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n              return false;\n            }\n          }\n\n          for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n        /**\n        * Convert regexp to namespace\n        *\n        * @param {RegExp} regxep\n        * @return {String} namespace\n        * @api private\n        */\n\n\n        function toNamespace(regexp) {\n          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n        }\n        /**\n        * Coerce `val`.\n        *\n        * @param {Mixed} val\n        * @return {Mixed}\n        * @api private\n        */\n\n\n        function coerce(val) {\n          if (val instanceof Error) {\n            return val.stack || val.message;\n          }\n\n          return val;\n        }\n        /**\n        * XXX DO NOT USE. This is a temporary stub function.\n        * XXX It WILL be removed in the next major release.\n        */\n\n\n        function destroy() {\n          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n\n        createDebug.enable(createDebug.load());\n        return createDebug;\n      }\n\n      module.exports = setup;\n    }, {\n      \"ms\": 43\n    }],\n    21: [function (require, module, exports) {\n      (function (process, Buffer) {\n        (function () {\n          var stream = require('readable-stream');\n\n          var eos = require('end-of-stream');\n\n          var inherits = require('inherits');\n\n          var shift = require('stream-shift');\n\n          var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);\n\n          var onuncork = function (self, fn) {\n            if (self._corked) self.once('uncork', fn);else fn();\n          };\n\n          var autoDestroy = function (self, err) {\n            if (self._autoDestroy) self.destroy(err);\n          };\n\n          var destroyer = function (self, end) {\n            return function (err) {\n              if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();\n            };\n          };\n\n          var end = function (ws, fn) {\n            if (!ws) return fn();\n            if (ws._writableState && ws._writableState.finished) return fn();\n            if (ws._writableState) return ws.end(fn);\n            ws.end();\n            fn();\n          };\n\n          var toStreams2 = function (rs) {\n            return new stream.Readable({\n              objectMode: true,\n              highWaterMark: 16\n            }).wrap(rs);\n          };\n\n          var Duplexify = function (writable, readable, opts) {\n            if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n            stream.Duplex.call(this, opts);\n            this._writable = null;\n            this._readable = null;\n            this._readable2 = null;\n            this._autoDestroy = !opts || opts.autoDestroy !== false;\n            this._forwardDestroy = !opts || opts.destroy !== false;\n            this._forwardEnd = !opts || opts.end !== false;\n            this._corked = 1; // start corked\n\n            this._ondrain = null;\n            this._drained = false;\n            this._forwarding = false;\n            this._unwrite = null;\n            this._unread = null;\n            this._ended = false;\n            this.destroyed = false;\n            if (writable) this.setWritable(writable);\n            if (readable) this.setReadable(readable);\n          };\n\n          inherits(Duplexify, stream.Duplex);\n\n          Duplexify.obj = function (writable, readable, opts) {\n            if (!opts) opts = {};\n            opts.objectMode = true;\n            opts.highWaterMark = 16;\n            return new Duplexify(writable, readable, opts);\n          };\n\n          Duplexify.prototype.cork = function () {\n            if (++this._corked === 1) this.emit('cork');\n          };\n\n          Duplexify.prototype.uncork = function () {\n            if (this._corked && --this._corked === 0) this.emit('uncork');\n          };\n\n          Duplexify.prototype.setWritable = function (writable) {\n            if (this._unwrite) this._unwrite();\n\n            if (this.destroyed) {\n              if (writable && writable.destroy) writable.destroy();\n              return;\n            }\n\n            if (writable === null || writable === false) {\n              this.end();\n              return;\n            }\n\n            var self = this;\n            var unend = eos(writable, {\n              writable: true,\n              readable: false\n            }, destroyer(this, this._forwardEnd));\n\n            var ondrain = function () {\n              var ondrain = self._ondrain;\n              self._ondrain = null;\n              if (ondrain) ondrain();\n            };\n\n            var clear = function () {\n              self._writable.removeListener('drain', ondrain);\n\n              unend();\n            };\n\n            if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n            this._writable = writable;\n\n            this._writable.on('drain', ondrain);\n\n            this._unwrite = clear;\n            this.uncork(); // always uncork setWritable\n          };\n\n          Duplexify.prototype.setReadable = function (readable) {\n            if (this._unread) this._unread();\n\n            if (this.destroyed) {\n              if (readable && readable.destroy) readable.destroy();\n              return;\n            }\n\n            if (readable === null || readable === false) {\n              this.push(null);\n              this.resume();\n              return;\n            }\n\n            var self = this;\n            var unend = eos(readable, {\n              writable: false,\n              readable: true\n            }, destroyer(this));\n\n            var onreadable = function () {\n              self._forward();\n            };\n\n            var onend = function () {\n              self.push(null);\n            };\n\n            var clear = function () {\n              self._readable2.removeListener('readable', onreadable);\n\n              self._readable2.removeListener('end', onend);\n\n              unend();\n            };\n\n            this._drained = true;\n            this._readable = readable;\n            this._readable2 = readable._readableState ? readable : toStreams2(readable);\n\n            this._readable2.on('readable', onreadable);\n\n            this._readable2.on('end', onend);\n\n            this._unread = clear;\n\n            this._forward();\n          };\n\n          Duplexify.prototype._read = function () {\n            this._drained = true;\n\n            this._forward();\n          };\n\n          Duplexify.prototype._forward = function () {\n            if (this._forwarding || !this._readable2 || !this._drained) return;\n            this._forwarding = true;\n            var data;\n\n            while (this._drained && (data = shift(this._readable2)) !== null) {\n              if (this.destroyed) continue;\n              this._drained = this.push(data);\n            }\n\n            this._forwarding = false;\n          };\n\n          Duplexify.prototype.destroy = function (err) {\n            if (this.destroyed) return;\n            this.destroyed = true;\n            var self = this;\n            process.nextTick(function () {\n              self._destroy(err);\n            });\n          };\n\n          Duplexify.prototype._destroy = function (err) {\n            if (err) {\n              var ondrain = this._ondrain;\n              this._ondrain = null;\n              if (ondrain) ondrain(err);else this.emit('error', err);\n            }\n\n            if (this._forwardDestroy) {\n              if (this._readable && this._readable.destroy) this._readable.destroy();\n              if (this._writable && this._writable.destroy) this._writable.destroy();\n            }\n\n            this.emit('close');\n          };\n\n          Duplexify.prototype._write = function (data, enc, cb) {\n            if (this.destroyed) return cb();\n            if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n            if (data === SIGNAL_FLUSH) return this._finish(cb);\n            if (!this._writable) return cb();\n            if (this._writable.write(data) === false) this._ondrain = cb;else cb();\n          };\n\n          Duplexify.prototype._finish = function (cb) {\n            var self = this;\n            this.emit('preend');\n            onuncork(this, function () {\n              end(self._forwardEnd && self._writable, function () {\n                // haxx to not emit prefinish twice\n                if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n                self.emit('prefinish');\n                onuncork(self, cb);\n              });\n            });\n          };\n\n          Duplexify.prototype.end = function (data, enc, cb) {\n            if (typeof data === 'function') return this.end(null, null, data);\n            if (typeof enc === 'function') return this.end(data, null, enc);\n            this._ended = true;\n            if (data) this.write(data);\n            if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n            return stream.Writable.prototype.end.call(this, cb);\n          };\n\n          module.exports = Duplexify;\n        }).call(this);\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"end-of-stream\": 33,\n      \"inherits\": 34,\n      \"readable-stream\": 30,\n      \"stream-shift\": 63\n    }],\n    22: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a duplex stream is just a stream that is both readable and writable.\n      // Since JS doesn't have multiple prototypal inheritance, this class\n      // prototypally inherits from Readable, and then parasitically from\n      // Writable.\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n\n        for (var key in obj) {\n          keys.push(key);\n        }\n\n        return keys;\n      };\n      /*</replacement>*/\n\n\n      module.exports = Duplex;\n      /*<replacement>*/\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      var Readable = require('./_stream_readable');\n\n      var Writable = require('./_stream_writable');\n\n      util.inherits(Duplex, Readable);\n      {\n        // avoid scope creep, the keys array can then be collected\n        var keys = objectKeys(Writable.prototype);\n\n        for (var v = 0; v < keys.length; v++) {\n          var method = keys[v];\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n        }\n      }\n\n      function Duplex(options) {\n        if (!(this instanceof Duplex)) return new Duplex(options);\n        Readable.call(this, options);\n        Writable.call(this, options);\n        if (options && options.readable === false) this.readable = false;\n        if (options && options.writable === false) this.writable = false;\n        this.allowHalfOpen = true;\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n        this.once('end', onend);\n      }\n\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function () {\n          return this._writableState.highWaterMark;\n        }\n      }); // the no-half-open enforcer\n\n      function onend() {\n        // if we allow half-open state, or if the writable side ended,\n        // then we're ok.\n        if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.\n        // But allow more writes to happen in this tick.\n\n        pna.nextTick(onEndNT, this);\n      }\n\n      function onEndNT(self) {\n        self.end();\n      }\n\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\n        get: function () {\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n          }\n\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function (value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n          } // backward compatibility, the user is explicitly\n          // managing destroyed\n\n\n          this._readableState.destroyed = value;\n          this._writableState.destroyed = value;\n        }\n      });\n\n      Duplex.prototype._destroy = function (err, cb) {\n        this.push(null);\n        this.end();\n        pna.nextTick(cb, err);\n      };\n    }, {\n      \"./_stream_readable\": 24,\n      \"./_stream_writable\": 26,\n      \"core-util-is\": 18,\n      \"inherits\": 34,\n      \"process-nextick-args\": 45\n    }],\n    23: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n      /*<replacement>*/\n\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, {\n      \"./_stream_transform\": 25,\n      \"core-util-is\": 18,\n      \"inherits\": 34\n    }],\n    24: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          'use strict';\n          /*<replacement>*/\n\n          var pna = require('process-nextick-args');\n          /*</replacement>*/\n\n\n          module.exports = Readable;\n          /*<replacement>*/\n\n          var isArray = require('isarray');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Duplex;\n          /*</replacement>*/\n\n          Readable.ReadableState = ReadableState;\n          /*<replacement>*/\n\n          var EE = require('events').EventEmitter;\n\n          var EElistenerCount = function (emitter, type) {\n            return emitter.listeners(type).length;\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Buffer = require('safe-buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var util = Object.create(require('core-util-is'));\n          util.inherits = require('inherits');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var debugUtil = require('util');\n\n          var debug = void 0;\n\n          if (debugUtil && debugUtil.debuglog) {\n            debug = debugUtil.debuglog('stream');\n          } else {\n            debug = function () {};\n          }\n          /*</replacement>*/\n\n\n          var BufferList = require('./internal/streams/BufferList');\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var StringDecoder;\n          util.inherits(Readable, Stream);\n          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n          function prependListener(emitter, event, fn) {\n            // Sadly this is not cacheable as some libraries bundle their own\n            // event emitter implementation with them.\n            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n            // userland ones.  NEVER DO THIS. This is here only because this code needs\n            // to continue to work with older versions of Node.js that do not include\n            // the prependListener() method. The goal is to eventually remove this hack.\n\n            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n          }\n\n          function ReadableState(options, stream) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n            // make all the buffer merging and length checks go away\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n            // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n            var hwm = options.highWaterMark;\n            var readableHwm = options.readableHighWaterMark;\n            var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n            if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n            this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the\n            // linked list can remove elements from the beginning faster than\n            // array.shift()\n\n            this.buffer = new BufferList();\n            this.length = 0;\n            this.pipes = null;\n            this.pipesCount = 0;\n            this.flowing = null;\n            this.ended = false;\n            this.endEmitted = false;\n            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n            // immediately, or on a later tick.  We set this to true at first, because\n            // any actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first read call.\n\n            this.sync = true; // whenever we return null, then we set a flag to say\n            // that we're awaiting a 'readable' event emission.\n\n            this.needReadable = false;\n            this.emittedReadable = false;\n            this.readableListening = false;\n            this.resumeScheduled = false; // has it been destroyed\n\n            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n            this.readingMore = false;\n            this.decoder = null;\n            this.encoding = null;\n\n            if (options.encoding) {\n              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n              this.decoder = new StringDecoder(options.encoding);\n              this.encoding = options.encoding;\n            }\n          }\n\n          function Readable(options) {\n            Duplex = Duplex || require('./_stream_duplex');\n            if (!(this instanceof Readable)) return new Readable(options);\n            this._readableState = new ReadableState(options, this); // legacy\n\n            this.readable = true;\n\n            if (options) {\n              if (typeof options.read === 'function') this._read = options.read;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            }\n\n            Stream.call(this);\n          }\n\n          Object.defineProperty(Readable.prototype, 'destroyed', {\n            get: function () {\n              if (this._readableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed;\n            },\n            set: function (value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._readableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n            }\n          });\n          Readable.prototype.destroy = destroyImpl.destroy;\n          Readable.prototype._undestroy = destroyImpl.undestroy;\n\n          Readable.prototype._destroy = function (err, cb) {\n            this.push(null);\n            cb(err);\n          }; // Manually shove something into the read() buffer.\n          // This returns true if the highWaterMark has not been hit yet,\n          // similar to how Writable.write() returns true if you should\n          // write() some more.\n\n\n          Readable.prototype.push = function (chunk, encoding) {\n            var state = this._readableState;\n            var skipChunkCheck;\n\n            if (!state.objectMode) {\n              if (typeof chunk === 'string') {\n                encoding = encoding || state.defaultEncoding;\n\n                if (encoding !== state.encoding) {\n                  chunk = Buffer.from(chunk, encoding);\n                  encoding = '';\n                }\n\n                skipChunkCheck = true;\n              }\n            } else {\n              skipChunkCheck = true;\n            }\n\n            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n          }; // Unshift should *always* be something directly out of read()\n\n\n          Readable.prototype.unshift = function (chunk) {\n            return readableAddChunk(this, chunk, null, true, false);\n          };\n\n          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n            var state = stream._readableState;\n\n            if (chunk === null) {\n              state.reading = false;\n              onEofChunk(stream, state);\n            } else {\n              var er;\n              if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n              if (er) {\n                stream.emit('error', er);\n              } else if (state.objectMode || chunk && chunk.length > 0) {\n                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                  chunk = _uint8ArrayToBuffer(chunk);\n                }\n\n                if (addToFront) {\n                  if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n                } else if (state.ended) {\n                  stream.emit('error', new Error('stream.push() after EOF'));\n                } else {\n                  state.reading = false;\n\n                  if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                  } else {\n                    addChunk(stream, state, chunk, false);\n                  }\n                }\n              } else if (!addToFront) {\n                state.reading = false;\n              }\n            }\n\n            return needMoreData(state);\n          }\n\n          function addChunk(stream, state, chunk, addToFront) {\n            if (state.flowing && state.length === 0 && !state.sync) {\n              stream.emit('data', chunk);\n              stream.read(0);\n            } else {\n              // update the buffer info.\n              state.length += state.objectMode ? 1 : chunk.length;\n              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n              if (state.needReadable) emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n          }\n\n          function chunkInvalid(state, chunk) {\n            var er;\n\n            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new TypeError('Invalid non-string/buffer chunk');\n            }\n\n            return er;\n          } // if it's past the high water mark, we can push in some more.\n          // Also, if we have no data yet, we can stand some\n          // more bytes.  This is to work around cases where hwm=0,\n          // such as the repl.  Also, if the push() triggered a\n          // readable event, and the user called read(largeNumber) such that\n          // needReadable was set, then we ought to push more, so that another\n          // 'readable' event will be triggered.\n\n\n          function needMoreData(state) {\n            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n          }\n\n          Readable.prototype.isPaused = function () {\n            return this._readableState.flowing === false;\n          }; // backwards compatibility.\n\n\n          Readable.prototype.setEncoding = function (enc) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            this._readableState.decoder = new StringDecoder(enc);\n            this._readableState.encoding = enc;\n            return this;\n          }; // Don't raise the hwm > 8MB\n\n\n          var MAX_HWM = 0x800000;\n\n          function computeNewHighWaterMark(n) {\n            if (n >= MAX_HWM) {\n              n = MAX_HWM;\n            } else {\n              // Get the next highest power of 2 to prevent increasing hwm excessively in\n              // tiny amounts\n              n--;\n              n |= n >>> 1;\n              n |= n >>> 2;\n              n |= n >>> 4;\n              n |= n >>> 8;\n              n |= n >>> 16;\n              n++;\n            }\n\n            return n;\n          } // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function howMuchToRead(n, state) {\n            if (n <= 0 || state.length === 0 && state.ended) return 0;\n            if (state.objectMode) return 1;\n\n            if (n !== n) {\n              // Only flow one buffer at a time\n              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n            } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n            if (n <= state.length) return n; // Don't have enough\n\n            if (!state.ended) {\n              state.needReadable = true;\n              return 0;\n            }\n\n            return state.length;\n          } // you can override either this method, or the async _read(n) below.\n\n\n          Readable.prototype.read = function (n) {\n            debug('read', n);\n            n = parseInt(n, 10);\n            var state = this._readableState;\n            var nOrig = n;\n            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n            // already have a bunch of data in the buffer, then just trigger\n            // the 'readable' event and move on.\n\n            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n              debug('read: emitReadable', state.length, state.ended);\n              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n              return null;\n            }\n\n            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n            if (n === 0 && state.ended) {\n              if (state.length === 0) endReadable(this);\n              return null;\n            } // All the actual chunk generation logic needs to be\n            // *below* the call to _read.  The reason is that in certain\n            // synthetic stream cases, such as passthrough streams, _read\n            // may be a completely synchronous operation which may change\n            // the state of the read buffer, providing enough data when\n            // before there was *not* enough.\n            //\n            // So, the steps are:\n            // 1. Figure out what the state of things will be after we do\n            // a read from the buffer.\n            //\n            // 2. If that resulting state will trigger a _read, then call _read.\n            // Note that this may be asynchronous, or synchronous.  Yes, it is\n            // deeply ugly to write APIs this way, but that still doesn't mean\n            // that the Readable class should behave improperly, as streams are\n            // designed to be sync/async agnostic.\n            // Take note if the _read call is sync or async (ie, if the read call\n            // has returned yet), so that we know whether or not it's safe to emit\n            // 'readable' etc.\n            //\n            // 3. Actually pull the requested chunks out of the buffer and return.\n            // if we need a readable event, then we need to do some reading.\n\n\n            var doRead = state.needReadable;\n            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n            if (state.length === 0 || state.length - n < state.highWaterMark) {\n              doRead = true;\n              debug('length less than watermark', doRead);\n            } // however, if we've ended, then there's no point, and if we're already\n            // reading, then it's unnecessary.\n\n\n            if (state.ended || state.reading) {\n              doRead = false;\n              debug('reading or ended', doRead);\n            } else if (doRead) {\n              debug('do read');\n              state.reading = true;\n              state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n              if (state.length === 0) state.needReadable = true; // call internal read method\n\n              this._read(state.highWaterMark);\n\n              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n              // and we need to re-evaluate how much data we can return to the user.\n\n              if (!state.reading) n = howMuchToRead(nOrig, state);\n            }\n\n            var ret;\n            if (n > 0) ret = fromList(n, state);else ret = null;\n\n            if (ret === null) {\n              state.needReadable = true;\n              n = 0;\n            } else {\n              state.length -= n;\n            }\n\n            if (state.length === 0) {\n              // If we have nothing in the buffer, then we want to know\n              // as soon as we *do* get something into the buffer.\n              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n              if (nOrig !== n && state.ended) endReadable(this);\n            }\n\n            if (ret !== null) this.emit('data', ret);\n            return ret;\n          };\n\n          function onEofChunk(stream, state) {\n            if (state.ended) return;\n\n            if (state.decoder) {\n              var chunk = state.decoder.end();\n\n              if (chunk && chunk.length) {\n                state.buffer.push(chunk);\n                state.length += state.objectMode ? 1 : chunk.length;\n              }\n            }\n\n            state.ended = true; // emit 'readable' now to make sure it gets picked up.\n\n            emitReadable(stream);\n          } // Don't emit readable right away in sync mode, because this can trigger\n          // another read() call => stack overflow.  This way, it might trigger\n          // a nextTick recursion warning, but that's not so bad.\n\n\n          function emitReadable(stream) {\n            var state = stream._readableState;\n            state.needReadable = false;\n\n            if (!state.emittedReadable) {\n              debug('emitReadable', state.flowing);\n              state.emittedReadable = true;\n              if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n            }\n          }\n\n          function emitReadable_(stream) {\n            debug('emit readable');\n            stream.emit('readable');\n            flow(stream);\n          } // at this point, the user has presumably seen the 'readable' event,\n          // and called read() to consume some data.  that may have triggered\n          // in turn another _read(n) call, in which case reading = true if\n          // it's in progress.\n          // However, if we're not ended, or reading, and the length < hwm,\n          // then go ahead and try to read some more preemptively.\n\n\n          function maybeReadMore(stream, state) {\n            if (!state.readingMore) {\n              state.readingMore = true;\n              pna.nextTick(maybeReadMore_, stream, state);\n            }\n          }\n\n          function maybeReadMore_(stream, state) {\n            var len = state.length;\n\n            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n              debug('maybeReadMore read 0');\n              stream.read(0);\n              if (len === state.length) // didn't get any data, stop spinning.\n                break;else len = state.length;\n            }\n\n            state.readingMore = false;\n          } // abstract method.  to be overridden in specific implementation classes.\n          // call cb(er, data) where data is <= n in length.\n          // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n          // arbitrary, and perhaps not very meaningful.\n\n\n          Readable.prototype._read = function (n) {\n            this.emit('error', new Error('_read() is not implemented'));\n          };\n\n          Readable.prototype.pipe = function (dest, pipeOpts) {\n            var src = this;\n            var state = this._readableState;\n\n            switch (state.pipesCount) {\n              case 0:\n                state.pipes = dest;\n                break;\n\n              case 1:\n                state.pipes = [state.pipes, dest];\n                break;\n\n              default:\n                state.pipes.push(dest);\n                break;\n            }\n\n            state.pipesCount += 1;\n            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n            var endFn = doEnd ? onend : unpipe;\n            if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n            dest.on('unpipe', onunpipe);\n\n            function onunpipe(readable, unpipeInfo) {\n              debug('onunpipe');\n\n              if (readable === src) {\n                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                  unpipeInfo.hasUnpiped = true;\n                  cleanup();\n                }\n              }\n            }\n\n            function onend() {\n              debug('onend');\n              dest.end();\n            } // when the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n\n\n            var ondrain = pipeOnDrain(src);\n            dest.on('drain', ondrain);\n            var cleanedUp = false;\n\n            function cleanup() {\n              debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n              dest.removeListener('close', onclose);\n              dest.removeListener('finish', onfinish);\n              dest.removeListener('drain', ondrain);\n              dest.removeListener('error', onerror);\n              dest.removeListener('unpipe', onunpipe);\n              src.removeListener('end', onend);\n              src.removeListener('end', unpipe);\n              src.removeListener('data', ondata);\n              cleanedUp = true; // if the reader is waiting for a drain event from this\n              // specific writer, then it would cause it to never start\n              // flowing again.\n              // So, if this is awaiting a drain, then we just call it now.\n              // If we don't know, then assume that we are waiting for one.\n\n              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n            } // If the user pushes more data while we're writing to dest then we'll end up\n            // in ondata again. However, we only want to increase awaitDrain once because\n            // dest will only emit one 'drain' event for the multiple writes.\n            // => Introduce a guard on increasing awaitDrain.\n\n\n            var increasedAwaitDrain = false;\n            src.on('data', ondata);\n\n            function ondata(chunk) {\n              debug('ondata');\n              increasedAwaitDrain = false;\n              var ret = dest.write(chunk);\n\n              if (false === ret && !increasedAwaitDrain) {\n                // If the user unpiped during `dest.write()`, it is possible\n                // to get stuck in a permanently paused state if that write\n                // also returned false.\n                // => Check whether `dest` is still a piping destination.\n                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                  debug('false write response, pause', src._readableState.awaitDrain);\n                  src._readableState.awaitDrain++;\n                  increasedAwaitDrain = true;\n                }\n\n                src.pause();\n              }\n            } // if the dest has an error, then stop piping into it.\n            // however, don't suppress the throwing behavior for this.\n\n\n            function onerror(er) {\n              debug('onerror', er);\n              unpipe();\n              dest.removeListener('error', onerror);\n              if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n            } // Make sure our error handler is attached before userland ones.\n\n\n            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n            function onclose() {\n              dest.removeListener('finish', onfinish);\n              unpipe();\n            }\n\n            dest.once('close', onclose);\n\n            function onfinish() {\n              debug('onfinish');\n              dest.removeListener('close', onclose);\n              unpipe();\n            }\n\n            dest.once('finish', onfinish);\n\n            function unpipe() {\n              debug('unpipe');\n              src.unpipe(dest);\n            } // tell the dest that it's being piped to\n\n\n            dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n            if (!state.flowing) {\n              debug('pipe resume');\n              src.resume();\n            }\n\n            return dest;\n          };\n\n          function pipeOnDrain(src) {\n            return function () {\n              var state = src._readableState;\n              debug('pipeOnDrain', state.awaitDrain);\n              if (state.awaitDrain) state.awaitDrain--;\n\n              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n                state.flowing = true;\n                flow(src);\n              }\n            };\n          }\n\n          Readable.prototype.unpipe = function (dest) {\n            var state = this._readableState;\n            var unpipeInfo = {\n              hasUnpiped: false\n            }; // if we're not piping anywhere, then do nothing.\n\n            if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n            if (state.pipesCount === 1) {\n              // passed in one, but it's not the right one.\n              if (dest && dest !== state.pipes) return this;\n              if (!dest) dest = state.pipes; // got a match.\n\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n              if (dest) dest.emit('unpipe', this, unpipeInfo);\n              return this;\n            } // slow case. multiple pipe destinations.\n\n\n            if (!dest) {\n              // remove all.\n              var dests = state.pipes;\n              var len = state.pipesCount;\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n\n              for (var i = 0; i < len; i++) {\n                dests[i].emit('unpipe', this, unpipeInfo);\n              }\n\n              return this;\n            } // try to find the right one.\n\n\n            var index = indexOf(state.pipes, dest);\n            if (index === -1) return this;\n            state.pipes.splice(index, 1);\n            state.pipesCount -= 1;\n            if (state.pipesCount === 1) state.pipes = state.pipes[0];\n            dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }; // set up data events if they are asked for\n          // Ensure readable listeners eventually get something\n\n\n          Readable.prototype.on = function (ev, fn) {\n            var res = Stream.prototype.on.call(this, ev, fn);\n\n            if (ev === 'data') {\n              // Start flowing on next tick if stream isn't explicitly paused\n              if (this._readableState.flowing !== false) this.resume();\n            } else if (ev === 'readable') {\n              var state = this._readableState;\n\n              if (!state.endEmitted && !state.readableListening) {\n                state.readableListening = state.needReadable = true;\n                state.emittedReadable = false;\n\n                if (!state.reading) {\n                  pna.nextTick(nReadingNextTick, this);\n                } else if (state.length) {\n                  emitReadable(this);\n                }\n              }\n            }\n\n            return res;\n          };\n\n          Readable.prototype.addListener = Readable.prototype.on;\n\n          function nReadingNextTick(self) {\n            debug('readable nexttick read 0');\n            self.read(0);\n          } // pause() and resume() are remnants of the legacy readable stream API\n          // If the user uses them, then switch into old mode.\n\n\n          Readable.prototype.resume = function () {\n            var state = this._readableState;\n\n            if (!state.flowing) {\n              debug('resume');\n              state.flowing = true;\n              resume(this, state);\n            }\n\n            return this;\n          };\n\n          function resume(stream, state) {\n            if (!state.resumeScheduled) {\n              state.resumeScheduled = true;\n              pna.nextTick(resume_, stream, state);\n            }\n          }\n\n          function resume_(stream, state) {\n            if (!state.reading) {\n              debug('resume read 0');\n              stream.read(0);\n            }\n\n            state.resumeScheduled = false;\n            state.awaitDrain = 0;\n            stream.emit('resume');\n            flow(stream);\n            if (state.flowing && !state.reading) stream.read(0);\n          }\n\n          Readable.prototype.pause = function () {\n            debug('call pause flowing=%j', this._readableState.flowing);\n\n            if (false !== this._readableState.flowing) {\n              debug('pause');\n              this._readableState.flowing = false;\n              this.emit('pause');\n            }\n\n            return this;\n          };\n\n          function flow(stream) {\n            var state = stream._readableState;\n            debug('flow', state.flowing);\n\n            while (state.flowing && stream.read() !== null) {}\n          } // wrap an old-style stream as the async data source.\n          // This is *not* part of the readable stream interface.\n          // It is an ugly unfortunate mess of history.\n\n\n          Readable.prototype.wrap = function (stream) {\n            var _this = this;\n\n            var state = this._readableState;\n            var paused = false;\n            stream.on('end', function () {\n              debug('wrapped end');\n\n              if (state.decoder && !state.ended) {\n                var chunk = state.decoder.end();\n                if (chunk && chunk.length) _this.push(chunk);\n              }\n\n              _this.push(null);\n            });\n            stream.on('data', function (chunk) {\n              debug('wrapped data');\n              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n              var ret = _this.push(chunk);\n\n              if (!ret) {\n                paused = true;\n                stream.pause();\n              }\n            }); // proxy all the other methods.\n            // important when wrapping filters and duplexes.\n\n            for (var i in stream) {\n              if (this[i] === undefined && typeof stream[i] === 'function') {\n                this[i] = function (method) {\n                  return function () {\n                    return stream[method].apply(stream, arguments);\n                  };\n                }(i);\n              }\n            } // proxy certain important events.\n\n\n            for (var n = 0; n < kProxyEvents.length; n++) {\n              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n            } // when we try to consume some more bytes, simply unpause the\n            // underlying stream.\n\n\n            this._read = function (n) {\n              debug('wrapped _read', n);\n\n              if (paused) {\n                paused = false;\n                stream.resume();\n              }\n            };\n\n            return this;\n          };\n\n          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function () {\n              return this._readableState.highWaterMark;\n            }\n          }); // exposed for testing purposes only.\n\n          Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.\n          // Length is the combined lengths of all the buffers in the list.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n          function fromList(n, state) {\n            // nothing buffered\n            if (state.length === 0) return null;\n            var ret;\n            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n              // read it all, truncate the list\n              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n              state.buffer.clear();\n            } else {\n              // read part of list\n              ret = fromListPartial(n, state.buffer, state.decoder);\n            }\n            return ret;\n          } // Extracts only enough buffered data to satisfy the amount requested.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function fromListPartial(n, list, hasStrings) {\n            var ret;\n\n            if (n < list.head.data.length) {\n              // slice is the same for buffers and strings\n              ret = list.head.data.slice(0, n);\n              list.head.data = list.head.data.slice(n);\n            } else if (n === list.head.data.length) {\n              // first chunk is a perfect match\n              ret = list.shift();\n            } else {\n              // result spans more than one buffer\n              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n            }\n\n            return ret;\n          } // Copies a specified amount of characters from the list of buffered data\n          // chunks.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function copyFromBufferString(n, list) {\n            var p = list.head;\n            var c = 1;\n            var ret = p.data;\n            n -= ret.length;\n\n            while (p = p.next) {\n              var str = p.data;\n              var nb = n > str.length ? str.length : n;\n              if (nb === str.length) ret += str;else ret += str.slice(0, n);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === str.length) {\n                  ++c;\n                  if (p.next) list.head = p.next;else list.head = list.tail = null;\n                } else {\n                  list.head = p;\n                  p.data = str.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            list.length -= c;\n            return ret;\n          } // Copies a specified amount of bytes from the list of buffered data chunks.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function copyFromBuffer(n, list) {\n            var ret = Buffer.allocUnsafe(n);\n            var p = list.head;\n            var c = 1;\n            p.data.copy(ret);\n            n -= p.data.length;\n\n            while (p = p.next) {\n              var buf = p.data;\n              var nb = n > buf.length ? buf.length : n;\n              buf.copy(ret, ret.length - n, 0, nb);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === buf.length) {\n                  ++c;\n                  if (p.next) list.head = p.next;else list.head = list.tail = null;\n                } else {\n                  list.head = p;\n                  p.data = buf.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            list.length -= c;\n            return ret;\n          }\n\n          function endReadable(stream) {\n            var state = stream._readableState; // If we get here before consuming all the bytes, then that is a\n            // bug in node.  Should never happen.\n\n            if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n            if (!state.endEmitted) {\n              state.ended = true;\n              pna.nextTick(endReadableNT, state, stream);\n            }\n          }\n\n          function endReadableNT(state, stream) {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n              state.endEmitted = true;\n              stream.readable = false;\n              stream.emit('end');\n            }\n          }\n\n          function indexOf(xs, x) {\n            for (var i = 0, l = xs.length; i < l; i++) {\n              if (xs[i] === x) return i;\n            }\n\n            return -1;\n          }\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./_stream_duplex\": 22,\n      \"./internal/streams/BufferList\": 27,\n      \"./internal/streams/destroy\": 28,\n      \"./internal/streams/stream\": 29,\n      \"_process\": 69,\n      \"core-util-is\": 18,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"isarray\": 35,\n      \"process-nextick-args\": 45,\n      \"safe-buffer\": 31,\n      \"string_decoder/\": 32,\n      \"util\": 2\n    }],\n    25: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n      'use strict';\n\n      module.exports = Transform;\n\n      var Duplex = require('./_stream_duplex');\n      /*<replacement>*/\n\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n        var cb = ts.writecb;\n\n        if (!cb) {\n          return this.emit('error', new Error('write callback called multiple times'));\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n        cb(er);\n        var rs = this._readableState;\n        rs.reading = false;\n\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n        Duplex.call(this, options);\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        }; // start out asking for a readable event once data is transformed.\n\n        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        } // When the writable side finishes, then flush out anything remaining.\n\n\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function') {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      }; // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n\n\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        throw new Error('_transform() is not implemented');\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      }; // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n\n\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n          ts.transforming = true;\n\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        var _this2 = this;\n\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n\n          _this2.emit('close');\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data); // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n        return stream.push(null);\n      }\n    }, {\n      \"./_stream_duplex\": 22,\n      \"core-util-is\": 18,\n      \"inherits\": 34\n    }],\n    26: [function (require, module, exports) {\n      (function (process, global, setImmediate) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // A bit simpler than readable streams.\n          // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n          // the drain event emission and buffering.\n          'use strict';\n          /*<replacement>*/\n\n          var pna = require('process-nextick-args');\n          /*</replacement>*/\n\n\n          module.exports = Writable;\n          /* <replacement> */\n\n          function WriteReq(chunk, encoding, cb) {\n            this.chunk = chunk;\n            this.encoding = encoding;\n            this.callback = cb;\n            this.next = null;\n          } // It seems a linked list but it is not\n          // there will be only 2 of these for each stream\n\n\n          function CorkedRequest(state) {\n            var _this = this;\n\n            this.next = null;\n            this.entry = null;\n\n            this.finish = function () {\n              onCorkedFinish(_this, state);\n            };\n          }\n          /* </replacement> */\n\n          /*<replacement>*/\n\n\n          var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Duplex;\n          /*</replacement>*/\n\n          Writable.WritableState = WritableState;\n          /*<replacement>*/\n\n          var util = Object.create(require('core-util-is'));\n          util.inherits = require('inherits');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var internalUtil = {\n            deprecate: require('util-deprecate')\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Buffer = require('safe-buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*</replacement>*/\n\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          util.inherits(Writable, Stream);\n\n          function nop() {}\n\n          function WritableState(options, stream) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n            // contains buffers or objects.\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n            // Note: 0 is a valid value, means that we always return false if\n            // the entire buffer is not flushed immediately on write()\n\n            var hwm = options.highWaterMark;\n            var writableHwm = options.writableHighWaterMark;\n            var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n            if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n            this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called\n\n            this.finalCalled = false; // drain event flag.\n\n            this.needDrain = false; // at the start of calling end()\n\n            this.ending = false; // when end() has been called, and returned\n\n            this.ended = false; // when 'finish' is emitted\n\n            this.finished = false; // has it been destroyed\n\n            this.destroyed = false; // should we decode strings into buffers before passing to _write?\n            // this is here so that some node-core streams can optimize string\n            // handling at a lower level.\n\n            var noDecode = options.decodeStrings === false;\n            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n            // of how much we're waiting to get pushed to some underlying\n            // socket or file.\n\n            this.length = 0; // a flag to see when we're in the middle of a write.\n\n            this.writing = false; // when true all writes will be buffered until .uncork() call\n\n            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n            // or on a later tick.  We set this to true at first, because any\n            // actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first write call.\n\n            this.sync = true; // a flag to know if we're processing previously buffered items, which\n            // may call the _write() callback in the same tick, so that we don't\n            // end up in an overlapped onwrite situation.\n\n            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n            this.onwrite = function (er) {\n              onwrite(stream, er);\n            }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n            this.writecb = null; // the amount that is being written when _write is called.\n\n            this.writelen = 0;\n            this.bufferedRequest = null;\n            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n            // this must be 0 before 'finish' can be emitted\n\n            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n            // This is relevant for synchronous Transform streams\n\n            this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n            this.errorEmitted = false; // count buffered requests\n\n            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n            // one allocated and free to use, and we maintain at most two\n\n            this.corkedRequestsFree = new CorkedRequest(this);\n          }\n\n          WritableState.prototype.getBuffer = function getBuffer() {\n            var current = this.bufferedRequest;\n            var out = [];\n\n            while (current) {\n              out.push(current);\n              current = current.next;\n            }\n\n            return out;\n          };\n\n          (function () {\n            try {\n              Object.defineProperty(WritableState.prototype, 'buffer', {\n                get: internalUtil.deprecate(function () {\n                  return this.getBuffer();\n                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n              });\n            } catch (_) {}\n          })(); // Test _writableState for inheritance to account for Duplex streams,\n          // whose prototype chain only points to Readable.\n\n\n          var realHasInstance;\n\n          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n            realHasInstance = Function.prototype[Symbol.hasInstance];\n            Object.defineProperty(Writable, Symbol.hasInstance, {\n              value: function (object) {\n                if (realHasInstance.call(this, object)) return true;\n                if (this !== Writable) return false;\n                return object && object._writableState instanceof WritableState;\n              }\n            });\n          } else {\n            realHasInstance = function (object) {\n              return object instanceof this;\n            };\n          }\n\n          function Writable(options) {\n            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n            // `realHasInstance` is necessary because using plain `instanceof`\n            // would return false, as no `_writableState` property is attached.\n            // Trying to use the custom `instanceof` for Writable here will also break the\n            // Node.js LazyTransform implementation, which has a non-trivial getter for\n            // `_writableState` that would lead to infinite recursion.\n\n            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n              return new Writable(options);\n            }\n\n            this._writableState = new WritableState(options, this); // legacy.\n\n            this.writable = true;\n\n            if (options) {\n              if (typeof options.write === 'function') this._write = options.write;\n              if (typeof options.writev === 'function') this._writev = options.writev;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n              if (typeof options.final === 'function') this._final = options.final;\n            }\n\n            Stream.call(this);\n          } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n          Writable.prototype.pipe = function () {\n            this.emit('error', new Error('Cannot pipe, not readable'));\n          };\n\n          function writeAfterEnd(stream, cb) {\n            var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n            stream.emit('error', er);\n            pna.nextTick(cb, er);\n          } // Checks that a user-supplied chunk is valid, especially for the particular\n          // mode the stream is in. Currently this means that `null` is never accepted\n          // and undefined/non-string values are only allowed in object mode.\n\n\n          function validChunk(stream, state, chunk, cb) {\n            var valid = true;\n            var er = false;\n\n            if (chunk === null) {\n              er = new TypeError('May not write null values to stream');\n            } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new TypeError('Invalid non-string/buffer chunk');\n            }\n\n            if (er) {\n              stream.emit('error', er);\n              pna.nextTick(cb, er);\n              valid = false;\n            }\n\n            return valid;\n          }\n\n          Writable.prototype.write = function (chunk, encoding, cb) {\n            var state = this._writableState;\n            var ret = false;\n\n            var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n            if (isBuf && !Buffer.isBuffer(chunk)) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n            if (typeof cb !== 'function') cb = nop;\n            if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n              state.pendingcb++;\n              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n            }\n            return ret;\n          };\n\n          Writable.prototype.cork = function () {\n            var state = this._writableState;\n            state.corked++;\n          };\n\n          Writable.prototype.uncork = function () {\n            var state = this._writableState;\n\n            if (state.corked) {\n              state.corked--;\n              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n            }\n          };\n\n          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n            // node::ParseEncoding() requires lower case.\n            if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n            this._writableState.defaultEncoding = encoding;\n            return this;\n          };\n\n          function decodeChunk(state, chunk, encoding) {\n            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, encoding);\n            }\n\n            return chunk;\n          }\n\n          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function () {\n              return this._writableState.highWaterMark;\n            }\n          }); // if we're already writing something, then just put this\n          // in the queue, and wait our turn.  Otherwise, call _write\n          // If we return false, then we need a drain event, so set that flag.\n\n          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n            if (!isBuf) {\n              var newChunk = decodeChunk(state, chunk, encoding);\n\n              if (chunk !== newChunk) {\n                isBuf = true;\n                encoding = 'buffer';\n                chunk = newChunk;\n              }\n            }\n\n            var len = state.objectMode ? 1 : chunk.length;\n            state.length += len;\n            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n            if (!ret) state.needDrain = true;\n\n            if (state.writing || state.corked) {\n              var last = state.lastBufferedRequest;\n              state.lastBufferedRequest = {\n                chunk: chunk,\n                encoding: encoding,\n                isBuf: isBuf,\n                callback: cb,\n                next: null\n              };\n\n              if (last) {\n                last.next = state.lastBufferedRequest;\n              } else {\n                state.bufferedRequest = state.lastBufferedRequest;\n              }\n\n              state.bufferedRequestCount += 1;\n            } else {\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n            }\n\n            return ret;\n          }\n\n          function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n            state.writelen = len;\n            state.writecb = cb;\n            state.writing = true;\n            state.sync = true;\n            if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n            state.sync = false;\n          }\n\n          function onwriteError(stream, state, sync, er, cb) {\n            --state.pendingcb;\n\n            if (sync) {\n              // defer the callback if we are being called synchronously\n              // to avoid piling up things on the stack\n              pna.nextTick(cb, er); // this can emit finish, and it will always happen\n              // after error\n\n              pna.nextTick(finishMaybe, stream, state);\n              stream._writableState.errorEmitted = true;\n              stream.emit('error', er);\n            } else {\n              // the caller expect this to happen before if\n              // it is async\n              cb(er);\n              stream._writableState.errorEmitted = true;\n              stream.emit('error', er); // this can emit finish, but finish must\n              // always follow error\n\n              finishMaybe(stream, state);\n            }\n          }\n\n          function onwriteStateUpdate(state) {\n            state.writing = false;\n            state.writecb = null;\n            state.length -= state.writelen;\n            state.writelen = 0;\n          }\n\n          function onwrite(stream, er) {\n            var state = stream._writableState;\n            var sync = state.sync;\n            var cb = state.writecb;\n            onwriteStateUpdate(state);\n            if (er) onwriteError(stream, state, sync, er, cb);else {\n              // Check if we're actually ready to finish, but don't emit yet\n              var finished = needFinish(state);\n\n              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n                clearBuffer(stream, state);\n              }\n\n              if (sync) {\n                /*<replacement>*/\n                asyncWrite(afterWrite, stream, state, finished, cb);\n                /*</replacement>*/\n              } else {\n                afterWrite(stream, state, finished, cb);\n              }\n            }\n          }\n\n          function afterWrite(stream, state, finished, cb) {\n            if (!finished) onwriteDrain(stream, state);\n            state.pendingcb--;\n            cb();\n            finishMaybe(stream, state);\n          } // Must force callback to be called on nextTick, so that we don't\n          // emit 'drain' before the write() consumer gets the 'false' return\n          // value, and has a chance to attach a 'drain' listener.\n\n\n          function onwriteDrain(stream, state) {\n            if (state.length === 0 && state.needDrain) {\n              state.needDrain = false;\n              stream.emit('drain');\n            }\n          } // if there's something in the buffer waiting, then process it\n\n\n          function clearBuffer(stream, state) {\n            state.bufferProcessing = true;\n            var entry = state.bufferedRequest;\n\n            if (stream._writev && entry && entry.next) {\n              // Fast case, write everything using _writev()\n              var l = state.bufferedRequestCount;\n              var buffer = new Array(l);\n              var holder = state.corkedRequestsFree;\n              holder.entry = entry;\n              var count = 0;\n              var allBuffers = true;\n\n              while (entry) {\n                buffer[count] = entry;\n                if (!entry.isBuf) allBuffers = false;\n                entry = entry.next;\n                count += 1;\n              }\n\n              buffer.allBuffers = allBuffers;\n              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n              // as the hot path ends with doWrite\n\n              state.pendingcb++;\n              state.lastBufferedRequest = null;\n\n              if (holder.next) {\n                state.corkedRequestsFree = holder.next;\n                holder.next = null;\n              } else {\n                state.corkedRequestsFree = new CorkedRequest(state);\n              }\n\n              state.bufferedRequestCount = 0;\n            } else {\n              // Slow case, write chunks one-by-one\n              while (entry) {\n                var chunk = entry.chunk;\n                var encoding = entry.encoding;\n                var cb = entry.callback;\n                var len = state.objectMode ? 1 : chunk.length;\n                doWrite(stream, state, false, len, chunk, encoding, cb);\n                entry = entry.next;\n                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n                // it means that we need to wait until it does.\n                // also, that means that the chunk and cb are currently\n                // being processed, so move the buffer counter past them.\n\n                if (state.writing) {\n                  break;\n                }\n              }\n\n              if (entry === null) state.lastBufferedRequest = null;\n            }\n\n            state.bufferedRequest = entry;\n            state.bufferProcessing = false;\n          }\n\n          Writable.prototype._write = function (chunk, encoding, cb) {\n            cb(new Error('_write() is not implemented'));\n          };\n\n          Writable.prototype._writev = null;\n\n          Writable.prototype.end = function (chunk, encoding, cb) {\n            var state = this._writableState;\n\n            if (typeof chunk === 'function') {\n              cb = chunk;\n              chunk = null;\n              encoding = null;\n            } else if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n            if (state.corked) {\n              state.corked = 1;\n              this.uncork();\n            } // ignore unnecessary end() calls.\n\n\n            if (!state.ending && !state.finished) endWritable(this, state, cb);\n          };\n\n          function needFinish(state) {\n            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n          }\n\n          function callFinal(stream, state) {\n            stream._final(function (err) {\n              state.pendingcb--;\n\n              if (err) {\n                stream.emit('error', err);\n              }\n\n              state.prefinished = true;\n              stream.emit('prefinish');\n              finishMaybe(stream, state);\n            });\n          }\n\n          function prefinish(stream, state) {\n            if (!state.prefinished && !state.finalCalled) {\n              if (typeof stream._final === 'function') {\n                state.pendingcb++;\n                state.finalCalled = true;\n                pna.nextTick(callFinal, stream, state);\n              } else {\n                state.prefinished = true;\n                stream.emit('prefinish');\n              }\n            }\n          }\n\n          function finishMaybe(stream, state) {\n            var need = needFinish(state);\n\n            if (need) {\n              prefinish(stream, state);\n\n              if (state.pendingcb === 0) {\n                state.finished = true;\n                stream.emit('finish');\n              }\n            }\n\n            return need;\n          }\n\n          function endWritable(stream, state, cb) {\n            state.ending = true;\n            finishMaybe(stream, state);\n\n            if (cb) {\n              if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n            }\n\n            state.ended = true;\n            stream.writable = false;\n          }\n\n          function onCorkedFinish(corkReq, state, err) {\n            var entry = corkReq.entry;\n            corkReq.entry = null;\n\n            while (entry) {\n              var cb = entry.callback;\n              state.pendingcb--;\n              cb(err);\n              entry = entry.next;\n            }\n\n            if (state.corkedRequestsFree) {\n              state.corkedRequestsFree.next = corkReq;\n            } else {\n              state.corkedRequestsFree = corkReq;\n            }\n          }\n\n          Object.defineProperty(Writable.prototype, 'destroyed', {\n            get: function () {\n              if (this._writableState === undefined) {\n                return false;\n              }\n\n              return this._writableState.destroyed;\n            },\n            set: function (value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._writableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._writableState.destroyed = value;\n            }\n          });\n          Writable.prototype.destroy = destroyImpl.destroy;\n          Writable.prototype._undestroy = destroyImpl.undestroy;\n\n          Writable.prototype._destroy = function (err, cb) {\n            this.end();\n            cb(err);\n          };\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate);\n    }, {\n      \"./_stream_duplex\": 22,\n      \"./internal/streams/destroy\": 28,\n      \"./internal/streams/stream\": 29,\n      \"_process\": 69,\n      \"core-util-is\": 18,\n      \"inherits\": 34,\n      \"process-nextick-args\": 45,\n      \"safe-buffer\": 31,\n      \"timers\": 74,\n      \"util-deprecate\": 65\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      var util = require('util');\n\n      function copyBuffer(src, target, offset) {\n        src.copy(target, offset);\n      }\n\n      module.exports = function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        BufferList.prototype.push = function push(v) {\n          var entry = {\n            data: v,\n            next: null\n          };\n          if (this.length > 0) this.tail.next = entry;else this.head = entry;\n          this.tail = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.unshift = function unshift(v) {\n          var entry = {\n            data: v,\n            next: this.head\n          };\n          if (this.length === 0) this.tail = entry;\n          this.head = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.shift = function shift() {\n          if (this.length === 0) return;\n          var ret = this.head.data;\n          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n          --this.length;\n          return ret;\n        };\n\n        BufferList.prototype.clear = function clear() {\n          this.head = this.tail = null;\n          this.length = 0;\n        };\n\n        BufferList.prototype.join = function join(s) {\n          if (this.length === 0) return '';\n          var p = this.head;\n          var ret = '' + p.data;\n\n          while (p = p.next) {\n            ret += s + p.data;\n          }\n\n          return ret;\n        };\n\n        BufferList.prototype.concat = function concat(n) {\n          if (this.length === 0) return Buffer.alloc(0);\n          if (this.length === 1) return this.head.data;\n          var ret = Buffer.allocUnsafe(n >>> 0);\n          var p = this.head;\n          var i = 0;\n\n          while (p) {\n            copyBuffer(p.data, ret, i);\n            i += p.data.length;\n            p = p.next;\n          }\n\n          return ret;\n        };\n\n        return BufferList;\n      }();\n\n      if (util && util.inspect && util.inspect.custom) {\n        module.exports.prototype[util.inspect.custom] = function () {\n          var obj = util.inspect({\n            length: this.length\n          });\n          return this.constructor.name + ' ' + obj;\n        };\n      }\n    }, {\n      \"safe-buffer\": 31,\n      \"util\": 2\n    }],\n    28: [function (require, module, exports) {\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n      // undocumented cb() API, needed for core, not for public API\n\n\n      function destroy(err, cb) {\n        var _this = this;\n\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n        if (readableDestroyed || writableDestroyed) {\n          if (cb) {\n            cb(err);\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n          }\n\n          return this;\n        } // we set destroyed to true before firing error callbacks in order\n        // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n        if (this._readableState) {\n          this._readableState.destroyed = true;\n        } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n        if (this._writableState) {\n          this._writableState.destroyed = true;\n        }\n\n        this._destroy(err || null, function (err) {\n          if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n\n            if (_this._writableState) {\n              _this._writableState.errorEmitted = true;\n            }\n          } else if (cb) {\n            cb(err);\n          }\n        });\n\n        return this;\n      }\n\n      function undestroy() {\n        if (this._readableState) {\n          this._readableState.destroyed = false;\n          this._readableState.reading = false;\n          this._readableState.ended = false;\n          this._readableState.endEmitted = false;\n        }\n\n        if (this._writableState) {\n          this._writableState.destroyed = false;\n          this._writableState.ended = false;\n          this._writableState.ending = false;\n          this._writableState.finished = false;\n          this._writableState.errorEmitted = false;\n        }\n      }\n\n      function emitErrorNT(self, err) {\n        self.emit('error', err);\n      }\n\n      module.exports = {\n        destroy: destroy,\n        undestroy: undestroy\n      };\n    }, {\n      \"process-nextick-args\": 45\n    }],\n    29: [function (require, module, exports) {\n      module.exports = require('events').EventEmitter;\n    }, {\n      \"events\": 4\n    }],\n    30: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 22,\n      \"./lib/_stream_passthrough.js\": 23,\n      \"./lib/_stream_readable.js\": 24,\n      \"./lib/_stream_transform.js\": 25,\n      \"./lib/_stream_writable.js\": 26\n    }],\n    31: [function (require, module, exports) {\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n\n      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      } // Copy static methods from Buffer\n\n\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        var buf = Buffer(size);\n\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return buffer.SlowBuffer(size);\n      };\n    }, {\n      \"buffer\": 3\n    }],\n    32: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n      /*<replacement>*/\n\n      var Buffer = require('safe-buffer').Buffer;\n      /*</replacement>*/\n\n\n      var isEncoding = Buffer.isEncoding || function (encoding) {\n        encoding = '' + encoding;\n\n        switch (encoding && encoding.toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n          case 'raw':\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      function _normalizeEncoding(enc) {\n        if (!enc) return 'utf8';\n        var retried;\n\n        while (true) {\n          switch (enc) {\n            case 'utf8':\n            case 'utf-8':\n              return 'utf8';\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return 'utf16le';\n\n            case 'latin1':\n            case 'binary':\n              return 'latin1';\n\n            case 'base64':\n            case 'ascii':\n            case 'hex':\n              return enc;\n\n            default:\n              if (retried) return; // undefined\n\n              enc = ('' + enc).toLowerCase();\n              retried = true;\n          }\n        }\n      }\n\n      ; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n      // modules monkey-patch it to support additional encodings\n\n      function normalizeEncoding(enc) {\n        var nenc = _normalizeEncoding(enc);\n\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n        return nenc || enc;\n      } // StringDecoder provides an interface for efficiently splitting a series of\n      // buffers into a series of JS strings without breaking apart multi-byte\n      // characters.\n\n\n      exports.StringDecoder = StringDecoder;\n\n      function StringDecoder(encoding) {\n        this.encoding = normalizeEncoding(encoding);\n        var nb;\n\n        switch (this.encoding) {\n          case 'utf16le':\n            this.text = utf16Text;\n            this.end = utf16End;\n            nb = 4;\n            break;\n\n          case 'utf8':\n            this.fillLast = utf8FillLast;\n            nb = 4;\n            break;\n\n          case 'base64':\n            this.text = base64Text;\n            this.end = base64End;\n            nb = 3;\n            break;\n\n          default:\n            this.write = simpleWrite;\n            this.end = simpleEnd;\n            return;\n        }\n\n        this.lastNeed = 0;\n        this.lastTotal = 0;\n        this.lastChar = Buffer.allocUnsafe(nb);\n      }\n\n      StringDecoder.prototype.write = function (buf) {\n        if (buf.length === 0) return '';\n        var r;\n        var i;\n\n        if (this.lastNeed) {\n          r = this.fillLast(buf);\n          if (r === undefined) return '';\n          i = this.lastNeed;\n          this.lastNeed = 0;\n        } else {\n          i = 0;\n        }\n\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n        return r || '';\n      };\n\n      StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\n      StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\n      StringDecoder.prototype.fillLast = function (buf) {\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n        this.lastNeed -= buf.length;\n      }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n      // continuation byte. If an invalid byte is detected, -2 is returned.\n\n\n      function utf8CheckByte(byte) {\n        if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n        return byte >> 6 === 0x02 ? -1 : -2;\n      } // Checks at most 3 bytes at the end of a Buffer in order to detect an\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n      // needed to complete the UTF-8 character (if applicable) are returned.\n\n\n      function utf8CheckIncomplete(self, buf, i) {\n        var j = buf.length - 1;\n        if (j < i) return 0;\n        var nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 1;\n          return nb;\n        }\n\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 2;\n          return nb;\n        }\n\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) {\n            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n          }\n\n          return nb;\n        }\n\n        return 0;\n      } // Validates as many continuation bytes for a multi-byte UTF-8 character as\n      // needed or are available. If we see a non-continuation byte where we expect\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n      // behavior. The continuation byte check is included three times in the case\n      // where all of the continuation bytes for a character exist in the same buffer.\n      // It is also done this way as a slight performance increase instead of using a\n      // loop.\n\n\n      function utf8CheckExtraBytes(self, buf, p) {\n        if ((buf[0] & 0xC0) !== 0x80) {\n          self.lastNeed = 0;\n          return '\\ufffd';\n        }\n\n        if (self.lastNeed > 1 && buf.length > 1) {\n          if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return '\\ufffd';\n          }\n\n          if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n              self.lastNeed = 2;\n              return '\\ufffd';\n            }\n          }\n        }\n      } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\n      function utf8FillLast(buf) {\n        var p = this.lastTotal - this.lastNeed;\n        var r = utf8CheckExtraBytes(this, buf, p);\n        if (r !== undefined) return r;\n\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n\n        buf.copy(this.lastChar, p, 0, buf.length);\n        this.lastNeed -= buf.length;\n      } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n      // partial character, the character's bytes are buffered until the required\n      // number of bytes are available.\n\n\n      function utf8Text(buf, i) {\n        var total = utf8CheckIncomplete(this, buf, i);\n        if (!this.lastNeed) return buf.toString('utf8', i);\n        this.lastTotal = total;\n        var end = buf.length - (total - this.lastNeed);\n        buf.copy(this.lastChar, 0, end);\n        return buf.toString('utf8', i, end);\n      } // For UTF-8, a replacement character is added when ending on a partial\n      // character.\n\n\n      function utf8End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + '\\ufffd';\n        return r;\n      } // UTF-16LE typically needs two bytes per character, but even if we have an even\n      // number of bytes available, we need to check if we end on a leading/high\n      // surrogate. In that case, we need to wait for the next two bytes in order to\n      // decode the last character properly.\n\n\n      function utf16Text(buf, i) {\n        if ((buf.length - i) % 2 === 0) {\n          var r = buf.toString('utf16le', i);\n\n          if (r) {\n            var c = r.charCodeAt(r.length - 1);\n\n            if (c >= 0xD800 && c <= 0xDBFF) {\n              this.lastNeed = 2;\n              this.lastTotal = 4;\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n              return r.slice(0, -1);\n            }\n          }\n\n          return r;\n        }\n\n        this.lastNeed = 1;\n        this.lastTotal = 2;\n        this.lastChar[0] = buf[buf.length - 1];\n        return buf.toString('utf16le', i, buf.length - 1);\n      } // For UTF-16LE we do not explicitly append special replacement characters if we\n      // end on a partial character, we simply let v8 handle that.\n\n\n      function utf16End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n\n        if (this.lastNeed) {\n          var end = this.lastTotal - this.lastNeed;\n          return r + this.lastChar.toString('utf16le', 0, end);\n        }\n\n        return r;\n      }\n\n      function base64Text(buf, i) {\n        var n = (buf.length - i) % 3;\n        if (n === 0) return buf.toString('base64', i);\n        this.lastNeed = 3 - n;\n        this.lastTotal = 3;\n\n        if (n === 1) {\n          this.lastChar[0] = buf[buf.length - 1];\n        } else {\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n        }\n\n        return buf.toString('base64', i, buf.length - n);\n      }\n\n      function base64End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n        return r;\n      } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\n      function simpleWrite(buf) {\n        return buf.toString(this.encoding);\n      }\n\n      function simpleEnd(buf) {\n        return buf && buf.length ? this.write(buf) : '';\n      }\n    }, {\n      \"safe-buffer\": 31\n    }],\n    33: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          var once = require('once');\n\n          var noop = function () {};\n\n          var isRequest = function (stream) {\n            return stream.setHeader && typeof stream.abort === 'function';\n          };\n\n          var isChildProcess = function (stream) {\n            return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;\n          };\n\n          var eos = function (stream, opts, callback) {\n            if (typeof opts === 'function') return eos(stream, null, opts);\n            if (!opts) opts = {};\n            callback = once(callback || noop);\n            var ws = stream._writableState;\n            var rs = stream._readableState;\n            var readable = opts.readable || opts.readable !== false && stream.readable;\n            var writable = opts.writable || opts.writable !== false && stream.writable;\n            var cancelled = false;\n\n            var onlegacyfinish = function () {\n              if (!stream.writable) onfinish();\n            };\n\n            var onfinish = function () {\n              writable = false;\n              if (!readable) callback.call(stream);\n            };\n\n            var onend = function () {\n              readable = false;\n              if (!writable) callback.call(stream);\n            };\n\n            var onexit = function (exitCode) {\n              callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n            };\n\n            var onerror = function (err) {\n              callback.call(stream, err);\n            };\n\n            var onclose = function () {\n              process.nextTick(onclosenexttick);\n            };\n\n            var onclosenexttick = function () {\n              if (cancelled) return;\n              if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));\n              if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));\n            };\n\n            var onrequest = function () {\n              stream.req.on('finish', onfinish);\n            };\n\n            if (isRequest(stream)) {\n              stream.on('complete', onfinish);\n              stream.on('abort', onclose);\n              if (stream.req) onrequest();else stream.on('request', onrequest);\n            } else if (writable && !ws) {\n              // legacy streams\n              stream.on('end', onlegacyfinish);\n              stream.on('close', onlegacyfinish);\n            }\n\n            if (isChildProcess(stream)) stream.on('exit', onexit);\n            stream.on('end', onend);\n            stream.on('finish', onfinish);\n            if (opts.error !== false) stream.on('error', onerror);\n            stream.on('close', onclose);\n            return function () {\n              cancelled = true;\n              stream.removeListener('complete', onfinish);\n              stream.removeListener('abort', onclose);\n              stream.removeListener('request', onrequest);\n              if (stream.req) stream.req.removeListener('finish', onfinish);\n              stream.removeListener('end', onlegacyfinish);\n              stream.removeListener('close', onlegacyfinish);\n              stream.removeListener('finish', onfinish);\n              stream.removeListener('exit', onexit);\n              stream.removeListener('end', onend);\n              stream.removeListener('error', onerror);\n              stream.removeListener('close', onclose);\n            };\n          };\n\n          module.exports = eos;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69,\n      \"once\": 44\n    }],\n    34: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n            ctor.prototype = Object.create(superCtor.prototype, {\n              constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = superCtor.prototype;\n            ctor.prototype = new TempCtor();\n            ctor.prototype.constructor = ctor;\n          }\n        };\n      }\n    }, {}],\n    35: [function (require, module, exports) {\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n    }, {}],\n    36: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          /* Protocol - protocol constants */\n          const protocol = module.exports;\n          /* Command code => mnemonic */\n\n          protocol.types = {\n            0: 'reserved',\n            1: 'connect',\n            2: 'connack',\n            3: 'publish',\n            4: 'puback',\n            5: 'pubrec',\n            6: 'pubrel',\n            7: 'pubcomp',\n            8: 'subscribe',\n            9: 'suback',\n            10: 'unsubscribe',\n            11: 'unsuback',\n            12: 'pingreq',\n            13: 'pingresp',\n            14: 'disconnect',\n            15: 'auth'\n          };\n          /* Mnemonic => Command code */\n\n          protocol.codes = {};\n\n          for (const k in protocol.types) {\n            const v = protocol.types[k];\n            protocol.codes[v] = k;\n          }\n          /* Header */\n\n\n          protocol.CMD_SHIFT = 4;\n          protocol.CMD_MASK = 0xF0;\n          protocol.DUP_MASK = 0x08;\n          protocol.QOS_MASK = 0x03;\n          protocol.QOS_SHIFT = 1;\n          protocol.RETAIN_MASK = 0x01;\n          /* Length */\n\n          protocol.VARBYTEINT_MASK = 0x7F;\n          protocol.VARBYTEINT_FIN_MASK = 0x80;\n          protocol.VARBYTEINT_MAX = 268435455;\n          /* Connack */\n\n          protocol.SESSIONPRESENT_MASK = 0x01;\n          protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);\n          protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT]);\n          /* Connect */\n\n          protocol.USERNAME_MASK = 0x80;\n          protocol.PASSWORD_MASK = 0x40;\n          protocol.WILL_RETAIN_MASK = 0x20;\n          protocol.WILL_QOS_MASK = 0x18;\n          protocol.WILL_QOS_SHIFT = 3;\n          protocol.WILL_FLAG_MASK = 0x04;\n          protocol.CLEAN_SESSION_MASK = 0x02;\n          protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT]);\n          /* Properties */\n\n          protocol.properties = {\n            sessionExpiryInterval: 17,\n            willDelayInterval: 24,\n            receiveMaximum: 33,\n            maximumPacketSize: 39,\n            topicAliasMaximum: 34,\n            requestResponseInformation: 25,\n            requestProblemInformation: 23,\n            userProperties: 38,\n            authenticationMethod: 21,\n            authenticationData: 22,\n            payloadFormatIndicator: 1,\n            messageExpiryInterval: 2,\n            contentType: 3,\n            responseTopic: 8,\n            correlationData: 9,\n            maximumQoS: 36,\n            retainAvailable: 37,\n            assignedClientIdentifier: 18,\n            reasonString: 31,\n            wildcardSubscriptionAvailable: 40,\n            subscriptionIdentifiersAvailable: 41,\n            sharedSubscriptionAvailable: 42,\n            serverKeepAlive: 19,\n            responseInformation: 26,\n            serverReference: 28,\n            topicAlias: 35,\n            subscriptionIdentifier: 11\n          };\n          protocol.propertiesCodes = {};\n\n          for (const prop in protocol.properties) {\n            const id = protocol.properties[prop];\n            protocol.propertiesCodes[id] = prop;\n          }\n\n          protocol.propertiesTypes = {\n            sessionExpiryInterval: 'int32',\n            willDelayInterval: 'int32',\n            receiveMaximum: 'int16',\n            maximumPacketSize: 'int32',\n            topicAliasMaximum: 'int16',\n            requestResponseInformation: 'byte',\n            requestProblemInformation: 'byte',\n            userProperties: 'pair',\n            authenticationMethod: 'string',\n            authenticationData: 'binary',\n            payloadFormatIndicator: 'byte',\n            messageExpiryInterval: 'int32',\n            contentType: 'string',\n            responseTopic: 'string',\n            correlationData: 'binary',\n            maximumQoS: 'int8',\n            retainAvailable: 'byte',\n            assignedClientIdentifier: 'string',\n            reasonString: 'string',\n            wildcardSubscriptionAvailable: 'byte',\n            subscriptionIdentifiersAvailable: 'byte',\n            sharedSubscriptionAvailable: 'byte',\n            serverKeepAlive: 'int16',\n            responseInformation: 'string',\n            serverReference: 'string',\n            topicAlias: 'int16',\n            subscriptionIdentifier: 'var'\n          };\n\n          function genHeader(type) {\n            return [0, 1, 2].map(qos => {\n              return [0, 1].map(dup => {\n                return [0, 1].map(retain => {\n                  const buf = Buffer.alloc(1);\n                  buf.writeUInt8(protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain, 0, true);\n                  return buf;\n                });\n              });\n            });\n          }\n          /* Publish */\n\n\n          protocol.PUBLISH_HEADER = genHeader('publish');\n          /* Subscribe */\n\n          protocol.SUBSCRIBE_HEADER = genHeader('subscribe');\n          protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03;\n          protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01;\n          protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;\n          protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01;\n          protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;\n          protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03;\n          protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;\n          protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20];\n          protocol.SUBSCRIBE_OPTIONS_NL = 0x04;\n          protocol.SUBSCRIBE_OPTIONS_RAP = 0x08;\n          protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02];\n          /* Unsubscribe */\n\n          protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe');\n          /* Confirmations */\n\n          protocol.ACKS = {\n            unsuback: genHeader('unsuback'),\n            puback: genHeader('puback'),\n            pubcomp: genHeader('pubcomp'),\n            pubrel: genHeader('pubrel'),\n            pubrec: genHeader('pubrec')\n          };\n          protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT]);\n          /* Protocol versions */\n\n          protocol.VERSION3 = Buffer.from([3]);\n          protocol.VERSION4 = Buffer.from([4]);\n          protocol.VERSION5 = Buffer.from([5]);\n          protocol.VERSION131 = Buffer.from([131]);\n          protocol.VERSION132 = Buffer.from([132]);\n          /* QoS */\n\n          protocol.QOS = [0, 1, 2].map(qos => {\n            return Buffer.from([qos]);\n          });\n          /* Empty packets */\n\n          protocol.EMPTY = {\n            pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),\n            pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),\n            disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])\n          };\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3\n    }],\n    37: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const writeToStream = require('./writeToStream');\n\n          const EventEmitter = require('events');\n\n          function generate(packet, opts) {\n            const stream = new Accumulator();\n            writeToStream(packet, stream, opts);\n            return stream.concat();\n          }\n\n          class Accumulator extends EventEmitter {\n            constructor() {\n              super();\n              this._array = new Array(20);\n              this._i = 0;\n            }\n\n            write(chunk) {\n              this._array[this._i++] = chunk;\n              return true;\n            }\n\n            concat() {\n              let length = 0;\n              const lengths = new Array(this._array.length);\n              const list = this._array;\n              let pos = 0;\n              let i;\n\n              for (i = 0; i < list.length && list[i] !== undefined; i++) {\n                if (typeof list[i] !== 'string') lengths[i] = list[i].length;else lengths[i] = Buffer.byteLength(list[i]);\n                length += lengths[i];\n              }\n\n              const result = Buffer.allocUnsafe(length);\n\n              for (i = 0; i < list.length && list[i] !== undefined; i++) {\n                if (typeof list[i] !== 'string') {\n                  list[i].copy(result, pos);\n                  pos += lengths[i];\n                } else {\n                  result.write(list[i], pos);\n                  pos += lengths[i];\n                }\n              }\n\n              return result;\n            }\n\n          }\n\n          module.exports = generate;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"./writeToStream\": 42,\n      \"buffer\": 3,\n      \"events\": 4\n    }],\n    38: [function (require, module, exports) {\n      exports.parser = require('./parser').parser;\n      exports.generate = require('./generate');\n      exports.writeToStream = require('./writeToStream');\n    }, {\n      \"./generate\": 37,\n      \"./parser\": 41,\n      \"./writeToStream\": 42\n    }],\n    39: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const max = 65536;\n          const cache = {}; // in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n          // later versions return a Buffer\n          // alternative is Buffer.slice but that creates a new buffer\n          // creating new buffers takes time\n          // SubOk is only false on node < 8\n\n          const SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1));\n\n          function generateBuffer(i) {\n            const buffer = Buffer.allocUnsafe(2);\n            buffer.writeUInt8(i >> 8, 0);\n            buffer.writeUInt8(i & 0x00FF, 0 + 1);\n            return buffer;\n          }\n\n          function generateCache() {\n            for (let i = 0; i < max; i++) {\n              cache[i] = generateBuffer(i);\n            }\n          }\n\n          function genBufVariableByteInt(num) {\n            const maxLength = 4; // max 4 bytes\n\n            let digit = 0;\n            let pos = 0;\n            const buffer = Buffer.allocUnsafe(maxLength);\n\n            do {\n              digit = num % 128 | 0;\n              num = num / 128 | 0;\n              if (num > 0) digit = digit | 0x80;\n              buffer.writeUInt8(digit, pos++);\n            } while (num > 0 && pos < maxLength);\n\n            if (num > 0) {\n              pos = 0;\n            }\n\n            return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);\n          }\n\n          function generate4ByteBuffer(num) {\n            const buffer = Buffer.allocUnsafe(4);\n            buffer.writeUInt32BE(num, 0);\n            return buffer;\n          }\n\n          module.exports = {\n            cache,\n            generateCache,\n            generateNumber: generateBuffer,\n            genBufVariableByteInt,\n            generate4ByteBuffer\n          };\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3\n    }],\n    40: [function (require, module, exports) {\n      class Packet {\n        constructor() {\n          this.cmd = null;\n          this.retain = false;\n          this.qos = 0;\n          this.dup = false;\n          this.length = -1;\n          this.topic = null;\n          this.payload = null;\n        }\n\n      }\n\n      module.exports = Packet;\n    }, {}],\n    41: [function (require, module, exports) {\n      const bl = require('bl');\n\n      const EventEmitter = require('events');\n\n      const Packet = require('./packet');\n\n      const constants = require('./constants');\n\n      const debug = require('debug')('mqtt-packet:parser');\n\n      class Parser extends EventEmitter {\n        constructor() {\n          super();\n          this.parser = this.constructor.parser;\n        }\n\n        static parser(opt) {\n          if (!(this instanceof Parser)) return new Parser().parser(opt);\n          this.settings = opt || {};\n          this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n\n          this._resetState();\n\n          return this;\n        }\n\n        _resetState() {\n          debug('_resetState: resetting packet, error, _list, and _stateCounter');\n          this.packet = new Packet();\n          this.error = null;\n          this._list = bl();\n          this._stateCounter = 0;\n        }\n\n        parse(buf) {\n          if (this.error) this._resetState();\n\n          this._list.append(buf);\n\n          debug('parse: current state: %s', this._states[this._stateCounter]);\n\n          while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n            this._stateCounter++;\n            debug('parse: state complete. _stateCounter is now: %d', this._stateCounter);\n            debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length);\n            if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n          }\n\n          debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length);\n          return this._list.length;\n        }\n\n        _parseHeader() {\n          // There is at least one byte in the buffer\n          const zero = this._list.readUInt8(0);\n\n          this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n          this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n          this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n          this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n          debug('_parseHeader: packet: %o', this.packet);\n\n          this._list.consume(1);\n\n          return true;\n        }\n\n        _parseLength() {\n          // There is at least one byte in the list\n          const result = this._parseVarByteNum(true);\n\n          if (result) {\n            this.packet.length = result.value;\n\n            this._list.consume(result.bytes);\n          }\n\n          debug('_parseLength %d', result.value);\n          return !!result;\n        }\n\n        _parsePayload() {\n          debug('_parsePayload: payload %O', this._list);\n          let result = false; // Do we have a payload? Do we have enough data to complete the payload?\n          // PINGs have no payload\n\n          if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n            this._pos = 0;\n\n            switch (this.packet.cmd) {\n              case 'connect':\n                this._parseConnect();\n\n                break;\n\n              case 'connack':\n                this._parseConnack();\n\n                break;\n\n              case 'publish':\n                this._parsePublish();\n\n                break;\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubrel':\n              case 'pubcomp':\n                this._parseConfirmation();\n\n                break;\n\n              case 'subscribe':\n                this._parseSubscribe();\n\n                break;\n\n              case 'suback':\n                this._parseSuback();\n\n                break;\n\n              case 'unsubscribe':\n                this._parseUnsubscribe();\n\n                break;\n\n              case 'unsuback':\n                this._parseUnsuback();\n\n                break;\n\n              case 'pingreq':\n              case 'pingresp':\n                // These are empty, nothing to do\n                break;\n\n              case 'disconnect':\n                this._parseDisconnect();\n\n                break;\n\n              case 'auth':\n                this._parseAuth();\n\n                break;\n\n              default:\n                this._emitError(new Error('Not supported'));\n\n            }\n\n            result = true;\n          }\n\n          debug('_parsePayload complete result: %s', result);\n          return result;\n        }\n\n        _parseConnect() {\n          debug('_parseConnect');\n          let topic; // Will topic\n\n          let payload; // Will payload\n\n          let password; // Password\n\n          let username; // Username\n\n          const flags = {};\n          const packet = this.packet; // Parse protocolId\n\n          const protocolId = this._parseString();\n\n          if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n\n          if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n            return this._emitError(new Error('Invalid protocolId'));\n          }\n\n          packet.protocolId = protocolId; // Parse constants version number\n\n          if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n          packet.protocolVersion = this._list.readUInt8(this._pos);\n\n          if (packet.protocolVersion >= 128) {\n            packet.bridgeMode = true;\n            packet.protocolVersion = packet.protocolVersion - 128;\n          }\n\n          if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n            return this._emitError(new Error('Invalid protocol version'));\n          }\n\n          this._pos++;\n\n          if (this._pos >= this._list.length) {\n            return this._emitError(new Error('Packet too short'));\n          } // Parse connect flags\n\n\n          flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n          flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n          flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n\n          if (flags.will) {\n            packet.will = {};\n            packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n            packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n          }\n\n          packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n          this._pos++; // Parse keepalive\n\n          packet.keepalive = this._parseNum();\n          if (packet.keepalive === -1) return this._emitError(new Error('Packet too short')); // parse properties\n\n          if (packet.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          } // Parse clientId\n\n\n          const clientId = this._parseString();\n\n          if (clientId === null) return this._emitError(new Error('Packet too short'));\n          packet.clientId = clientId;\n          debug('_parseConnect: packet.clientId: %s', packet.clientId);\n\n          if (flags.will) {\n            if (packet.protocolVersion === 5) {\n              const willProperties = this._parseProperties();\n\n              if (Object.getOwnPropertyNames(willProperties).length) {\n                packet.will.properties = willProperties;\n              }\n            } // Parse will topic\n\n\n            topic = this._parseString();\n            if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n            packet.will.topic = topic;\n            debug('_parseConnect: packet.will.topic: %s', packet.will.topic); // Parse will payload\n\n            payload = this._parseBuffer();\n            if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n            packet.will.payload = payload;\n            debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload);\n          } // Parse username\n\n\n          if (flags.username) {\n            username = this._parseString();\n            if (username === null) return this._emitError(new Error('Cannot parse username'));\n            packet.username = username;\n            debug('_parseConnect: packet.username: %s', packet.username);\n          } // Parse password\n\n\n          if (flags.password) {\n            password = this._parseBuffer();\n            if (password === null) return this._emitError(new Error('Cannot parse password'));\n            packet.password = password;\n          } // need for right parse auth packet and self set up\n\n\n          this.settings = packet;\n          debug('_parseConnect: complete');\n          return packet;\n        }\n\n        _parseConnack() {\n          debug('_parseConnack');\n          const packet = this.packet;\n          if (this._list.length < 1) return null;\n          packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n\n          if (this.settings.protocolVersion === 5) {\n            if (this._list.length >= 2) {\n              packet.reasonCode = this._list.readUInt8(this._pos++);\n            } else {\n              packet.reasonCode = 0;\n            }\n          } else {\n            if (this._list.length < 2) return null;\n            packet.returnCode = this._list.readUInt8(this._pos++);\n          }\n\n          if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code')); // mqtt 5 properties\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          debug('_parseConnack: complete');\n        }\n\n        _parsePublish() {\n          debug('_parsePublish');\n          const packet = this.packet;\n          packet.topic = this._parseString();\n          if (packet.topic === null) return this._emitError(new Error('Cannot parse topic')); // Parse messageId\n\n          if (packet.qos > 0) if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          packet.payload = this._list.slice(this._pos, packet.length);\n          debug('_parsePublish: payload from buffer list: %o', packet.payload);\n        }\n\n        _parseSubscribe() {\n          debug('_parseSubscribe');\n          const packet = this.packet;\n          let topic;\n          let options;\n          let qos;\n          let rh;\n          let rap;\n          let nl;\n          let subscription;\n\n          if (packet.qos !== 1) {\n            return this._emitError(new Error('Wrong subscribe header'));\n          }\n\n          packet.subscriptions = [];\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          while (this._pos < packet.length) {\n            // Parse topic\n            topic = this._parseString();\n            if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n            if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'));\n            options = this._parseByte();\n            qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n            nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n            rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n            rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n            subscription = {\n              topic,\n              qos\n            }; // mqtt 5 options\n\n            if (this.settings.protocolVersion === 5) {\n              subscription.nl = nl;\n              subscription.rap = rap;\n              subscription.rh = rh;\n            } else if (this.settings.bridgeMode) {\n              subscription.rh = 0;\n              subscription.rap = true;\n              subscription.nl = true;\n            } // Push pair to subscriptions\n\n\n            debug('_parseSubscribe: push subscription `%s` to subscription', subscription);\n            packet.subscriptions.push(subscription);\n          }\n        }\n\n        _parseSuback() {\n          debug('_parseSuback');\n          const packet = this.packet;\n          this.packet.granted = [];\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          } // Parse granted QoSes\n\n\n          while (this._pos < this.packet.length) {\n            this.packet.granted.push(this._list.readUInt8(this._pos++));\n          }\n        }\n\n        _parseUnsubscribe() {\n          debug('_parseUnsubscribe');\n          const packet = this.packet;\n          packet.unsubscriptions = []; // Parse messageId\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          while (this._pos < packet.length) {\n            // Parse topic\n            const topic = this._parseString();\n\n            if (topic === null) return this._emitError(new Error('Cannot parse topic')); // Push topic to unsubscriptions\n\n            debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic);\n            packet.unsubscriptions.push(topic);\n          }\n        }\n\n        _parseUnsuback() {\n          debug('_parseUnsuback');\n          const packet = this.packet;\n          if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId')); // Properties mqtt 5\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            } // Parse granted QoSes\n\n\n            packet.granted = [];\n\n            while (this._pos < this.packet.length) {\n              this.packet.granted.push(this._list.readUInt8(this._pos++));\n            }\n          }\n        } // parse packets like puback, pubrec, pubrel, pubcomp\n\n\n        _parseConfirmation() {\n          debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd);\n          const packet = this.packet;\n\n          this._parseMessageId();\n\n          if (this.settings.protocolVersion === 5) {\n            if (packet.length > 2) {\n              // response code\n              packet.reasonCode = this._parseByte();\n              debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode);\n            } else {\n              packet.reasonCode = 0;\n            }\n\n            if (packet.length > 3) {\n              // properies mqtt 5\n              const properties = this._parseProperties();\n\n              if (Object.getOwnPropertyNames(properties).length) {\n                packet.properties = properties;\n              }\n            }\n          }\n\n          return true;\n        } // parse disconnect packet\n\n\n        _parseDisconnect() {\n          const packet = this.packet;\n          debug('_parseDisconnect');\n\n          if (this.settings.protocolVersion === 5) {\n            // response code\n            if (this._list.length > 0) {\n              packet.reasonCode = this._parseByte();\n            } else {\n              packet.reasonCode = 0;\n            } // properies mqtt 5\n\n\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          debug('_parseDisconnect result: true');\n          return true;\n        } // parse auth packet\n\n\n        _parseAuth() {\n          debug('_parseAuth');\n          const packet = this.packet;\n\n          if (this.settings.protocolVersion !== 5) {\n            return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n          } // response code\n\n\n          packet.reasonCode = this._parseByte(); // properies mqtt 5\n\n          const properties = this._parseProperties();\n\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n\n          debug('_parseAuth: result: true');\n          return true;\n        }\n\n        _parseMessageId() {\n          const packet = this.packet;\n          packet.messageId = this._parseNum();\n\n          if (packet.messageId === null) {\n            this._emitError(new Error('Cannot parse messageId'));\n\n            return false;\n          }\n\n          debug('_parseMessageId: packet.messageId %d', packet.messageId);\n          return true;\n        }\n\n        _parseString(maybeBuffer) {\n          const length = this._parseNum();\n\n          const end = length + this._pos;\n          if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n          const result = this._list.toString('utf8', this._pos, end);\n\n          this._pos += length;\n          debug('_parseString: result: %s', result);\n          return result;\n        }\n\n        _parseStringPair() {\n          debug('_parseStringPair');\n          return {\n            name: this._parseString(),\n            value: this._parseString()\n          };\n        }\n\n        _parseBuffer() {\n          const length = this._parseNum();\n\n          const end = length + this._pos;\n          if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n          const result = this._list.slice(this._pos, end);\n\n          this._pos += length;\n          debug('_parseBuffer: result: %o', result);\n          return result;\n        }\n\n        _parseNum() {\n          if (this._list.length - this._pos < 2) return -1;\n\n          const result = this._list.readUInt16BE(this._pos);\n\n          this._pos += 2;\n          debug('_parseNum: result: %s', result);\n          return result;\n        }\n\n        _parse4ByteNum() {\n          if (this._list.length - this._pos < 4) return -1;\n\n          const result = this._list.readUInt32BE(this._pos);\n\n          this._pos += 4;\n          debug('_parse4ByteNum: result: %s', result);\n          return result;\n        }\n\n        _parseVarByteNum(fullInfoFlag) {\n          debug('_parseVarByteNum');\n          const maxBytes = 4;\n          let bytes = 0;\n          let mul = 1;\n          let value = 0;\n          let result = false;\n          let current;\n          const padding = this._pos ? this._pos : 0;\n\n          while (bytes < maxBytes && padding + bytes < this._list.length) {\n            current = this._list.readUInt8(padding + bytes++);\n            value += mul * (current & constants.VARBYTEINT_MASK);\n            mul *= 0x80;\n\n            if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n              result = true;\n              break;\n            }\n\n            if (this._list.length <= bytes) {\n              break;\n            }\n          }\n\n          if (!result && bytes === maxBytes && this._list.length >= bytes) {\n            this._emitError(new Error('Invalid variable byte integer'));\n          }\n\n          if (padding) {\n            this._pos += bytes;\n          }\n\n          result = result ? fullInfoFlag ? {\n            bytes,\n            value\n          } : value : false;\n          debug('_parseVarByteNum: result: %o', result);\n          return result;\n        }\n\n        _parseByte() {\n          let result;\n\n          if (this._pos < this._list.length) {\n            result = this._list.readUInt8(this._pos);\n            this._pos++;\n          }\n\n          debug('_parseByte: result: %o', result);\n          return result;\n        }\n\n        _parseByType(type) {\n          debug('_parseByType: type: %s', type);\n\n          switch (type) {\n            case 'byte':\n              {\n                return this._parseByte() !== 0;\n              }\n\n            case 'int8':\n              {\n                return this._parseByte();\n              }\n\n            case 'int16':\n              {\n                return this._parseNum();\n              }\n\n            case 'int32':\n              {\n                return this._parse4ByteNum();\n              }\n\n            case 'var':\n              {\n                return this._parseVarByteNum();\n              }\n\n            case 'string':\n              {\n                return this._parseString();\n              }\n\n            case 'pair':\n              {\n                return this._parseStringPair();\n              }\n\n            case 'binary':\n              {\n                return this._parseBuffer();\n              }\n          }\n        }\n\n        _parseProperties() {\n          debug('_parseProperties');\n\n          const length = this._parseVarByteNum();\n\n          const start = this._pos;\n          const end = start + length;\n          const result = {};\n\n          while (this._pos < end) {\n            const type = this._parseByte();\n\n            if (!type) {\n              this._emitError(new Error('Cannot parse property code type'));\n\n              return false;\n            }\n\n            const name = constants.propertiesCodes[type];\n\n            if (!name) {\n              this._emitError(new Error('Unknown property'));\n\n              return false;\n            } // user properties process\n\n\n            if (name === 'userProperties') {\n              if (!result[name]) {\n                result[name] = Object.create(null);\n              }\n\n              const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n\n              if (result[name][currentUserProperty.name]) {\n                if (Array.isArray(result[name][currentUserProperty.name])) {\n                  result[name][currentUserProperty.name].push(currentUserProperty.value);\n                } else {\n                  const currentValue = result[name][currentUserProperty.name];\n                  result[name][currentUserProperty.name] = [currentValue];\n                  result[name][currentUserProperty.name].push(currentUserProperty.value);\n                }\n              } else {\n                result[name][currentUserProperty.name] = currentUserProperty.value;\n              }\n\n              continue;\n            }\n\n            if (result[name]) {\n              if (Array.isArray(result[name])) {\n                result[name].push(this._parseByType(constants.propertiesTypes[name]));\n              } else {\n                result[name] = [result[name]];\n                result[name].push(this._parseByType(constants.propertiesTypes[name]));\n              }\n            } else {\n              result[name] = this._parseByType(constants.propertiesTypes[name]);\n            }\n          }\n\n          return result;\n        }\n\n        _newPacket() {\n          debug('_newPacket');\n\n          if (this.packet) {\n            this._list.consume(this.packet.length);\n\n            debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length);\n            this.emit('packet', this.packet);\n          }\n\n          debug('_newPacket: new packet');\n          this.packet = new Packet();\n          this._pos = 0;\n          return true;\n        }\n\n        _emitError(err) {\n          debug('_emitError');\n          this.error = err;\n          this.emit('error', err);\n        }\n\n      }\n\n      module.exports = Parser;\n    }, {\n      \"./constants\": 36,\n      \"./packet\": 40,\n      \"bl\": 17,\n      \"debug\": 19,\n      \"events\": 4\n    }],\n    42: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const protocol = require('./constants');\n\n          const empty = Buffer.allocUnsafe(0);\n          const zeroBuf = Buffer.from([0]);\n\n          const numbers = require('./numbers');\n\n          const nextTick = require('process-nextick-args').nextTick;\n\n          const debug = require('debug')('mqtt-packet:writeToStream');\n\n          const numCache = numbers.cache;\n          const generateNumber = numbers.generateNumber;\n          const generateCache = numbers.generateCache;\n          const genBufVariableByteInt = numbers.genBufVariableByteInt;\n          const generate4ByteBuffer = numbers.generate4ByteBuffer;\n          let writeNumber = writeNumberCached;\n          let toGenerate = true;\n\n          function generate(packet, stream, opts) {\n            debug('generate called');\n\n            if (stream.cork) {\n              stream.cork();\n              nextTick(uncork, stream);\n            }\n\n            if (toGenerate) {\n              toGenerate = false;\n              generateCache();\n            }\n\n            debug('generate: packet.cmd: %s', packet.cmd);\n\n            switch (packet.cmd) {\n              case 'connect':\n                return connect(packet, stream, opts);\n\n              case 'connack':\n                return connack(packet, stream, opts);\n\n              case 'publish':\n                return publish(packet, stream, opts);\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubrel':\n              case 'pubcomp':\n                return confirmation(packet, stream, opts);\n\n              case 'subscribe':\n                return subscribe(packet, stream, opts);\n\n              case 'suback':\n                return suback(packet, stream, opts);\n\n              case 'unsubscribe':\n                return unsubscribe(packet, stream, opts);\n\n              case 'unsuback':\n                return unsuback(packet, stream, opts);\n\n              case 'pingreq':\n              case 'pingresp':\n                return emptyPacket(packet, stream, opts);\n\n              case 'disconnect':\n                return disconnect(packet, stream, opts);\n\n              case 'auth':\n                return auth(packet, stream, opts);\n\n              default:\n                stream.emit('error', new Error('Unknown command'));\n                return false;\n            }\n          }\n          /**\n           * Controls numbers cache.\n           * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n           */\n\n\n          Object.defineProperty(generate, 'cacheNumbers', {\n            get() {\n              return writeNumber === writeNumberCached;\n            },\n\n            set(value) {\n              if (value) {\n                if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n                writeNumber = writeNumberCached;\n              } else {\n                toGenerate = false;\n                writeNumber = writeNumberGenerated;\n              }\n            }\n\n          });\n\n          function uncork(stream) {\n            stream.uncork();\n          }\n\n          function connect(packet, stream, opts) {\n            const settings = packet || {};\n            const protocolId = settings.protocolId || 'MQTT';\n            let protocolVersion = settings.protocolVersion || 4;\n            const will = settings.will;\n            let clean = settings.clean;\n            const keepalive = settings.keepalive || 0;\n            const clientId = settings.clientId || '';\n            const username = settings.username;\n            const password = settings.password;\n            /* mqtt5 new oprions */\n\n            const properties = settings.properties;\n            if (clean === undefined) clean = true;\n            let length = 0; // Must be a string and non-falsy\n\n            if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n              stream.emit('error', new Error('Invalid protocolId'));\n              return false;\n            } else length += protocolId.length + 2; // Must be 3 or 4 or 5\n\n\n            if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n              stream.emit('error', new Error('Invalid protocol version'));\n              return false;\n            } else length += 1; // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n\n\n            if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {\n              length += Buffer.byteLength(clientId) + 2;\n            } else {\n              if (protocolVersion < 4) {\n                stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n                return false;\n              }\n\n              if (clean * 1 === 0) {\n                stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n                return false;\n              }\n            } // Must be a two byte number\n\n\n            if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n              stream.emit('error', new Error('Invalid keepalive'));\n              return false;\n            } else length += 2; // Connect flags\n\n\n            length += 1; // Properties\n\n            if (protocolVersion === 5) {\n              var propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // If will exists...\n\n\n            if (will) {\n              // It must be an object\n              if (typeof will !== 'object') {\n                stream.emit('error', new Error('Invalid will'));\n                return false;\n              } // It must have topic typeof string\n\n\n              if (!will.topic || typeof will.topic !== 'string') {\n                stream.emit('error', new Error('Invalid will topic'));\n                return false;\n              } else {\n                length += Buffer.byteLength(will.topic) + 2;\n              } // Payload\n\n\n              length += 2; // payload length\n\n              if (will.payload) {\n                if (will.payload.length >= 0) {\n                  if (typeof will.payload === 'string') {\n                    length += Buffer.byteLength(will.payload);\n                  } else {\n                    length += will.payload.length;\n                  }\n                } else {\n                  stream.emit('error', new Error('Invalid will payload'));\n                  return false;\n                }\n              } // will properties\n\n\n              var willProperties = {};\n\n              if (protocolVersion === 5) {\n                willProperties = getProperties(stream, will.properties);\n\n                if (!willProperties) {\n                  return false;\n                }\n\n                length += willProperties.length;\n              }\n            } // Username\n\n\n            let providedUsername = false;\n\n            if (username != null) {\n              if (isStringOrBuffer(username)) {\n                providedUsername = true;\n                length += Buffer.byteLength(username) + 2;\n              } else {\n                stream.emit('error', new Error('Invalid username'));\n                return false;\n              }\n            } // Password\n\n\n            if (password != null) {\n              if (!providedUsername) {\n                stream.emit('error', new Error('Username is required to use password'));\n                return false;\n              }\n\n              if (isStringOrBuffer(password)) {\n                length += byteLength(password) + 2;\n              } else {\n                stream.emit('error', new Error('Invalid password'));\n                return false;\n              }\n            } // Generate header\n\n\n            stream.write(protocol.CONNECT_HEADER); // Generate length\n\n            writeVarByteInt(stream, length); // Generate protocol ID\n\n            writeStringOrBuffer(stream, protocolId);\n\n            if (settings.bridgeMode) {\n              protocolVersion += 128;\n            }\n\n            stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3); // Connect flags\n\n            let flags = 0;\n            flags |= username != null ? protocol.USERNAME_MASK : 0;\n            flags |= password != null ? protocol.PASSWORD_MASK : 0;\n            flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n            flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n            flags |= will ? protocol.WILL_FLAG_MASK : 0;\n            flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n            stream.write(Buffer.from([flags])); // Keepalive\n\n            writeNumber(stream, keepalive); // Properties\n\n            if (protocolVersion === 5) {\n              propertiesData.write();\n            } // Client ID\n\n\n            writeStringOrBuffer(stream, clientId); // Will\n\n            if (will) {\n              if (protocolVersion === 5) {\n                willProperties.write();\n              }\n\n              writeString(stream, will.topic);\n              writeStringOrBuffer(stream, will.payload);\n            } // Username and password\n\n\n            if (username != null) {\n              writeStringOrBuffer(stream, username);\n            }\n\n            if (password != null) {\n              writeStringOrBuffer(stream, password);\n            } // This is a small packet that happens only once on a stream\n            // We assume the stream is always free to receive more data after this\n\n\n            return true;\n          }\n\n          function connack(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const rc = version === 5 ? settings.reasonCode : settings.returnCode;\n            const properties = settings.properties;\n            let length = 2; // length of rc and sessionHeader\n            // Check return code\n\n            if (typeof rc !== 'number') {\n              stream.emit('error', new Error('Invalid return code'));\n              return false;\n            } // mqtt5 properties\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            }\n\n            stream.write(protocol.CONNACK_HEADER); // length\n\n            writeVarByteInt(stream, length);\n            stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n            stream.write(Buffer.from([rc]));\n\n            if (propertiesData != null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function publish(packet, stream, opts) {\n            debug('publish: packet: %o', packet);\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const qos = settings.qos || 0;\n            const retain = settings.retain ? protocol.RETAIN_MASK : 0;\n            const topic = settings.topic;\n            const payload = settings.payload || empty;\n            const id = settings.messageId;\n            const properties = settings.properties;\n            let length = 0; // Topic must be a non-empty string or Buffer\n\n            if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n              stream.emit('error', new Error('Invalid topic'));\n              return false;\n            } // Get the payload length\n\n            if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length; // Message ID must a number if qos > 0\n\n            if (qos && typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else if (qos) length += 2; // mqtt5 properties\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]); // Remaining length\n\n            writeVarByteInt(stream, length); // Topic\n\n            writeNumber(stream, byteLength(topic));\n            stream.write(topic); // Message ID\n\n            if (qos > 0) writeNumber(stream, id); // Properties\n\n            if (propertiesData != null) {\n              propertiesData.write();\n            } // Payload\n\n\n            debug('publish: payload: %o', payload);\n            return stream.write(payload);\n          }\n          /* Puback, pubrec, pubrel and pubcomp */\n\n\n          function confirmation(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const type = settings.cmd || 'puback';\n            const id = settings.messageId;\n            const dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n            let qos = 0;\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 3 : 2;\n            if (type === 'pubrel') qos = 1; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n              if (typeof properties === 'object') {\n                propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n                if (!propertiesData) {\n                  return false;\n                }\n\n                length += propertiesData.length;\n              }\n            } // Header\n\n\n            stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // reason code in header\n\n            if (version === 5) {\n              stream.write(Buffer.from([reasonCode]));\n            } // properies mqtt 5\n\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function subscribe(packet, stream, opts) {\n            debug('subscribe: packet: ');\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const id = settings.messageId;\n            const subs = settings.subscriptions;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else length += 2; // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Check subscriptions\n\n\n            if (typeof subs === 'object' && subs.length) {\n              for (let i = 0; i < subs.length; i += 1) {\n                const itopic = subs[i].topic;\n                const iqos = subs[i].qos;\n\n                if (typeof itopic !== 'string') {\n                  stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n                  return false;\n                }\n\n                if (typeof iqos !== 'number') {\n                  stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n                  return false;\n                }\n\n                if (version === 5) {\n                  const nl = subs[i].nl || false;\n\n                  if (typeof nl !== 'boolean') {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n                    return false;\n                  }\n\n                  const rap = subs[i].rap || false;\n\n                  if (typeof rap !== 'boolean') {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n                    return false;\n                  }\n\n                  const rh = subs[i].rh || 0;\n\n                  if (typeof rh !== 'number' || rh > 2) {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n                    return false;\n                  }\n                }\n\n                length += Buffer.byteLength(itopic) + 2 + 1;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid subscriptions'));\n              return false;\n            } // Generate header\n\n\n            debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n            stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Generate length\n\n            writeVarByteInt(stream, length); // Generate message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            let result = true; // Generate subs\n\n            for (const sub of subs) {\n              const jtopic = sub.topic;\n              const jqos = sub.qos;\n              const jnl = +sub.nl;\n              const jrap = +sub.rap;\n              const jrh = sub.rh;\n              let joptions; // Write topic string\n\n              writeString(stream, jtopic); // options process\n\n              joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n\n              if (version === 5) {\n                joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n                joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n                joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n              } // Write options\n\n\n              result = stream.write(Buffer.from([joptions]));\n            }\n\n            return result;\n          }\n\n          function suback(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const granted = settings.granted;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else length += 2; // Check granted qos vector\n\n\n            if (typeof granted === 'object' && granted.length) {\n              for (let i = 0; i < granted.length; i += 1) {\n                if (typeof granted[i] !== 'number') {\n                  stream.emit('error', new Error('Invalid qos vector'));\n                  return false;\n                }\n\n                length += 1;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid qos vector'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // header\n\n\n            stream.write(protocol.SUBACK_HEADER); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return stream.write(Buffer.from(granted));\n          }\n\n          function unsubscribe(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const unsubs = settings.unsubscriptions;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else {\n              length += 2;\n            } // Check unsubs\n\n\n            if (typeof unsubs === 'object' && unsubs.length) {\n              for (let i = 0; i < unsubs.length; i += 1) {\n                if (typeof unsubs[i] !== 'string') {\n                  stream.emit('error', new Error('Invalid unsubscriptions'));\n                  return false;\n                }\n\n                length += Buffer.byteLength(unsubs[i]) + 2;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid unsubscriptions'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            } // Unsubs\n\n\n            let result = true;\n\n            for (let j = 0; j < unsubs.length; j++) {\n              result = writeString(stream, unsubs[j]);\n            }\n\n            return result;\n          }\n\n          function unsuback(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const granted = settings.granted;\n            const properties = settings.properties;\n            const type = settings.cmd;\n            const qos = 0;\n            let length = 2; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } // Check granted\n\n\n            if (version === 5) {\n              if (typeof granted === 'object' && granted.length) {\n                for (let i = 0; i < granted.length; i += 1) {\n                  if (typeof granted[i] !== 'number') {\n                    stream.emit('error', new Error('Invalid qos vector'));\n                    return false;\n                  }\n\n                  length += 1;\n                }\n              } else {\n                stream.emit('error', new Error('Invalid qos vector'));\n                return false;\n              }\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            } // payload\n\n\n            if (version === 5) {\n              stream.write(Buffer.from(granted));\n            }\n\n            return true;\n          }\n\n          function emptyPacket(packet, stream, opts) {\n            return stream.write(protocol.EMPTY[packet.cmd]);\n          }\n\n          function disconnect(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 1 : 0; // properies mqtt 5\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(Buffer.from([protocol.codes.disconnect << 4])); // Length\n\n            writeVarByteInt(stream, length); // reason code in header\n\n            if (version === 5) {\n              stream.write(Buffer.from([reasonCode]));\n            } // properies mqtt 5\n\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function auth(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 1 : 0;\n            if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet')); // properies mqtt 5\n\n            const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n            if (!propertiesData) {\n              return false;\n            }\n\n            length += propertiesData.length; // Header\n\n            stream.write(Buffer.from([protocol.codes.auth << 4])); // Length\n\n            writeVarByteInt(stream, length); // reason code in header\n\n            stream.write(Buffer.from([reasonCode])); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n          /**\n           * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <Number> length - length (>0)\n           * @returns <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          const varByteIntCache = {};\n\n          function writeVarByteInt(stream, num) {\n            if (num > protocol.VARBYTEINT_MAX) {\n              stream.emit('error', new Error(`Invalid variable byte integer: ${num}`));\n              return false;\n            }\n\n            let buffer = varByteIntCache[num];\n\n            if (!buffer) {\n              buffer = genBufVariableByteInt(num);\n              if (num < 16384) varByteIntCache[num] = buffer;\n            }\n\n            debug('writeVarByteInt: writing to stream: %o', buffer);\n            return stream.write(buffer);\n          }\n          /**\n           * writeString - write a utf8 string to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> string - string to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeString(stream, string) {\n            const strlen = Buffer.byteLength(string);\n            writeNumber(stream, strlen);\n            debug('writeString: %s', string);\n            return stream.write(string, 'utf8');\n          }\n          /**\n           * writeStringPair - write a utf8 string pairs to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <String> name - string name to write\n           * @param <String> value - string value to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeStringPair(stream, name, value) {\n            writeString(stream, name);\n            writeString(stream, value);\n          }\n          /**\n           * writeNumber - write a two byte number to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> number - number to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeNumberCached(stream, number) {\n            debug('writeNumberCached: number: %d', number);\n            debug('writeNumberCached: %o', numCache[number]);\n            return stream.write(numCache[number]);\n          }\n\n          function writeNumberGenerated(stream, number) {\n            const generatedNumber = generateNumber(number);\n            debug('writeNumberGenerated: %o', generatedNumber);\n            return stream.write(generatedNumber);\n          }\n\n          function write4ByteNumber(stream, number) {\n            const generated4ByteBuffer = generate4ByteBuffer(number);\n            debug('write4ByteNumber: %o', generated4ByteBuffer);\n            return stream.write(generated4ByteBuffer);\n          }\n          /**\n           * writeStringOrBuffer - write a String or Buffer with the its length prefix\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> toWrite - String or Buffer\n           * @return <Number> number of bytes written\n           */\n\n\n          function writeStringOrBuffer(stream, toWrite) {\n            if (typeof toWrite === 'string') {\n              writeString(stream, toWrite);\n            } else if (toWrite) {\n              writeNumber(stream, toWrite.length);\n              stream.write(toWrite);\n            } else writeNumber(stream, 0);\n          }\n\n          function getProperties(stream, properties) {\n            /* connect properties */\n            if (typeof properties !== 'object' || properties.length != null) {\n              return {\n                length: 1,\n\n                write() {\n                  writeProperties(stream, {}, 0);\n                }\n\n              };\n            }\n\n            let propertiesLength = 0;\n\n            function getLengthProperty(name, value) {\n              const type = protocol.propertiesTypes[name];\n              let length = 0;\n\n              switch (type) {\n                case 'byte':\n                  {\n                    if (typeof value !== 'boolean') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 1;\n                    break;\n                  }\n\n                case 'int8':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 1;\n                    break;\n                  }\n\n                case 'binary':\n                  {\n                    if (value && value === null) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + Buffer.byteLength(value) + 2;\n                    break;\n                  }\n\n                case 'int16':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 2;\n                    break;\n                  }\n\n                case 'int32':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 4;\n                    break;\n                  }\n\n                case 'var':\n                  {\n                    // var byte integer is max 24 bits packed in 32 bits\n                    if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n                    break;\n                  }\n\n                case 'string':\n                  {\n                    if (typeof value !== 'string') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 2 + Buffer.byteLength(value.toString());\n                    break;\n                  }\n\n                case 'pair':\n                  {\n                    if (typeof value !== 'object') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n                      const currentValue = value[name];\n\n                      if (Array.isArray(currentValue)) {\n                        result += currentValue.reduce((currentLength, value) => {\n                          currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                          return currentLength;\n                        }, 0);\n                      } else {\n                        result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n                      }\n\n                      return result;\n                    }, 0);\n                    break;\n                  }\n\n                default:\n                  {\n                    stream.emit('error', new Error(`Invalid property ${name}: ${value}`));\n                    return false;\n                  }\n              }\n\n              return length;\n            }\n\n            if (properties) {\n              for (const propName in properties) {\n                let propLength = 0;\n                let propValueLength = 0;\n                const propValue = properties[propName];\n\n                if (Array.isArray(propValue)) {\n                  for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n                    propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n\n                    if (!propValueLength) {\n                      return false;\n                    }\n\n                    propLength += propValueLength;\n                  }\n                } else {\n                  propValueLength = getLengthProperty(propName, propValue);\n\n                  if (!propValueLength) {\n                    return false;\n                  }\n\n                  propLength = propValueLength;\n                }\n\n                if (!propLength) return false;\n                propertiesLength += propLength;\n              }\n            }\n\n            const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n            return {\n              length: propertiesLengthLength + propertiesLength,\n\n              write() {\n                writeProperties(stream, properties, propertiesLength);\n              }\n\n            };\n          }\n\n          function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n            const mayEmptyProps = ['reasonString', 'userProperties'];\n            const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n            let propertiesData = getProperties(stream, properties);\n\n            if (maximumPacketSize) {\n              while (length + propertiesData.length > maximumPacketSize) {\n                const currentMayEmptyProp = mayEmptyProps.shift();\n\n                if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n                  delete properties[currentMayEmptyProp];\n                  propertiesData = getProperties(stream, properties);\n                } else {\n                  return false;\n                }\n              }\n            }\n\n            return propertiesData;\n          }\n\n          function writeProperty(stream, propName, value) {\n            const type = protocol.propertiesTypes[propName];\n\n            switch (type) {\n              case 'byte':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([+value]));\n                  break;\n                }\n\n              case 'int8':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([value]));\n                  break;\n                }\n\n              case 'binary':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeStringOrBuffer(stream, value);\n                  break;\n                }\n\n              case 'int16':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeNumber(stream, value);\n                  break;\n                }\n\n              case 'int32':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  write4ByteNumber(stream, value);\n                  break;\n                }\n\n              case 'var':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeVarByteInt(stream, value);\n                  break;\n                }\n\n              case 'string':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeString(stream, value);\n                  break;\n                }\n\n              case 'pair':\n                {\n                  Object.getOwnPropertyNames(value).forEach(name => {\n                    const currentValue = value[name];\n\n                    if (Array.isArray(currentValue)) {\n                      currentValue.forEach(value => {\n                        stream.write(Buffer.from([protocol.properties[propName]]));\n                        writeStringPair(stream, name.toString(), value.toString());\n                      });\n                    } else {\n                      stream.write(Buffer.from([protocol.properties[propName]]));\n                      writeStringPair(stream, name.toString(), currentValue.toString());\n                    }\n                  });\n                  break;\n                }\n\n              default:\n                {\n                  stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`));\n                  return false;\n                }\n            }\n          }\n\n          function writeProperties(stream, properties, propertiesLength) {\n            /* write properties to stream */\n            writeVarByteInt(stream, propertiesLength);\n\n            for (const propName in properties) {\n              if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n                const value = properties[propName];\n\n                if (Array.isArray(value)) {\n                  for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n                    writeProperty(stream, propName, value[valueIndex]);\n                  }\n                } else {\n                  writeProperty(stream, propName, value);\n                }\n              }\n            }\n          }\n\n          function byteLength(bufOrString) {\n            if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n          }\n\n          function isStringOrBuffer(field) {\n            return typeof field === 'string' || field instanceof Buffer;\n          }\n\n          module.exports = generate;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"./constants\": 36,\n      \"./numbers\": 39,\n      \"buffer\": 3,\n      \"debug\": 19,\n      \"process-nextick-args\": 45\n    }],\n    43: [function (require, module, exports) {\n      /**\n       * Helpers.\n       */\n      var s = 1000;\n      var m = s * 60;\n      var h = m * 60;\n      var d = h * 24;\n      var w = d * 7;\n      var y = d * 365.25;\n      /**\n       * Parse or format the given `val`.\n       *\n       * Options:\n       *\n       *  - `long` verbose formatting [false]\n       *\n       * @param {String|Number} val\n       * @param {Object} [options]\n       * @throws {Error} throw an error if val is not a non-empty string or a number\n       * @return {String|Number}\n       * @api public\n       */\n\n      module.exports = function (val, options) {\n        options = options || {};\n        var type = typeof val;\n\n        if (type === 'string' && val.length > 0) {\n          return parse(val);\n        } else if (type === 'number' && isFinite(val)) {\n          return options.long ? fmtLong(val) : fmtShort(val);\n        }\n\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n      };\n      /**\n       * Parse the given `str` and return milliseconds.\n       *\n       * @param {String} str\n       * @return {Number}\n       * @api private\n       */\n\n\n      function parse(str) {\n        str = String(str);\n\n        if (str.length > 100) {\n          return;\n        }\n\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n        if (!match) {\n          return;\n        }\n\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n\n        switch (type) {\n          case 'years':\n          case 'year':\n          case 'yrs':\n          case 'yr':\n          case 'y':\n            return n * y;\n\n          case 'weeks':\n          case 'week':\n          case 'w':\n            return n * w;\n\n          case 'days':\n          case 'day':\n          case 'd':\n            return n * d;\n\n          case 'hours':\n          case 'hour':\n          case 'hrs':\n          case 'hr':\n          case 'h':\n            return n * h;\n\n          case 'minutes':\n          case 'minute':\n          case 'mins':\n          case 'min':\n          case 'm':\n            return n * m;\n\n          case 'seconds':\n          case 'second':\n          case 'secs':\n          case 'sec':\n          case 's':\n            return n * s;\n\n          case 'milliseconds':\n          case 'millisecond':\n          case 'msecs':\n          case 'msec':\n          case 'ms':\n            return n;\n\n          default:\n            return undefined;\n        }\n      }\n      /**\n       * Short format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n\n      function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n\n        if (msAbs >= d) {\n          return Math.round(ms / d) + 'd';\n        }\n\n        if (msAbs >= h) {\n          return Math.round(ms / h) + 'h';\n        }\n\n        if (msAbs >= m) {\n          return Math.round(ms / m) + 'm';\n        }\n\n        if (msAbs >= s) {\n          return Math.round(ms / s) + 's';\n        }\n\n        return ms + 'ms';\n      }\n      /**\n       * Long format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n\n      function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n\n        if (msAbs >= d) {\n          return plural(ms, msAbs, d, 'day');\n        }\n\n        if (msAbs >= h) {\n          return plural(ms, msAbs, h, 'hour');\n        }\n\n        if (msAbs >= m) {\n          return plural(ms, msAbs, m, 'minute');\n        }\n\n        if (msAbs >= s) {\n          return plural(ms, msAbs, s, 'second');\n        }\n\n        return ms + ' ms';\n      }\n      /**\n       * Pluralization helper.\n       */\n\n\n      function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n      }\n    }, {}],\n    44: [function (require, module, exports) {\n      var wrappy = require('wrappy');\n\n      module.exports = wrappy(once);\n      module.exports.strict = wrappy(onceStrict);\n      once.proto = once(function () {\n        Object.defineProperty(Function.prototype, 'once', {\n          value: function () {\n            return once(this);\n          },\n          configurable: true\n        });\n        Object.defineProperty(Function.prototype, 'onceStrict', {\n          value: function () {\n            return onceStrict(this);\n          },\n          configurable: true\n        });\n      });\n\n      function once(fn) {\n        var f = function () {\n          if (f.called) return f.value;\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n\n        f.called = false;\n        return f;\n      }\n\n      function onceStrict(fn) {\n        var f = function () {\n          if (f.called) throw new Error(f.onceError);\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n\n        var name = fn.name || 'Function wrapped with `once`';\n        f.onceError = name + \" shouldn't be called more than once\";\n        f.called = false;\n        return f;\n      }\n    }, {\n      \"wrappy\": 66\n    }],\n    45: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n            module.exports = {\n              nextTick: nextTick\n            };\n          } else {\n            module.exports = process;\n          }\n\n          function nextTick(fn, arg1, arg2, arg3) {\n            if (typeof fn !== 'function') {\n              throw new TypeError('\"callback\" argument must be a function');\n            }\n\n            var len = arguments.length;\n            var args, i;\n\n            switch (len) {\n              case 0:\n              case 1:\n                return process.nextTick(fn);\n\n              case 2:\n                return process.nextTick(function afterTickOne() {\n                  fn.call(null, arg1);\n                });\n\n              case 3:\n                return process.nextTick(function afterTickTwo() {\n                  fn.call(null, arg1, arg2);\n                });\n\n              case 4:\n                return process.nextTick(function afterTickThree() {\n                  fn.call(null, arg1, arg2, arg3);\n                });\n\n              default:\n                args = new Array(len - 1);\n                i = 0;\n\n                while (i < args.length) {\n                  args[i++] = arguments[i];\n                }\n\n                return process.nextTick(function afterTick() {\n                  fn.apply(null, args);\n                });\n            }\n          }\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69\n    }],\n    46: [function (require, module, exports) {\n      'use strict';\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      var codes = {};\n\n      function createErrorType(code, message, Base) {\n        if (!Base) {\n          Base = Error;\n        }\n\n        function getMessage(arg1, arg2, arg3) {\n          if (typeof message === 'string') {\n            return message;\n          } else {\n            return message(arg1, arg2, arg3);\n          }\n        }\n\n        var NodeError = /*#__PURE__*/function (_Base) {\n          _inheritsLoose(NodeError, _Base);\n\n          function NodeError(arg1, arg2, arg3) {\n            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n          }\n\n          return NodeError;\n        }(Base);\n\n        NodeError.prototype.name = Base.name;\n        NodeError.prototype.code = code;\n        codes[code] = NodeError;\n      } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\n      function oneOf(expected, thing) {\n        if (Array.isArray(expected)) {\n          var len = expected.length;\n          expected = expected.map(function (i) {\n            return String(i);\n          });\n\n          if (len > 2) {\n            return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n          } else if (len === 2) {\n            return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n          } else {\n            return \"of \".concat(thing, \" \").concat(expected[0]);\n          }\n        } else {\n          return \"of \".concat(thing, \" \").concat(String(expected));\n        }\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\n      function startsWith(str, search, pos) {\n        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\n      function endsWith(str, search, this_len) {\n        if (this_len === undefined || this_len > str.length) {\n          this_len = str.length;\n        }\n\n        return str.substring(this_len - search.length, this_len) === search;\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\n      function includes(str, search, start) {\n        if (typeof start !== 'number') {\n          start = 0;\n        }\n\n        if (start + search.length > str.length) {\n          return false;\n        } else {\n          return str.indexOf(search, start) !== -1;\n        }\n      }\n\n      createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n        return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n      }, TypeError);\n      createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        var determiner;\n\n        if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n          determiner = 'must not be';\n          expected = expected.replace(/^not /, '');\n        } else {\n          determiner = 'must be';\n        }\n\n        var msg;\n\n        if (endsWith(name, ' argument')) {\n          // For cases like 'first argument'\n          msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n        } else {\n          var type = includes(name, '.') ? 'property' : 'argument';\n          msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n        }\n\n        msg += \". Received type \".concat(typeof actual);\n        return msg;\n      }, TypeError);\n      createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\n      createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n        return 'The ' + name + ' method is not implemented';\n      });\n      createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\n      createErrorType('ERR_STREAM_DESTROYED', function (name) {\n        return 'Cannot call ' + name + ' after a stream was destroyed';\n      });\n      createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\n      createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\n      createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\n      createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\n      createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n        return 'Unknown encoding: ' + arg;\n      }, TypeError);\n      createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n      module.exports.codes = codes;\n    }, {}],\n    47: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // a duplex stream is just a stream that is both readable and writable.\n          // Since JS doesn't have multiple prototypal inheritance, this class\n          // prototypally inherits from Readable, and then parasitically from\n          // Writable.\n          'use strict';\n          /*<replacement>*/\n\n          var objectKeys = Object.keys || function (obj) {\n            var keys = [];\n\n            for (var key in obj) {\n              keys.push(key);\n            }\n\n            return keys;\n          };\n          /*</replacement>*/\n\n\n          module.exports = Duplex;\n\n          var Readable = require('./_stream_readable');\n\n          var Writable = require('./_stream_writable');\n\n          require('inherits')(Duplex, Readable);\n\n          {\n            // Allow the keys array to be GC'ed.\n            var keys = objectKeys(Writable.prototype);\n\n            for (var v = 0; v < keys.length; v++) {\n              var method = keys[v];\n              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n            }\n          }\n\n          function Duplex(options) {\n            if (!(this instanceof Duplex)) return new Duplex(options);\n            Readable.call(this, options);\n            Writable.call(this, options);\n            this.allowHalfOpen = true;\n\n            if (options) {\n              if (options.readable === false) this.readable = false;\n              if (options.writable === false) this.writable = false;\n\n              if (options.allowHalfOpen === false) {\n                this.allowHalfOpen = false;\n                this.once('end', onend);\n              }\n            }\n          }\n\n          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          }); // the no-half-open enforcer\n\n          function onend() {\n            // If the writable side ended, then we're ok.\n            if (this._writableState.ended) return; // no more data can be written.\n            // But allow more writes to happen in this tick.\n\n            process.nextTick(onEndNT, this);\n          }\n\n          function onEndNT(self) {\n            self.end();\n          }\n\n          Object.defineProperty(Duplex.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed && this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n              this._writableState.destroyed = value;\n            }\n          });\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./_stream_readable\": 49,\n      \"./_stream_writable\": 51,\n      \"_process\": 69,\n      \"inherits\": 34\n    }],\n    48: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n\n      require('inherits')(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, {\n      \"./_stream_transform\": 50,\n      \"inherits\": 34\n    }],\n    49: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          'use strict';\n\n          module.exports = Readable;\n          /*<replacement>*/\n\n          var Duplex;\n          /*</replacement>*/\n\n          Readable.ReadableState = ReadableState;\n          /*<replacement>*/\n\n          var EE = require('events').EventEmitter;\n\n          var EElistenerCount = function EElistenerCount(emitter, type) {\n            return emitter.listeners(type).length;\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n\n          var Buffer = require('buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*<replacement>*/\n\n\n          var debugUtil = require('util');\n\n          var debug;\n\n          if (debugUtil && debugUtil.debuglog) {\n            debug = debugUtil.debuglog('stream');\n          } else {\n            debug = function debug() {};\n          }\n          /*</replacement>*/\n\n\n          var BufferList = require('./internal/streams/buffer_list');\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var _require = require('./internal/streams/state'),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = require('../errors').codes,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\n          var StringDecoder;\n          var createReadableStreamAsyncIterator;\n          var from;\n\n          require('inherits')(Readable, Stream);\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n          function prependListener(emitter, event, fn) {\n            // Sadly this is not cacheable as some libraries bundle their own\n            // event emitter implementation with them.\n            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n            // userland ones.  NEVER DO THIS. This is here only because this code needs\n            // to continue to work with older versions of Node.js that do not include\n            // the prependListener() method. The goal is to eventually remove this hack.\n\n            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n          }\n\n          function ReadableState(options, stream, isDuplex) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n            // make all the buffer merging and length checks go away\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n            // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n            this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n            // linked list can remove elements from the beginning faster than\n            // array.shift()\n\n            this.buffer = new BufferList();\n            this.length = 0;\n            this.pipes = null;\n            this.pipesCount = 0;\n            this.flowing = null;\n            this.ended = false;\n            this.endEmitted = false;\n            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n            // immediately, or on a later tick.  We set this to true at first, because\n            // any actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first read call.\n\n            this.sync = true; // whenever we return null, then we set a flag to say\n            // that we're awaiting a 'readable' event emission.\n\n            this.needReadable = false;\n            this.emittedReadable = false;\n            this.readableListening = false;\n            this.resumeScheduled = false;\n            this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n            this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n            this.readingMore = false;\n            this.decoder = null;\n            this.encoding = null;\n\n            if (options.encoding) {\n              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n              this.decoder = new StringDecoder(options.encoding);\n              this.encoding = options.encoding;\n            }\n          }\n\n          function Readable(options) {\n            Duplex = Duplex || require('./_stream_duplex');\n            if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the ReadableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n            this.readable = true;\n\n            if (options) {\n              if (typeof options.read === 'function') this._read = options.read;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            }\n\n            Stream.call(this);\n          }\n\n          Object.defineProperty(Readable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._readableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n            }\n          });\n          Readable.prototype.destroy = destroyImpl.destroy;\n          Readable.prototype._undestroy = destroyImpl.undestroy;\n\n          Readable.prototype._destroy = function (err, cb) {\n            cb(err);\n          }; // Manually shove something into the read() buffer.\n          // This returns true if the highWaterMark has not been hit yet,\n          // similar to how Writable.write() returns true if you should\n          // write() some more.\n\n\n          Readable.prototype.push = function (chunk, encoding) {\n            var state = this._readableState;\n            var skipChunkCheck;\n\n            if (!state.objectMode) {\n              if (typeof chunk === 'string') {\n                encoding = encoding || state.defaultEncoding;\n\n                if (encoding !== state.encoding) {\n                  chunk = Buffer.from(chunk, encoding);\n                  encoding = '';\n                }\n\n                skipChunkCheck = true;\n              }\n            } else {\n              skipChunkCheck = true;\n            }\n\n            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n          }; // Unshift should *always* be something directly out of read()\n\n\n          Readable.prototype.unshift = function (chunk) {\n            return readableAddChunk(this, chunk, null, true, false);\n          };\n\n          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n            debug('readableAddChunk', chunk);\n            var state = stream._readableState;\n\n            if (chunk === null) {\n              state.reading = false;\n              onEofChunk(stream, state);\n            } else {\n              var er;\n              if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n              if (er) {\n                errorOrDestroy(stream, er);\n              } else if (state.objectMode || chunk && chunk.length > 0) {\n                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                  chunk = _uint8ArrayToBuffer(chunk);\n                }\n\n                if (addToFront) {\n                  if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n                } else if (state.ended) {\n                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n                } else if (state.destroyed) {\n                  return false;\n                } else {\n                  state.reading = false;\n\n                  if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                  } else {\n                    addChunk(stream, state, chunk, false);\n                  }\n                }\n              } else if (!addToFront) {\n                state.reading = false;\n                maybeReadMore(stream, state);\n              }\n            } // We can push more data if we are below the highWaterMark.\n            // Also, if we have no data yet, we can stand some more bytes.\n            // This is to work around cases where hwm=0, such as the repl.\n\n\n            return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n          }\n\n          function addChunk(stream, state, chunk, addToFront) {\n            if (state.flowing && state.length === 0 && !state.sync) {\n              state.awaitDrain = 0;\n              stream.emit('data', chunk);\n            } else {\n              // update the buffer info.\n              state.length += state.objectMode ? 1 : chunk.length;\n              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n              if (state.needReadable) emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n          }\n\n          function chunkInvalid(state, chunk) {\n            var er;\n\n            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n            }\n\n            return er;\n          }\n\n          Readable.prototype.isPaused = function () {\n            return this._readableState.flowing === false;\n          }; // backwards compatibility.\n\n\n          Readable.prototype.setEncoding = function (enc) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            var decoder = new StringDecoder(enc);\n            this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n            this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n            var p = this._readableState.buffer.head;\n            var content = '';\n\n            while (p !== null) {\n              content += decoder.write(p.data);\n              p = p.next;\n            }\n\n            this._readableState.buffer.clear();\n\n            if (content !== '') this._readableState.buffer.push(content);\n            this._readableState.length = content.length;\n            return this;\n          }; // Don't raise the hwm > 1GB\n\n\n          var MAX_HWM = 0x40000000;\n\n          function computeNewHighWaterMark(n) {\n            if (n >= MAX_HWM) {\n              // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n              n = MAX_HWM;\n            } else {\n              // Get the next highest power of 2 to prevent increasing hwm excessively in\n              // tiny amounts\n              n--;\n              n |= n >>> 1;\n              n |= n >>> 2;\n              n |= n >>> 4;\n              n |= n >>> 8;\n              n |= n >>> 16;\n              n++;\n            }\n\n            return n;\n          } // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function howMuchToRead(n, state) {\n            if (n <= 0 || state.length === 0 && state.ended) return 0;\n            if (state.objectMode) return 1;\n\n            if (n !== n) {\n              // Only flow one buffer at a time\n              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n            } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n            if (n <= state.length) return n; // Don't have enough\n\n            if (!state.ended) {\n              state.needReadable = true;\n              return 0;\n            }\n\n            return state.length;\n          } // you can override either this method, or the async _read(n) below.\n\n\n          Readable.prototype.read = function (n) {\n            debug('read', n);\n            n = parseInt(n, 10);\n            var state = this._readableState;\n            var nOrig = n;\n            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n            // already have a bunch of data in the buffer, then just trigger\n            // the 'readable' event and move on.\n\n            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n              debug('read: emitReadable', state.length, state.ended);\n              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n              return null;\n            }\n\n            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n            if (n === 0 && state.ended) {\n              if (state.length === 0) endReadable(this);\n              return null;\n            } // All the actual chunk generation logic needs to be\n            // *below* the call to _read.  The reason is that in certain\n            // synthetic stream cases, such as passthrough streams, _read\n            // may be a completely synchronous operation which may change\n            // the state of the read buffer, providing enough data when\n            // before there was *not* enough.\n            //\n            // So, the steps are:\n            // 1. Figure out what the state of things will be after we do\n            // a read from the buffer.\n            //\n            // 2. If that resulting state will trigger a _read, then call _read.\n            // Note that this may be asynchronous, or synchronous.  Yes, it is\n            // deeply ugly to write APIs this way, but that still doesn't mean\n            // that the Readable class should behave improperly, as streams are\n            // designed to be sync/async agnostic.\n            // Take note if the _read call is sync or async (ie, if the read call\n            // has returned yet), so that we know whether or not it's safe to emit\n            // 'readable' etc.\n            //\n            // 3. Actually pull the requested chunks out of the buffer and return.\n            // if we need a readable event, then we need to do some reading.\n\n\n            var doRead = state.needReadable;\n            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n            if (state.length === 0 || state.length - n < state.highWaterMark) {\n              doRead = true;\n              debug('length less than watermark', doRead);\n            } // however, if we've ended, then there's no point, and if we're already\n            // reading, then it's unnecessary.\n\n\n            if (state.ended || state.reading) {\n              doRead = false;\n              debug('reading or ended', doRead);\n            } else if (doRead) {\n              debug('do read');\n              state.reading = true;\n              state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n              if (state.length === 0) state.needReadable = true; // call internal read method\n\n              this._read(state.highWaterMark);\n\n              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n              // and we need to re-evaluate how much data we can return to the user.\n\n              if (!state.reading) n = howMuchToRead(nOrig, state);\n            }\n\n            var ret;\n            if (n > 0) ret = fromList(n, state);else ret = null;\n\n            if (ret === null) {\n              state.needReadable = state.length <= state.highWaterMark;\n              n = 0;\n            } else {\n              state.length -= n;\n              state.awaitDrain = 0;\n            }\n\n            if (state.length === 0) {\n              // If we have nothing in the buffer, then we want to know\n              // as soon as we *do* get something into the buffer.\n              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n              if (nOrig !== n && state.ended) endReadable(this);\n            }\n\n            if (ret !== null) this.emit('data', ret);\n            return ret;\n          };\n\n          function onEofChunk(stream, state) {\n            debug('onEofChunk');\n            if (state.ended) return;\n\n            if (state.decoder) {\n              var chunk = state.decoder.end();\n\n              if (chunk && chunk.length) {\n                state.buffer.push(chunk);\n                state.length += state.objectMode ? 1 : chunk.length;\n              }\n            }\n\n            state.ended = true;\n\n            if (state.sync) {\n              // if we are sync, wait until next tick to emit the data.\n              // Otherwise we risk emitting data in the flow()\n              // the readable code triggers during a read() call\n              emitReadable(stream);\n            } else {\n              // emit 'readable' now to make sure it gets picked up.\n              state.needReadable = false;\n\n              if (!state.emittedReadable) {\n                state.emittedReadable = true;\n                emitReadable_(stream);\n              }\n            }\n          } // Don't emit readable right away in sync mode, because this can trigger\n          // another read() call => stack overflow.  This way, it might trigger\n          // a nextTick recursion warning, but that's not so bad.\n\n\n          function emitReadable(stream) {\n            var state = stream._readableState;\n            debug('emitReadable', state.needReadable, state.emittedReadable);\n            state.needReadable = false;\n\n            if (!state.emittedReadable) {\n              debug('emitReadable', state.flowing);\n              state.emittedReadable = true;\n              process.nextTick(emitReadable_, stream);\n            }\n          }\n\n          function emitReadable_(stream) {\n            var state = stream._readableState;\n            debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n            if (!state.destroyed && (state.length || state.ended)) {\n              stream.emit('readable');\n              state.emittedReadable = false;\n            } // The stream needs another readable event if\n            // 1. It is not flowing, as the flow mechanism will take\n            //    care of it.\n            // 2. It is not ended.\n            // 3. It is below the highWaterMark, so we can schedule\n            //    another readable later.\n\n\n            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n            flow(stream);\n          } // at this point, the user has presumably seen the 'readable' event,\n          // and called read() to consume some data.  that may have triggered\n          // in turn another _read(n) call, in which case reading = true if\n          // it's in progress.\n          // However, if we're not ended, or reading, and the length < hwm,\n          // then go ahead and try to read some more preemptively.\n\n\n          function maybeReadMore(stream, state) {\n            if (!state.readingMore) {\n              state.readingMore = true;\n              process.nextTick(maybeReadMore_, stream, state);\n            }\n          }\n\n          function maybeReadMore_(stream, state) {\n            // Attempt to read more data if we should.\n            //\n            // The conditions for reading more data are (one of):\n            // - Not enough data buffered (state.length < state.highWaterMark). The loop\n            //   is responsible for filling the buffer with enough data if such data\n            //   is available. If highWaterMark is 0 and we are not in the flowing mode\n            //   we should _not_ attempt to buffer any extra data. We'll get more data\n            //   when the stream consumer calls read() instead.\n            // - No data in the buffer, and the stream is in flowing mode. In this mode\n            //   the loop below is responsible for ensuring read() is called. Failing to\n            //   call read here would abort the flow and there's no other mechanism for\n            //   continuing the flow if the stream consumer has just subscribed to the\n            //   'data' event.\n            //\n            // In addition to the above conditions to keep reading data, the following\n            // conditions prevent the data from being read:\n            // - The stream has ended (state.ended).\n            // - There is already a pending 'read' operation (state.reading). This is a\n            //   case where the the stream has called the implementation defined _read()\n            //   method, but they are processing the call asynchronously and have _not_\n            //   called push() with new data. In this case we skip performing more\n            //   read()s. The execution ends in this method again after the _read() ends\n            //   up calling push() with more data.\n            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n              var len = state.length;\n              debug('maybeReadMore read 0');\n              stream.read(0);\n              if (len === state.length) // didn't get any data, stop spinning.\n                break;\n            }\n\n            state.readingMore = false;\n          } // abstract method.  to be overridden in specific implementation classes.\n          // call cb(er, data) where data is <= n in length.\n          // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n          // arbitrary, and perhaps not very meaningful.\n\n\n          Readable.prototype._read = function (n) {\n            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n          };\n\n          Readable.prototype.pipe = function (dest, pipeOpts) {\n            var src = this;\n            var state = this._readableState;\n\n            switch (state.pipesCount) {\n              case 0:\n                state.pipes = dest;\n                break;\n\n              case 1:\n                state.pipes = [state.pipes, dest];\n                break;\n\n              default:\n                state.pipes.push(dest);\n                break;\n            }\n\n            state.pipesCount += 1;\n            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n            var endFn = doEnd ? onend : unpipe;\n            if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n            dest.on('unpipe', onunpipe);\n\n            function onunpipe(readable, unpipeInfo) {\n              debug('onunpipe');\n\n              if (readable === src) {\n                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                  unpipeInfo.hasUnpiped = true;\n                  cleanup();\n                }\n              }\n            }\n\n            function onend() {\n              debug('onend');\n              dest.end();\n            } // when the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n\n\n            var ondrain = pipeOnDrain(src);\n            dest.on('drain', ondrain);\n            var cleanedUp = false;\n\n            function cleanup() {\n              debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n              dest.removeListener('close', onclose);\n              dest.removeListener('finish', onfinish);\n              dest.removeListener('drain', ondrain);\n              dest.removeListener('error', onerror);\n              dest.removeListener('unpipe', onunpipe);\n              src.removeListener('end', onend);\n              src.removeListener('end', unpipe);\n              src.removeListener('data', ondata);\n              cleanedUp = true; // if the reader is waiting for a drain event from this\n              // specific writer, then it would cause it to never start\n              // flowing again.\n              // So, if this is awaiting a drain, then we just call it now.\n              // If we don't know, then assume that we are waiting for one.\n\n              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n            }\n\n            src.on('data', ondata);\n\n            function ondata(chunk) {\n              debug('ondata');\n              var ret = dest.write(chunk);\n              debug('dest.write', ret);\n\n              if (ret === false) {\n                // If the user unpiped during `dest.write()`, it is possible\n                // to get stuck in a permanently paused state if that write\n                // also returned false.\n                // => Check whether `dest` is still a piping destination.\n                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                  debug('false write response, pause', state.awaitDrain);\n                  state.awaitDrain++;\n                }\n\n                src.pause();\n              }\n            } // if the dest has an error, then stop piping into it.\n            // however, don't suppress the throwing behavior for this.\n\n\n            function onerror(er) {\n              debug('onerror', er);\n              unpipe();\n              dest.removeListener('error', onerror);\n              if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n            } // Make sure our error handler is attached before userland ones.\n\n\n            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n            function onclose() {\n              dest.removeListener('finish', onfinish);\n              unpipe();\n            }\n\n            dest.once('close', onclose);\n\n            function onfinish() {\n              debug('onfinish');\n              dest.removeListener('close', onclose);\n              unpipe();\n            }\n\n            dest.once('finish', onfinish);\n\n            function unpipe() {\n              debug('unpipe');\n              src.unpipe(dest);\n            } // tell the dest that it's being piped to\n\n\n            dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n            if (!state.flowing) {\n              debug('pipe resume');\n              src.resume();\n            }\n\n            return dest;\n          };\n\n          function pipeOnDrain(src) {\n            return function pipeOnDrainFunctionResult() {\n              var state = src._readableState;\n              debug('pipeOnDrain', state.awaitDrain);\n              if (state.awaitDrain) state.awaitDrain--;\n\n              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n                state.flowing = true;\n                flow(src);\n              }\n            };\n          }\n\n          Readable.prototype.unpipe = function (dest) {\n            var state = this._readableState;\n            var unpipeInfo = {\n              hasUnpiped: false\n            }; // if we're not piping anywhere, then do nothing.\n\n            if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n            if (state.pipesCount === 1) {\n              // passed in one, but it's not the right one.\n              if (dest && dest !== state.pipes) return this;\n              if (!dest) dest = state.pipes; // got a match.\n\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n              if (dest) dest.emit('unpipe', this, unpipeInfo);\n              return this;\n            } // slow case. multiple pipe destinations.\n\n\n            if (!dest) {\n              // remove all.\n              var dests = state.pipes;\n              var len = state.pipesCount;\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n\n              for (var i = 0; i < len; i++) {\n                dests[i].emit('unpipe', this, {\n                  hasUnpiped: false\n                });\n              }\n\n              return this;\n            } // try to find the right one.\n\n\n            var index = indexOf(state.pipes, dest);\n            if (index === -1) return this;\n            state.pipes.splice(index, 1);\n            state.pipesCount -= 1;\n            if (state.pipesCount === 1) state.pipes = state.pipes[0];\n            dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }; // set up data events if they are asked for\n          // Ensure readable listeners eventually get something\n\n\n          Readable.prototype.on = function (ev, fn) {\n            var res = Stream.prototype.on.call(this, ev, fn);\n            var state = this._readableState;\n\n            if (ev === 'data') {\n              // update readableListening so that resume() may be a no-op\n              // a few lines down. This is needed to support once('readable').\n              state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n              if (state.flowing !== false) this.resume();\n            } else if (ev === 'readable') {\n              if (!state.endEmitted && !state.readableListening) {\n                state.readableListening = state.needReadable = true;\n                state.flowing = false;\n                state.emittedReadable = false;\n                debug('on readable', state.length, state.reading);\n\n                if (state.length) {\n                  emitReadable(this);\n                } else if (!state.reading) {\n                  process.nextTick(nReadingNextTick, this);\n                }\n              }\n            }\n\n            return res;\n          };\n\n          Readable.prototype.addListener = Readable.prototype.on;\n\n          Readable.prototype.removeListener = function (ev, fn) {\n            var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n            if (ev === 'readable') {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          Readable.prototype.removeAllListeners = function (ev) {\n            var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n            if (ev === 'readable' || ev === undefined) {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          function updateReadableListening(self) {\n            var state = self._readableState;\n            state.readableListening = self.listenerCount('readable') > 0;\n\n            if (state.resumeScheduled && !state.paused) {\n              // flowing needs to be set to true now, otherwise\n              // the upcoming resume will not flow.\n              state.flowing = true; // crude way to check if we should resume\n            } else if (self.listenerCount('data') > 0) {\n              self.resume();\n            }\n          }\n\n          function nReadingNextTick(self) {\n            debug('readable nexttick read 0');\n            self.read(0);\n          } // pause() and resume() are remnants of the legacy readable stream API\n          // If the user uses them, then switch into old mode.\n\n\n          Readable.prototype.resume = function () {\n            var state = this._readableState;\n\n            if (!state.flowing) {\n              debug('resume'); // we flow only if there is no one listening\n              // for readable, but we still have to call\n              // resume()\n\n              state.flowing = !state.readableListening;\n              resume(this, state);\n            }\n\n            state.paused = false;\n            return this;\n          };\n\n          function resume(stream, state) {\n            if (!state.resumeScheduled) {\n              state.resumeScheduled = true;\n              process.nextTick(resume_, stream, state);\n            }\n          }\n\n          function resume_(stream, state) {\n            debug('resume', state.reading);\n\n            if (!state.reading) {\n              stream.read(0);\n            }\n\n            state.resumeScheduled = false;\n            stream.emit('resume');\n            flow(stream);\n            if (state.flowing && !state.reading) stream.read(0);\n          }\n\n          Readable.prototype.pause = function () {\n            debug('call pause flowing=%j', this._readableState.flowing);\n\n            if (this._readableState.flowing !== false) {\n              debug('pause');\n              this._readableState.flowing = false;\n              this.emit('pause');\n            }\n\n            this._readableState.paused = true;\n            return this;\n          };\n\n          function flow(stream) {\n            var state = stream._readableState;\n            debug('flow', state.flowing);\n\n            while (state.flowing && stream.read() !== null) {\n              ;\n            }\n          } // wrap an old-style stream as the async data source.\n          // This is *not* part of the readable stream interface.\n          // It is an ugly unfortunate mess of history.\n\n\n          Readable.prototype.wrap = function (stream) {\n            var _this = this;\n\n            var state = this._readableState;\n            var paused = false;\n            stream.on('end', function () {\n              debug('wrapped end');\n\n              if (state.decoder && !state.ended) {\n                var chunk = state.decoder.end();\n                if (chunk && chunk.length) _this.push(chunk);\n              }\n\n              _this.push(null);\n            });\n            stream.on('data', function (chunk) {\n              debug('wrapped data');\n              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n              var ret = _this.push(chunk);\n\n              if (!ret) {\n                paused = true;\n                stream.pause();\n              }\n            }); // proxy all the other methods.\n            // important when wrapping filters and duplexes.\n\n            for (var i in stream) {\n              if (this[i] === undefined && typeof stream[i] === 'function') {\n                this[i] = function methodWrap(method) {\n                  return function methodWrapReturnFunction() {\n                    return stream[method].apply(stream, arguments);\n                  };\n                }(i);\n              }\n            } // proxy certain important events.\n\n\n            for (var n = 0; n < kProxyEvents.length; n++) {\n              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n            } // when we try to consume some more bytes, simply unpause the\n            // underlying stream.\n\n\n            this._read = function (n) {\n              debug('wrapped _read', n);\n\n              if (paused) {\n                paused = false;\n                stream.resume();\n              }\n            };\n\n            return this;\n          };\n\n          if (typeof Symbol === 'function') {\n            Readable.prototype[Symbol.asyncIterator] = function () {\n              if (createReadableStreamAsyncIterator === undefined) {\n                createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n              }\n\n              return createReadableStreamAsyncIterator(this);\n            };\n          }\n\n          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState && this._readableState.buffer;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableFlowing', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.flowing;\n            },\n            set: function set(state) {\n              if (this._readableState) {\n                this._readableState.flowing = state;\n              }\n            }\n          }); // exposed for testing purposes only.\n\n          Readable._fromList = fromList;\n          Object.defineProperty(Readable.prototype, 'readableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.length;\n            }\n          }); // Pluck off n bytes from an array of buffers.\n          // Length is the combined lengths of all the buffers in the list.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n          function fromList(n, state) {\n            // nothing buffered\n            if (state.length === 0) return null;\n            var ret;\n            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n              // read it all, truncate the list\n              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n              state.buffer.clear();\n            } else {\n              // read part of list\n              ret = state.buffer.consume(n, state.decoder);\n            }\n            return ret;\n          }\n\n          function endReadable(stream) {\n            var state = stream._readableState;\n            debug('endReadable', state.endEmitted);\n\n            if (!state.endEmitted) {\n              state.ended = true;\n              process.nextTick(endReadableNT, state, stream);\n            }\n          }\n\n          function endReadableNT(state, stream) {\n            debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n            if (!state.endEmitted && state.length === 0) {\n              state.endEmitted = true;\n              stream.readable = false;\n              stream.emit('end');\n\n              if (state.autoDestroy) {\n                // In case of duplex streams we need a way to detect\n                // if the writable side is ready for autoDestroy as well\n                var wState = stream._writableState;\n\n                if (!wState || wState.autoDestroy && wState.finished) {\n                  stream.destroy();\n                }\n              }\n            }\n          }\n\n          if (typeof Symbol === 'function') {\n            Readable.from = function (iterable, opts) {\n              if (from === undefined) {\n                from = require('./internal/streams/from');\n              }\n\n              return from(Readable, iterable, opts);\n            };\n          }\n\n          function indexOf(xs, x) {\n            for (var i = 0, l = xs.length; i < l; i++) {\n              if (xs[i] === x) return i;\n            }\n\n            return -1;\n          }\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"./internal/streams/async_iterator\": 52,\n      \"./internal/streams/buffer_list\": 53,\n      \"./internal/streams/destroy\": 54,\n      \"./internal/streams/from\": 56,\n      \"./internal/streams/state\": 58,\n      \"./internal/streams/stream\": 59,\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"string_decoder/\": 64,\n      \"util\": 2\n    }],\n    50: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n      'use strict';\n\n      module.exports = Transform;\n\n      var _require$codes = require('../errors').codes,\n          ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n          ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n          ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n          ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\n      var Duplex = require('./_stream_duplex');\n\n      require('inherits')(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n        var cb = ts.writecb;\n\n        if (cb === null) {\n          return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n        cb(er);\n        var rs = this._readableState;\n        rs.reading = false;\n\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n        Duplex.call(this, options);\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        }; // start out asking for a readable event once data is transformed.\n\n        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        } // When the writable side finishes, then flush out anything remaining.\n\n\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      }; // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n\n\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      }; // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n\n\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && !ts.transforming) {\n          ts.transforming = true;\n\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n        // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n\n        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n        return stream.push(null);\n      }\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"inherits\": 34\n    }],\n    51: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // A bit simpler than readable streams.\n          // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n          // the drain event emission and buffering.\n          'use strict';\n\n          module.exports = Writable;\n          /* <replacement> */\n\n          function WriteReq(chunk, encoding, cb) {\n            this.chunk = chunk;\n            this.encoding = encoding;\n            this.callback = cb;\n            this.next = null;\n          } // It seems a linked list but it is not\n          // there will be only 2 of these for each stream\n\n\n          function CorkedRequest(state) {\n            var _this = this;\n\n            this.next = null;\n            this.entry = null;\n\n            this.finish = function () {\n              onCorkedFinish(_this, state);\n            };\n          }\n          /* </replacement> */\n\n          /*<replacement>*/\n\n\n          var Duplex;\n          /*</replacement>*/\n\n          Writable.WritableState = WritableState;\n          /*<replacement>*/\n\n          var internalUtil = {\n            deprecate: require('util-deprecate')\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n\n          var Buffer = require('buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var _require = require('./internal/streams/state'),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = require('../errors').codes,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n              ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n              ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n              ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n              ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n              ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n\n          require('inherits')(Writable, Stream);\n\n          function nop() {}\n\n          function WritableState(options, stream, isDuplex) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream,\n            // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n            // contains buffers or objects.\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n            // Note: 0 is a valid value, means that we always return false if\n            // the entire buffer is not flushed immediately on write()\n\n            this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n            this.finalCalled = false; // drain event flag.\n\n            this.needDrain = false; // at the start of calling end()\n\n            this.ending = false; // when end() has been called, and returned\n\n            this.ended = false; // when 'finish' is emitted\n\n            this.finished = false; // has it been destroyed\n\n            this.destroyed = false; // should we decode strings into buffers before passing to _write?\n            // this is here so that some node-core streams can optimize string\n            // handling at a lower level.\n\n            var noDecode = options.decodeStrings === false;\n            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n            // of how much we're waiting to get pushed to some underlying\n            // socket or file.\n\n            this.length = 0; // a flag to see when we're in the middle of a write.\n\n            this.writing = false; // when true all writes will be buffered until .uncork() call\n\n            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n            // or on a later tick.  We set this to true at first, because any\n            // actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first write call.\n\n            this.sync = true; // a flag to know if we're processing previously buffered items, which\n            // may call the _write() callback in the same tick, so that we don't\n            // end up in an overlapped onwrite situation.\n\n            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n            this.onwrite = function (er) {\n              onwrite(stream, er);\n            }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n            this.writecb = null; // the amount that is being written when _write is called.\n\n            this.writelen = 0;\n            this.bufferedRequest = null;\n            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n            // this must be 0 before 'finish' can be emitted\n\n            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n            // This is relevant for synchronous Transform streams\n\n            this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n            this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n            this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n            // one allocated and free to use, and we maintain at most two\n\n            this.corkedRequestsFree = new CorkedRequest(this);\n          }\n\n          WritableState.prototype.getBuffer = function getBuffer() {\n            var current = this.bufferedRequest;\n            var out = [];\n\n            while (current) {\n              out.push(current);\n              current = current.next;\n            }\n\n            return out;\n          };\n\n          (function () {\n            try {\n              Object.defineProperty(WritableState.prototype, 'buffer', {\n                get: internalUtil.deprecate(function writableStateBufferGetter() {\n                  return this.getBuffer();\n                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n              });\n            } catch (_) {}\n          })(); // Test _writableState for inheritance to account for Duplex streams,\n          // whose prototype chain only points to Readable.\n\n\n          var realHasInstance;\n\n          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n            realHasInstance = Function.prototype[Symbol.hasInstance];\n            Object.defineProperty(Writable, Symbol.hasInstance, {\n              value: function value(object) {\n                if (realHasInstance.call(this, object)) return true;\n                if (this !== Writable) return false;\n                return object && object._writableState instanceof WritableState;\n              }\n            });\n          } else {\n            realHasInstance = function realHasInstance(object) {\n              return object instanceof this;\n            };\n          }\n\n          function Writable(options) {\n            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n            // `realHasInstance` is necessary because using plain `instanceof`\n            // would return false, as no `_writableState` property is attached.\n            // Trying to use the custom `instanceof` for Writable here will also break the\n            // Node.js LazyTransform implementation, which has a non-trivial getter for\n            // `_writableState` that would lead to infinite recursion.\n            // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the WritableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n            this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n            this.writable = true;\n\n            if (options) {\n              if (typeof options.write === 'function') this._write = options.write;\n              if (typeof options.writev === 'function') this._writev = options.writev;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n              if (typeof options.final === 'function') this._final = options.final;\n            }\n\n            Stream.call(this);\n          } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n          Writable.prototype.pipe = function () {\n            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n          };\n\n          function writeAfterEnd(stream, cb) {\n            var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n            errorOrDestroy(stream, er);\n            process.nextTick(cb, er);\n          } // Checks that a user-supplied chunk is valid, especially for the particular\n          // mode the stream is in. Currently this means that `null` is never accepted\n          // and undefined/non-string values are only allowed in object mode.\n\n\n          function validChunk(stream, state, chunk, cb) {\n            var er;\n\n            if (chunk === null) {\n              er = new ERR_STREAM_NULL_VALUES();\n            } else if (typeof chunk !== 'string' && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n            }\n\n            if (er) {\n              errorOrDestroy(stream, er);\n              process.nextTick(cb, er);\n              return false;\n            }\n\n            return true;\n          }\n\n          Writable.prototype.write = function (chunk, encoding, cb) {\n            var state = this._writableState;\n            var ret = false;\n\n            var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n            if (isBuf && !Buffer.isBuffer(chunk)) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n            if (typeof cb !== 'function') cb = nop;\n            if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n              state.pendingcb++;\n              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n            }\n            return ret;\n          };\n\n          Writable.prototype.cork = function () {\n            this._writableState.corked++;\n          };\n\n          Writable.prototype.uncork = function () {\n            var state = this._writableState;\n\n            if (state.corked) {\n              state.corked--;\n              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n            }\n          };\n\n          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n            // node::ParseEncoding() requires lower case.\n            if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n            this._writableState.defaultEncoding = encoding;\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n\n          function decodeChunk(state, chunk, encoding) {\n            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, encoding);\n            }\n\n            return chunk;\n          }\n\n          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          }); // if we're already writing something, then just put this\n          // in the queue, and wait our turn.  Otherwise, call _write\n          // If we return false, then we need a drain event, so set that flag.\n\n          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n            if (!isBuf) {\n              var newChunk = decodeChunk(state, chunk, encoding);\n\n              if (chunk !== newChunk) {\n                isBuf = true;\n                encoding = 'buffer';\n                chunk = newChunk;\n              }\n            }\n\n            var len = state.objectMode ? 1 : chunk.length;\n            state.length += len;\n            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n            if (!ret) state.needDrain = true;\n\n            if (state.writing || state.corked) {\n              var last = state.lastBufferedRequest;\n              state.lastBufferedRequest = {\n                chunk: chunk,\n                encoding: encoding,\n                isBuf: isBuf,\n                callback: cb,\n                next: null\n              };\n\n              if (last) {\n                last.next = state.lastBufferedRequest;\n              } else {\n                state.bufferedRequest = state.lastBufferedRequest;\n              }\n\n              state.bufferedRequestCount += 1;\n            } else {\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n            }\n\n            return ret;\n          }\n\n          function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n            state.writelen = len;\n            state.writecb = cb;\n            state.writing = true;\n            state.sync = true;\n            if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n            state.sync = false;\n          }\n\n          function onwriteError(stream, state, sync, er, cb) {\n            --state.pendingcb;\n\n            if (sync) {\n              // defer the callback if we are being called synchronously\n              // to avoid piling up things on the stack\n              process.nextTick(cb, er); // this can emit finish, and it will always happen\n              // after error\n\n              process.nextTick(finishMaybe, stream, state);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er);\n            } else {\n              // the caller expect this to happen before if\n              // it is async\n              cb(er);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er); // this can emit finish, but finish must\n              // always follow error\n\n              finishMaybe(stream, state);\n            }\n          }\n\n          function onwriteStateUpdate(state) {\n            state.writing = false;\n            state.writecb = null;\n            state.length -= state.writelen;\n            state.writelen = 0;\n          }\n\n          function onwrite(stream, er) {\n            var state = stream._writableState;\n            var sync = state.sync;\n            var cb = state.writecb;\n            if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n            onwriteStateUpdate(state);\n            if (er) onwriteError(stream, state, sync, er, cb);else {\n              // Check if we're actually ready to finish, but don't emit yet\n              var finished = needFinish(state) || stream.destroyed;\n\n              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n                clearBuffer(stream, state);\n              }\n\n              if (sync) {\n                process.nextTick(afterWrite, stream, state, finished, cb);\n              } else {\n                afterWrite(stream, state, finished, cb);\n              }\n            }\n          }\n\n          function afterWrite(stream, state, finished, cb) {\n            if (!finished) onwriteDrain(stream, state);\n            state.pendingcb--;\n            cb();\n            finishMaybe(stream, state);\n          } // Must force callback to be called on nextTick, so that we don't\n          // emit 'drain' before the write() consumer gets the 'false' return\n          // value, and has a chance to attach a 'drain' listener.\n\n\n          function onwriteDrain(stream, state) {\n            if (state.length === 0 && state.needDrain) {\n              state.needDrain = false;\n              stream.emit('drain');\n            }\n          } // if there's something in the buffer waiting, then process it\n\n\n          function clearBuffer(stream, state) {\n            state.bufferProcessing = true;\n            var entry = state.bufferedRequest;\n\n            if (stream._writev && entry && entry.next) {\n              // Fast case, write everything using _writev()\n              var l = state.bufferedRequestCount;\n              var buffer = new Array(l);\n              var holder = state.corkedRequestsFree;\n              holder.entry = entry;\n              var count = 0;\n              var allBuffers = true;\n\n              while (entry) {\n                buffer[count] = entry;\n                if (!entry.isBuf) allBuffers = false;\n                entry = entry.next;\n                count += 1;\n              }\n\n              buffer.allBuffers = allBuffers;\n              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n              // as the hot path ends with doWrite\n\n              state.pendingcb++;\n              state.lastBufferedRequest = null;\n\n              if (holder.next) {\n                state.corkedRequestsFree = holder.next;\n                holder.next = null;\n              } else {\n                state.corkedRequestsFree = new CorkedRequest(state);\n              }\n\n              state.bufferedRequestCount = 0;\n            } else {\n              // Slow case, write chunks one-by-one\n              while (entry) {\n                var chunk = entry.chunk;\n                var encoding = entry.encoding;\n                var cb = entry.callback;\n                var len = state.objectMode ? 1 : chunk.length;\n                doWrite(stream, state, false, len, chunk, encoding, cb);\n                entry = entry.next;\n                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n                // it means that we need to wait until it does.\n                // also, that means that the chunk and cb are currently\n                // being processed, so move the buffer counter past them.\n\n                if (state.writing) {\n                  break;\n                }\n              }\n\n              if (entry === null) state.lastBufferedRequest = null;\n            }\n\n            state.bufferedRequest = entry;\n            state.bufferProcessing = false;\n          }\n\n          Writable.prototype._write = function (chunk, encoding, cb) {\n            cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n          };\n\n          Writable.prototype._writev = null;\n\n          Writable.prototype.end = function (chunk, encoding, cb) {\n            var state = this._writableState;\n\n            if (typeof chunk === 'function') {\n              cb = chunk;\n              chunk = null;\n              encoding = null;\n            } else if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n            if (state.corked) {\n              state.corked = 1;\n              this.uncork();\n            } // ignore unnecessary end() calls.\n\n\n            if (!state.ending) endWritable(this, state, cb);\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          });\n\n          function needFinish(state) {\n            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n          }\n\n          function callFinal(stream, state) {\n            stream._final(function (err) {\n              state.pendingcb--;\n\n              if (err) {\n                errorOrDestroy(stream, err);\n              }\n\n              state.prefinished = true;\n              stream.emit('prefinish');\n              finishMaybe(stream, state);\n            });\n          }\n\n          function prefinish(stream, state) {\n            if (!state.prefinished && !state.finalCalled) {\n              if (typeof stream._final === 'function' && !state.destroyed) {\n                state.pendingcb++;\n                state.finalCalled = true;\n                process.nextTick(callFinal, stream, state);\n              } else {\n                state.prefinished = true;\n                stream.emit('prefinish');\n              }\n            }\n          }\n\n          function finishMaybe(stream, state) {\n            var need = needFinish(state);\n\n            if (need) {\n              prefinish(stream, state);\n\n              if (state.pendingcb === 0) {\n                state.finished = true;\n                stream.emit('finish');\n\n                if (state.autoDestroy) {\n                  // In case of duplex streams we need a way to detect\n                  // if the readable side is ready for autoDestroy as well\n                  var rState = stream._readableState;\n\n                  if (!rState || rState.autoDestroy && rState.endEmitted) {\n                    stream.destroy();\n                  }\n                }\n              }\n            }\n\n            return need;\n          }\n\n          function endWritable(stream, state, cb) {\n            state.ending = true;\n            finishMaybe(stream, state);\n\n            if (cb) {\n              if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n            }\n\n            state.ended = true;\n            stream.writable = false;\n          }\n\n          function onCorkedFinish(corkReq, state, err) {\n            var entry = corkReq.entry;\n            corkReq.entry = null;\n\n            while (entry) {\n              var cb = entry.callback;\n              state.pendingcb--;\n              cb(err);\n              entry = entry.next;\n            } // reuse the free corkReq.\n\n\n            state.corkedRequestsFree.next = corkReq;\n          }\n\n          Object.defineProperty(Writable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._writableState === undefined) {\n                return false;\n              }\n\n              return this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._writableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._writableState.destroyed = value;\n            }\n          });\n          Writable.prototype.destroy = destroyImpl.destroy;\n          Writable.prototype._undestroy = destroyImpl.undestroy;\n\n          Writable.prototype._destroy = function (err, cb) {\n            cb(err);\n          };\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"./internal/streams/destroy\": 54,\n      \"./internal/streams/state\": 58,\n      \"./internal/streams/stream\": 59,\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"inherits\": 34,\n      \"util-deprecate\": 65\n    }],\n    52: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var _Object$setPrototypeO;\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          var finished = require('./end-of-stream');\n\n          var kLastResolve = Symbol('lastResolve');\n          var kLastReject = Symbol('lastReject');\n          var kError = Symbol('error');\n          var kEnded = Symbol('ended');\n          var kLastPromise = Symbol('lastPromise');\n          var kHandlePromise = Symbol('handlePromise');\n          var kStream = Symbol('stream');\n\n          function createIterResult(value, done) {\n            return {\n              value: value,\n              done: done\n            };\n          }\n\n          function readAndResolve(iter) {\n            var resolve = iter[kLastResolve];\n\n            if (resolve !== null) {\n              var data = iter[kStream].read(); // we defer if data is null\n              // we can be expecting either 'end' or\n              // 'error'\n\n              if (data !== null) {\n                iter[kLastPromise] = null;\n                iter[kLastResolve] = null;\n                iter[kLastReject] = null;\n                resolve(createIterResult(data, false));\n              }\n            }\n          }\n\n          function onReadable(iter) {\n            // we wait for the next tick, because it might\n            // emit an error with process.nextTick\n            process.nextTick(readAndResolve, iter);\n          }\n\n          function wrapForNext(lastPromise, iter) {\n            return function (resolve, reject) {\n              lastPromise.then(function () {\n                if (iter[kEnded]) {\n                  resolve(createIterResult(undefined, true));\n                  return;\n                }\n\n                iter[kHandlePromise](resolve, reject);\n              }, reject);\n            };\n          }\n\n          var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\n          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n            get stream() {\n              return this[kStream];\n            },\n\n            next: function next() {\n              var _this = this; // if we have detected an error in the meanwhile\n              // reject straight away\n\n\n              var error = this[kError];\n\n              if (error !== null) {\n                return Promise.reject(error);\n              }\n\n              if (this[kEnded]) {\n                return Promise.resolve(createIterResult(undefined, true));\n              }\n\n              if (this[kStream].destroyed) {\n                // We need to defer via nextTick because if .destroy(err) is\n                // called, the error will be emitted via nextTick, and\n                // we cannot guarantee that there is no error lingering around\n                // waiting to be emitted.\n                return new Promise(function (resolve, reject) {\n                  process.nextTick(function () {\n                    if (_this[kError]) {\n                      reject(_this[kError]);\n                    } else {\n                      resolve(createIterResult(undefined, true));\n                    }\n                  });\n                });\n              } // if we have multiple next() calls\n              // we will wait for the previous Promise to finish\n              // this logic is optimized to support for await loops,\n              // where next() is only called once at a time\n\n\n              var lastPromise = this[kLastPromise];\n              var promise;\n\n              if (lastPromise) {\n                promise = new Promise(wrapForNext(lastPromise, this));\n              } else {\n                // fast path needed to support multiple this.push()\n                // without triggering the next() queue\n                var data = this[kStream].read();\n\n                if (data !== null) {\n                  return Promise.resolve(createIterResult(data, false));\n                }\n\n                promise = new Promise(this[kHandlePromise]);\n              }\n\n              this[kLastPromise] = promise;\n              return promise;\n            }\n          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n            return this;\n          }), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n            var _this2 = this; // destroy(err, cb) is a private API\n            // we can guarantee we have that here, because we control the\n            // Readable class this is attached to\n\n\n            return new Promise(function (resolve, reject) {\n              _this2[kStream].destroy(null, function (err) {\n                if (err) {\n                  reject(err);\n                  return;\n                }\n\n                resolve(createIterResult(undefined, true));\n              });\n            });\n          }), _Object$setPrototypeO), AsyncIteratorPrototype);\n\n          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n            var _Object$create;\n\n            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n              value: stream,\n              writable: true\n            }), _defineProperty(_Object$create, kLastResolve, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kLastReject, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kError, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kEnded, {\n              value: stream._readableState.endEmitted,\n              writable: true\n            }), _defineProperty(_Object$create, kHandlePromise, {\n              value: function value(resolve, reject) {\n                var data = iterator[kStream].read();\n\n                if (data) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  resolve(createIterResult(data, false));\n                } else {\n                  iterator[kLastResolve] = resolve;\n                  iterator[kLastReject] = reject;\n                }\n              },\n              writable: true\n            }), _Object$create));\n            iterator[kLastPromise] = null;\n            finished(stream, function (err) {\n              if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n                var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n                // returned by next() and store the error\n\n                if (reject !== null) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  reject(err);\n                }\n\n                iterator[kError] = err;\n                return;\n              }\n\n              var resolve = iterator[kLastResolve];\n\n              if (resolve !== null) {\n                iterator[kLastPromise] = null;\n                iterator[kLastResolve] = null;\n                iterator[kLastReject] = null;\n                resolve(createIterResult(undefined, true));\n              }\n\n              iterator[kEnded] = true;\n            });\n            stream.on('readable', onReadable.bind(null, iterator));\n            return iterator;\n          };\n\n          module.exports = createReadableStreamAsyncIterator;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./end-of-stream\": 55,\n      \"_process\": 69\n    }],\n    53: [function (require, module, exports) {\n      'use strict';\n\n      function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n          var symbols = Object.getOwnPropertySymbols(object);\n          if (enumerableOnly) symbols = symbols.filter(function (sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n          keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n      }\n\n      function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n\n          if (i % 2) {\n            ownKeys(Object(source), true).forEach(function (key) {\n              _defineProperty(target, key, source[key]);\n            });\n          } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n          } else {\n            ownKeys(Object(source)).forEach(function (key) {\n              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n          }\n        }\n\n        return target;\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      var _require = require('buffer'),\n          Buffer = _require.Buffer;\n\n      var _require2 = require('util'),\n          inspect = _require2.inspect;\n\n      var custom = inspect && inspect.custom || 'inspect';\n\n      function copyBuffer(src, target, offset) {\n        Buffer.prototype.copy.call(src, target, offset);\n      }\n\n      module.exports = /*#__PURE__*/function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        _createClass(BufferList, [{\n          key: \"push\",\n          value: function push(v) {\n            var entry = {\n              data: v,\n              next: null\n            };\n            if (this.length > 0) this.tail.next = entry;else this.head = entry;\n            this.tail = entry;\n            ++this.length;\n          }\n        }, {\n          key: \"unshift\",\n          value: function unshift(v) {\n            var entry = {\n              data: v,\n              next: this.head\n            };\n            if (this.length === 0) this.tail = entry;\n            this.head = entry;\n            ++this.length;\n          }\n        }, {\n          key: \"shift\",\n          value: function shift() {\n            if (this.length === 0) return;\n            var ret = this.head.data;\n            if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n            --this.length;\n            return ret;\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this.head = this.tail = null;\n            this.length = 0;\n          }\n        }, {\n          key: \"join\",\n          value: function join(s) {\n            if (this.length === 0) return '';\n            var p = this.head;\n            var ret = '' + p.data;\n\n            while (p = p.next) {\n              ret += s + p.data;\n            }\n\n            return ret;\n          }\n        }, {\n          key: \"concat\",\n          value: function concat(n) {\n            if (this.length === 0) return Buffer.alloc(0);\n            var ret = Buffer.allocUnsafe(n >>> 0);\n            var p = this.head;\n            var i = 0;\n\n            while (p) {\n              copyBuffer(p.data, ret, i);\n              i += p.data.length;\n              p = p.next;\n            }\n\n            return ret;\n          } // Consumes a specified amount of bytes or characters from the buffered data.\n\n        }, {\n          key: \"consume\",\n          value: function consume(n, hasStrings) {\n            var ret;\n\n            if (n < this.head.data.length) {\n              // `slice` is the same for buffers and strings.\n              ret = this.head.data.slice(0, n);\n              this.head.data = this.head.data.slice(n);\n            } else if (n === this.head.data.length) {\n              // First chunk is a perfect match.\n              ret = this.shift();\n            } else {\n              // Result spans more than one buffer.\n              ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n            }\n\n            return ret;\n          }\n        }, {\n          key: \"first\",\n          value: function first() {\n            return this.head.data;\n          } // Consumes a specified amount of characters from the buffered data.\n\n        }, {\n          key: \"_getString\",\n          value: function _getString(n) {\n            var p = this.head;\n            var c = 1;\n            var ret = p.data;\n            n -= ret.length;\n\n            while (p = p.next) {\n              var str = p.data;\n              var nb = n > str.length ? str.length : n;\n              if (nb === str.length) ret += str;else ret += str.slice(0, n);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === str.length) {\n                  ++c;\n                  if (p.next) this.head = p.next;else this.head = this.tail = null;\n                } else {\n                  this.head = p;\n                  p.data = str.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            this.length -= c;\n            return ret;\n          } // Consumes a specified amount of bytes from the buffered data.\n\n        }, {\n          key: \"_getBuffer\",\n          value: function _getBuffer(n) {\n            var ret = Buffer.allocUnsafe(n);\n            var p = this.head;\n            var c = 1;\n            p.data.copy(ret);\n            n -= p.data.length;\n\n            while (p = p.next) {\n              var buf = p.data;\n              var nb = n > buf.length ? buf.length : n;\n              buf.copy(ret, ret.length - n, 0, nb);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === buf.length) {\n                  ++c;\n                  if (p.next) this.head = p.next;else this.head = this.tail = null;\n                } else {\n                  this.head = p;\n                  p.data = buf.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            this.length -= c;\n            return ret;\n          } // Make sure the linked list only shows the minimal necessary information.\n\n        }, {\n          key: custom,\n          value: function value(_, options) {\n            return inspect(this, _objectSpread({}, options, {\n              // Only inspect one level.\n              depth: 0,\n              // It should not recurse.\n              customInspect: false\n            }));\n          }\n        }]);\n\n        return BufferList;\n      }();\n    }, {\n      \"buffer\": 3,\n      \"util\": 2\n    }],\n    54: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict'; // undocumented cb() API, needed for core, not for public API\n\n          function destroy(err, cb) {\n            var _this = this;\n\n            var readableDestroyed = this._readableState && this._readableState.destroyed;\n            var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n            if (readableDestroyed || writableDestroyed) {\n              if (cb) {\n                cb(err);\n              } else if (err) {\n                if (!this._writableState) {\n                  process.nextTick(emitErrorNT, this, err);\n                } else if (!this._writableState.errorEmitted) {\n                  this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorNT, this, err);\n                }\n              }\n\n              return this;\n            } // we set destroyed to true before firing error callbacks in order\n            // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n            if (this._readableState) {\n              this._readableState.destroyed = true;\n            } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n            if (this._writableState) {\n              this._writableState.destroyed = true;\n            }\n\n            this._destroy(err || null, function (err) {\n              if (!cb && err) {\n                if (!_this._writableState) {\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else if (!_this._writableState.errorEmitted) {\n                  _this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else {\n                  process.nextTick(emitCloseNT, _this);\n                }\n              } else if (cb) {\n                process.nextTick(emitCloseNT, _this);\n                cb(err);\n              } else {\n                process.nextTick(emitCloseNT, _this);\n              }\n            });\n\n            return this;\n          }\n\n          function emitErrorAndCloseNT(self, err) {\n            emitErrorNT(self, err);\n            emitCloseNT(self);\n          }\n\n          function emitCloseNT(self) {\n            if (self._writableState && !self._writableState.emitClose) return;\n            if (self._readableState && !self._readableState.emitClose) return;\n            self.emit('close');\n          }\n\n          function undestroy() {\n            if (this._readableState) {\n              this._readableState.destroyed = false;\n              this._readableState.reading = false;\n              this._readableState.ended = false;\n              this._readableState.endEmitted = false;\n            }\n\n            if (this._writableState) {\n              this._writableState.destroyed = false;\n              this._writableState.ended = false;\n              this._writableState.ending = false;\n              this._writableState.finalCalled = false;\n              this._writableState.prefinished = false;\n              this._writableState.finished = false;\n              this._writableState.errorEmitted = false;\n            }\n          }\n\n          function emitErrorNT(self, err) {\n            self.emit('error', err);\n          }\n\n          function errorOrDestroy(stream, err) {\n            // We have tests that rely on errors being emitted\n            // in the same tick, so changing this is semver major.\n            // For now when you opt-in to autoDestroy we allow\n            // the error to be emitted nextTick. In a future\n            // semver major update we should change the default to this.\n            var rState = stream._readableState;\n            var wState = stream._writableState;\n            if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n          }\n\n          module.exports = {\n            destroy: destroy,\n            undestroy: undestroy,\n            errorOrDestroy: errorOrDestroy\n          };\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69\n    }],\n    55: [function (require, module, exports) {\n      // Ported from https://github.com/mafintosh/end-of-stream with\n      // permission from the author, Mathias Buus (@mafintosh).\n      'use strict';\n\n      var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\n      function once(callback) {\n        var called = false;\n        return function () {\n          if (called) return;\n          called = true;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          callback.apply(this, args);\n        };\n      }\n\n      function noop() {}\n\n      function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      }\n\n      function eos(stream, opts, callback) {\n        if (typeof opts === 'function') return eos(stream, null, opts);\n        if (!opts) opts = {};\n        callback = once(callback || noop);\n        var readable = opts.readable || opts.readable !== false && stream.readable;\n        var writable = opts.writable || opts.writable !== false && stream.writable;\n\n        var onlegacyfinish = function onlegacyfinish() {\n          if (!stream.writable) onfinish();\n        };\n\n        var writableEnded = stream._writableState && stream._writableState.finished;\n\n        var onfinish = function onfinish() {\n          writable = false;\n          writableEnded = true;\n          if (!readable) callback.call(stream);\n        };\n\n        var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n        var onend = function onend() {\n          readable = false;\n          readableEnded = true;\n          if (!writable) callback.call(stream);\n        };\n\n        var onerror = function onerror(err) {\n          callback.call(stream, err);\n        };\n\n        var onclose = function onclose() {\n          var err;\n\n          if (readable && !readableEnded) {\n            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n          }\n\n          if (writable && !writableEnded) {\n            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n          }\n        };\n\n        var onrequest = function onrequest() {\n          stream.req.on('finish', onfinish);\n        };\n\n        if (isRequest(stream)) {\n          stream.on('complete', onfinish);\n          stream.on('abort', onclose);\n          if (stream.req) onrequest();else stream.on('request', onrequest);\n        } else if (writable && !stream._writableState) {\n          // legacy streams\n          stream.on('end', onlegacyfinish);\n          stream.on('close', onlegacyfinish);\n        }\n\n        stream.on('end', onend);\n        stream.on('finish', onfinish);\n        if (opts.error !== false) stream.on('error', onerror);\n        stream.on('close', onclose);\n        return function () {\n          stream.removeListener('complete', onfinish);\n          stream.removeListener('abort', onclose);\n          stream.removeListener('request', onrequest);\n          if (stream.req) stream.req.removeListener('finish', onfinish);\n          stream.removeListener('end', onlegacyfinish);\n          stream.removeListener('close', onlegacyfinish);\n          stream.removeListener('finish', onfinish);\n          stream.removeListener('end', onend);\n          stream.removeListener('error', onerror);\n          stream.removeListener('close', onclose);\n        };\n      }\n\n      module.exports = eos;\n    }, {\n      \"../../../errors\": 46\n    }],\n    56: [function (require, module, exports) {\n      module.exports = function () {\n        throw new Error('Readable.from is not available in the browser');\n      };\n    }, {}],\n    57: [function (require, module, exports) {\n      // Ported from https://github.com/mafintosh/pump with\n      // permission from the author, Mathias Buus (@mafintosh).\n      'use strict';\n\n      var eos;\n\n      function once(callback) {\n        var called = false;\n        return function () {\n          if (called) return;\n          called = true;\n          callback.apply(void 0, arguments);\n        };\n      }\n\n      var _require$codes = require('../../../errors').codes,\n          ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n          ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\n      function noop(err) {\n        // Rethrow the error if it exists to avoid swallowing it\n        if (err) throw err;\n      }\n\n      function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      }\n\n      function destroyer(stream, reading, writing, callback) {\n        callback = once(callback);\n        var closed = false;\n        stream.on('close', function () {\n          closed = true;\n        });\n        if (eos === undefined) eos = require('./end-of-stream');\n        eos(stream, {\n          readable: reading,\n          writable: writing\n        }, function (err) {\n          if (err) return callback(err);\n          closed = true;\n          callback();\n        });\n        var destroyed = false;\n        return function (err) {\n          if (closed) return;\n          if (destroyed) return;\n          destroyed = true; // request.destroy just do .end - .abort is what we want\n\n          if (isRequest(stream)) return stream.abort();\n          if (typeof stream.destroy === 'function') return stream.destroy();\n          callback(err || new ERR_STREAM_DESTROYED('pipe'));\n        };\n      }\n\n      function call(fn) {\n        fn();\n      }\n\n      function pipe(from, to) {\n        return from.pipe(to);\n      }\n\n      function popCallback(streams) {\n        if (!streams.length) return noop;\n        if (typeof streams[streams.length - 1] !== 'function') return noop;\n        return streams.pop();\n      }\n\n      function pipeline() {\n        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n          streams[_key] = arguments[_key];\n        }\n\n        var callback = popCallback(streams);\n        if (Array.isArray(streams[0])) streams = streams[0];\n\n        if (streams.length < 2) {\n          throw new ERR_MISSING_ARGS('streams');\n        }\n\n        var error;\n        var destroys = streams.map(function (stream, i) {\n          var reading = i < streams.length - 1;\n          var writing = i > 0;\n          return destroyer(stream, reading, writing, function (err) {\n            if (!error) error = err;\n            if (err) destroys.forEach(call);\n            if (reading) return;\n            destroys.forEach(call);\n            callback(error);\n          });\n        });\n        return streams.reduce(pipe);\n      }\n\n      module.exports = pipeline;\n    }, {\n      \"../../../errors\": 46,\n      \"./end-of-stream\": 55\n    }],\n    58: [function (require, module, exports) {\n      'use strict';\n\n      var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\n      function highWaterMarkFrom(options, isDuplex, duplexKey) {\n        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n      }\n\n      function getHighWaterMark(state, options, duplexKey, isDuplex) {\n        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n        if (hwm != null) {\n          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n            var name = isDuplex ? duplexKey : 'highWaterMark';\n            throw new ERR_INVALID_OPT_VALUE(name, hwm);\n          }\n\n          return Math.floor(hwm);\n        } // Default value\n\n\n        return state.objectMode ? 16 : 16 * 1024;\n      }\n\n      module.exports = {\n        getHighWaterMark: getHighWaterMark\n      };\n    }, {\n      \"../../../errors\": 46\n    }],\n    59: [function (require, module, exports) {\n      arguments[4][29][0].apply(exports, arguments);\n    }, {\n      \"dup\": 29,\n      \"events\": 4\n    }],\n    60: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n      exports.finished = require('./lib/internal/streams/end-of-stream.js');\n      exports.pipeline = require('./lib/internal/streams/pipeline.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 47,\n      \"./lib/_stream_passthrough.js\": 48,\n      \"./lib/_stream_readable.js\": 49,\n      \"./lib/_stream_transform.js\": 50,\n      \"./lib/_stream_writable.js\": 51,\n      \"./lib/internal/streams/end-of-stream.js\": 55,\n      \"./lib/internal/streams/pipeline.js\": 57\n    }],\n    61: [function (require, module, exports) {\n      'use strict';\n\n      function ReInterval(callback, interval, args) {\n        var self = this;\n        this._callback = callback;\n        this._args = args;\n        this._interval = setInterval(callback, interval, this._args);\n\n        this.reschedule = function (interval) {\n          // if no interval entered, use the interval passed in on creation\n          if (!interval) interval = self._interval;\n          if (self._interval) clearInterval(self._interval);\n          self._interval = setInterval(self._callback, interval, self._args);\n        };\n\n        this.clear = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n            self._interval = undefined;\n          }\n        };\n\n        this.destroy = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n          }\n\n          self._callback = undefined;\n          self._interval = undefined;\n          self._args = undefined;\n        };\n      }\n\n      function reInterval() {\n        if (typeof arguments[0] !== 'function') throw new Error('callback needed');\n        if (typeof arguments[1] !== 'number') throw new Error('interval needed');\n        var args;\n\n        if (arguments.length > 0) {\n          args = new Array(arguments.length - 2);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 2];\n          }\n        }\n\n        return new ReInterval(arguments[0], arguments[1], args);\n      }\n\n      module.exports = reInterval;\n    }, {}],\n    62: [function (require, module, exports) {\n      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n\n      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      }\n\n      SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer\n\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        var buf = Buffer(size);\n\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return buffer.SlowBuffer(size);\n      };\n    }, {\n      \"buffer\": 3\n    }],\n    63: [function (require, module, exports) {\n      module.exports = shift;\n\n      function shift(stream) {\n        var rs = stream._readableState;\n        if (!rs) return null;\n        return rs.objectMode || typeof stream._duplexState === 'number' ? stream.read() : stream.read(getStateLength(rs));\n      }\n\n      function getStateLength(state) {\n        if (state.buffer.length) {\n          // Since node 6.3.0 state.buffer is a BufferList not an array\n          if (state.buffer.head) {\n            return state.buffer.head.data.length;\n          }\n\n          return state.buffer[0].length;\n        }\n\n        return state.length;\n      }\n    }, {}],\n    64: [function (require, module, exports) {\n      arguments[4][32][0].apply(exports, arguments);\n    }, {\n      \"dup\": 32,\n      \"safe-buffer\": 62\n    }],\n    65: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          /**\n           * Module exports.\n           */\n          module.exports = deprecate;\n          /**\n           * Mark that a method should not be used.\n           * Returns a modified function which warns once by default.\n           *\n           * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n           *\n           * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n           * will throw an Error when invoked.\n           *\n           * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n           * will invoke `console.trace()` instead of `console.error()`.\n           *\n           * @param {Function} fn - the function to deprecate\n           * @param {String} msg - the string to print to the console when `fn` is invoked\n           * @returns {Function} a new \"deprecated\" version of `fn`\n           * @api public\n           */\n\n          function deprecate(fn, msg) {\n            if (config('noDeprecation')) {\n              return fn;\n            }\n\n            var warned = false;\n\n            function deprecated() {\n              if (!warned) {\n                if (config('throwDeprecation')) {\n                  throw new Error(msg);\n                } else if (config('traceDeprecation')) {\n                  console.trace(msg);\n                } else {\n                  console.warn(msg);\n                }\n\n                warned = true;\n              }\n\n              return fn.apply(this, arguments);\n            }\n\n            return deprecated;\n          }\n          /**\n           * Checks `localStorage` for boolean values for the given `name`.\n           *\n           * @param {String} name\n           * @returns {Boolean}\n           * @api private\n           */\n\n\n          function config(name) {\n            // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n            try {\n              if (!global.localStorage) return false;\n            } catch (_) {\n              return false;\n            }\n\n            var val = global.localStorage[name];\n            if (null == val) return false;\n            return String(val).toLowerCase() === 'true';\n          }\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    66: [function (require, module, exports) {\n      // Returns a wrapper function that returns a wrapped callback\n      // The wrapper function should do some stuff, and return a\n      // presumably different callback function.\n      // This makes sure that own properties are retained, so that\n      // decorations and such are not lost along the way.\n      module.exports = wrappy;\n\n      function wrappy(fn, cb) {\n        if (fn && cb) return wrappy(fn)(cb);\n        if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n        Object.keys(fn).forEach(function (k) {\n          wrapper[k] = fn[k];\n        });\n        return wrapper;\n\n        function wrapper() {\n          var args = new Array(arguments.length);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n\n          var ret = fn.apply(this, args);\n          var cb = args[args.length - 1];\n\n          if (typeof ret === 'function' && ret !== cb) {\n            Object.keys(cb).forEach(function (k) {\n              ret[k] = cb[k];\n            });\n          }\n\n          return ret;\n        }\n      }\n    }, {}],\n    67: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        throw new Error('ws does not work in the browser. Browser clients must use the native ' + 'WebSocket object');\n      };\n    }, {}],\n    68: [function (require, module, exports) {\n      module.exports = extend;\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function extend() {\n        var target = {};\n\n        for (var i = 0; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      }\n    }, {}],\n    69: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    70: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          /*! https://mths.be/punycode v1.4.1 by @mathias */\n          ;\n\n          (function (root) {\n            /** Detect free variables */\n            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n            var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n            var freeGlobal = typeof global == 'object' && global;\n\n            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n              root = freeGlobal;\n            }\n            /**\n             * The `punycode` object.\n             * @name punycode\n             * @type Object\n             */\n\n\n            var punycode,\n\n            /** Highest positive signed 32-bit float value */\n            maxInt = 2147483647,\n                // aka. 0x7FFFFFFF or 2^31-1\n\n            /** Bootstring parameters */\n            base = 36,\n                tMin = 1,\n                tMax = 26,\n                skew = 38,\n                damp = 700,\n                initialBias = 72,\n                initialN = 128,\n                // 0x80\n            delimiter = '-',\n                // '\\x2D'\n\n            /** Regular expressions */\n            regexPunycode = /^xn--/,\n                regexNonASCII = /[^\\x20-\\x7E]/,\n                // unprintable ASCII chars + non-ASCII chars\n            regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                // RFC 3490 separators\n\n            /** Error messages */\n            errors = {\n              'overflow': 'Overflow: input needs wider integers to process',\n              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n              'invalid-input': 'Invalid input'\n            },\n\n            /** Convenience shortcuts */\n            baseMinusTMin = base - tMin,\n                floor = Math.floor,\n                stringFromCharCode = String.fromCharCode,\n\n            /** Temporary variable */\n            key;\n            /*--------------------------------------------------------------------------*/\n\n            /**\n             * A generic error utility function.\n             * @private\n             * @param {String} type The error type.\n             * @returns {Error} Throws a `RangeError` with the applicable error message.\n             */\n\n            function error(type) {\n              throw new RangeError(errors[type]);\n            }\n            /**\n             * A generic `Array#map` utility function.\n             * @private\n             * @param {Array} array The array to iterate over.\n             * @param {Function} callback The function that gets called for every array\n             * item.\n             * @returns {Array} A new array of values returned by the callback function.\n             */\n\n\n            function map(array, fn) {\n              var length = array.length;\n              var result = [];\n\n              while (length--) {\n                result[length] = fn(array[length]);\n              }\n\n              return result;\n            }\n            /**\n             * A simple `Array#map`-like wrapper to work with domain name strings or email\n             * addresses.\n             * @private\n             * @param {String} domain The domain name or email address.\n             * @param {Function} callback The function that gets called for every\n             * character.\n             * @returns {Array} A new string of characters returned by the callback\n             * function.\n             */\n\n\n            function mapDomain(string, fn) {\n              var parts = string.split('@');\n              var result = '';\n\n              if (parts.length > 1) {\n                // In email addresses, only the domain name should be punycoded. Leave\n                // the local part (i.e. everything up to `@`) intact.\n                result = parts[0] + '@';\n                string = parts[1];\n              } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n              string = string.replace(regexSeparators, '\\x2E');\n              var labels = string.split('.');\n              var encoded = map(labels, fn).join('.');\n              return result + encoded;\n            }\n            /**\n             * Creates an array containing the numeric code points of each Unicode\n             * character in the string. While JavaScript uses UCS-2 internally,\n             * this function will convert a pair of surrogate halves (each of which\n             * UCS-2 exposes as separate characters) into a single code point,\n             * matching UTF-16.\n             * @see `punycode.ucs2.encode`\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode.ucs2\n             * @name decode\n             * @param {String} string The Unicode input string (UCS-2).\n             * @returns {Array} The new array of code points.\n             */\n\n\n            function ucs2decode(string) {\n              var output = [],\n                  counter = 0,\n                  length = string.length,\n                  value,\n                  extra;\n\n              while (counter < length) {\n                value = string.charCodeAt(counter++);\n\n                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                  // high surrogate, and there is a next character\n                  extra = string.charCodeAt(counter++);\n\n                  if ((extra & 0xFC00) == 0xDC00) {\n                    // low surrogate\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                  } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                  }\n                } else {\n                  output.push(value);\n                }\n              }\n\n              return output;\n            }\n            /**\n             * Creates a string based on an array of numeric code points.\n             * @see `punycode.ucs2.decode`\n             * @memberOf punycode.ucs2\n             * @name encode\n             * @param {Array} codePoints The array of numeric code points.\n             * @returns {String} The new Unicode string (UCS-2).\n             */\n\n\n            function ucs2encode(array) {\n              return map(array, function (value) {\n                var output = '';\n\n                if (value > 0xFFFF) {\n                  value -= 0x10000;\n                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                  value = 0xDC00 | value & 0x3FF;\n                }\n\n                output += stringFromCharCode(value);\n                return output;\n              }).join('');\n            }\n            /**\n             * Converts a basic code point into a digit/integer.\n             * @see `digitToBasic()`\n             * @private\n             * @param {Number} codePoint The basic numeric code point value.\n             * @returns {Number} The numeric value of a basic code point (for use in\n             * representing integers) in the range `0` to `base - 1`, or `base` if\n             * the code point does not represent a value.\n             */\n\n\n            function basicToDigit(codePoint) {\n              if (codePoint - 48 < 10) {\n                return codePoint - 22;\n              }\n\n              if (codePoint - 65 < 26) {\n                return codePoint - 65;\n              }\n\n              if (codePoint - 97 < 26) {\n                return codePoint - 97;\n              }\n\n              return base;\n            }\n            /**\n             * Converts a digit/integer into a basic code point.\n             * @see `basicToDigit()`\n             * @private\n             * @param {Number} digit The numeric value of a basic code point.\n             * @returns {Number} The basic code point whose value (when used for\n             * representing integers) is `digit`, which needs to be in the range\n             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n             * used; else, the lowercase form is used. The behavior is undefined\n             * if `flag` is non-zero and `digit` has no uppercase form.\n             */\n\n\n            function digitToBasic(digit, flag) {\n              //  0..25 map to ASCII a..z or A..Z\n              // 26..35 map to ASCII 0..9\n              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n            }\n            /**\n             * Bias adaptation function as per section 3.4 of RFC 3492.\n             * https://tools.ietf.org/html/rfc3492#section-3.4\n             * @private\n             */\n\n\n            function adapt(delta, numPoints, firstTime) {\n              var k = 0;\n              delta = firstTime ? floor(delta / damp) : delta >> 1;\n              delta += floor(delta / numPoints);\n\n              for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n                delta = floor(delta / baseMinusTMin);\n              }\n\n              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n            }\n            /**\n             * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n             * symbols.\n             * @memberOf punycode\n             * @param {String} input The Punycode string of ASCII-only symbols.\n             * @returns {String} The resulting string of Unicode symbols.\n             */\n\n\n            function decode(input) {\n              // Don't use UCS-2\n              var output = [],\n                  inputLength = input.length,\n                  out,\n                  i = 0,\n                  n = initialN,\n                  bias = initialBias,\n                  basic,\n                  j,\n                  index,\n                  oldi,\n                  w,\n                  k,\n                  digit,\n                  t,\n\n              /** Cached calculation results */\n              baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n              // points before the last delimiter, or `0` if there is none, then copy\n              // the first basic code points to the output.\n\n              basic = input.lastIndexOf(delimiter);\n\n              if (basic < 0) {\n                basic = 0;\n              }\n\n              for (j = 0; j < basic; ++j) {\n                // if it's not a basic code point\n                if (input.charCodeAt(j) >= 0x80) {\n                  error('not-basic');\n                }\n\n                output.push(input.charCodeAt(j));\n              } // Main decoding loop: start just after the last delimiter if any basic code\n              // points were copied; start at the beginning otherwise.\n\n\n              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n                // `index` is the index of the next character to be consumed.\n                // Decode a generalized variable-length integer into `delta`,\n                // which gets added to `i`. The overflow checking is easier\n                // if we increase `i` as we go, then subtract off its starting\n                // value at the end to obtain `delta`.\n                for (oldi = i, w = 1, k = base;; k += base) {\n                  if (index >= inputLength) {\n                    error('invalid-input');\n                  }\n\n                  digit = basicToDigit(input.charCodeAt(index++));\n\n                  if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error('overflow');\n                  }\n\n                  i += digit * w;\n                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                  if (digit < t) {\n                    break;\n                  }\n\n                  baseMinusT = base - t;\n\n                  if (w > floor(maxInt / baseMinusT)) {\n                    error('overflow');\n                  }\n\n                  w *= baseMinusT;\n                }\n\n                out = output.length + 1;\n                bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n                // incrementing `n` each time, so we'll fix that now:\n\n                if (floor(i / out) > maxInt - n) {\n                  error('overflow');\n                }\n\n                n += floor(i / out);\n                i %= out; // Insert `n` at position `i` of the output\n\n                output.splice(i++, 0, n);\n              }\n\n              return ucs2encode(output);\n            }\n            /**\n             * Converts a string of Unicode symbols (e.g. a domain name label) to a\n             * Punycode string of ASCII-only symbols.\n             * @memberOf punycode\n             * @param {String} input The string of Unicode symbols.\n             * @returns {String} The resulting Punycode string of ASCII-only symbols.\n             */\n\n\n            function encode(input) {\n              var n,\n                  delta,\n                  handledCPCount,\n                  basicLength,\n                  bias,\n                  j,\n                  m,\n                  q,\n                  k,\n                  t,\n                  currentValue,\n                  output = [],\n\n              /** `inputLength` will hold the number of code points in `input`. */\n              inputLength,\n\n              /** Cached calculation results */\n              handledCPCountPlusOne,\n                  baseMinusT,\n                  qMinusT; // Convert the input in UCS-2 to Unicode\n\n              input = ucs2decode(input); // Cache the length\n\n              inputLength = input.length; // Initialize the state\n\n              n = initialN;\n              delta = 0;\n              bias = initialBias; // Handle the basic code points\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < 0x80) {\n                  output.push(stringFromCharCode(currentValue));\n                }\n              }\n\n              handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n              // `basicLength` is the number of basic code points.\n              // Finish the basic string - if it is not empty - with a delimiter\n\n              if (basicLength) {\n                output.push(delimiter);\n              } // Main encoding loop:\n\n\n              while (handledCPCount < inputLength) {\n                // All non-basic code points < n have been handled already. Find the next\n                // larger one:\n                for (m = maxInt, j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue >= n && currentValue < m) {\n                    m = currentValue;\n                  }\n                } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                // but guard against overflow\n\n\n                handledCPCountPlusOne = handledCPCount + 1;\n\n                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                  error('overflow');\n                }\n\n                delta += (m - n) * handledCPCountPlusOne;\n                n = m;\n\n                for (j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue < n && ++delta > maxInt) {\n                    error('overflow');\n                  }\n\n                  if (currentValue == n) {\n                    // Represent delta as a generalized variable-length integer\n                    for (q = delta, k = base;; k += base) {\n                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                      if (q < t) {\n                        break;\n                      }\n\n                      qMinusT = q - t;\n                      baseMinusT = base - t;\n                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                      q = floor(qMinusT / baseMinusT);\n                    }\n\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                    delta = 0;\n                    ++handledCPCount;\n                  }\n                }\n\n                ++delta;\n                ++n;\n              }\n\n              return output.join('');\n            }\n            /**\n             * Converts a Punycode string representing a domain name or an email address\n             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n             * it doesn't matter if you call it on a string that has already been\n             * converted to Unicode.\n             * @memberOf punycode\n             * @param {String} input The Punycoded domain name or email address to\n             * convert to Unicode.\n             * @returns {String} The Unicode representation of the given Punycode\n             * string.\n             */\n\n\n            function toUnicode(input) {\n              return mapDomain(input, function (string) {\n                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n              });\n            }\n            /**\n             * Converts a Unicode string representing a domain name or an email address to\n             * Punycode. Only the non-ASCII parts of the domain name will be converted,\n             * i.e. it doesn't matter if you call it with a domain that's already in\n             * ASCII.\n             * @memberOf punycode\n             * @param {String} input The domain name or email address to convert, as a\n             * Unicode string.\n             * @returns {String} The Punycode representation of the given domain name or\n             * email address.\n             */\n\n\n            function toASCII(input) {\n              return mapDomain(input, function (string) {\n                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n              });\n            }\n            /*--------------------------------------------------------------------------*/\n\n            /** Define the public API */\n\n\n            punycode = {\n              /**\n               * A string representing the current Punycode.js version number.\n               * @memberOf punycode\n               * @type String\n               */\n              'version': '1.4.1',\n\n              /**\n               * An object of methods to convert from JavaScript's internal character\n               * representation (UCS-2) to Unicode code points, and back.\n               * @see <https://mathiasbynens.be/notes/javascript-encoding>\n               * @memberOf punycode\n               * @type Object\n               */\n              'ucs2': {\n                'decode': ucs2decode,\n                'encode': ucs2encode\n              },\n              'decode': decode,\n              'encode': encode,\n              'toASCII': toASCII,\n              'toUnicode': toUnicode\n            };\n            /** Expose `punycode` */\n            // Some AMD build optimizers, like r.js, check for specific condition patterns\n            // like the following:\n\n            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n              define('punycode', function () {\n                return punycode;\n              });\n            } else if (freeExports && freeModule) {\n              if (module.exports == freeExports) {\n                // in Node.js, io.js, or RingoJS v0.8.0+\n                freeModule.exports = punycode;\n              } else {\n                // in Narwhal or RingoJS v0.7.0-\n                for (key in punycode) {\n                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n                }\n              }\n            } else {\n              // in Rhino or a web browser\n              root.punycode = punycode;\n            }\n          })(this);\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    71: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict'; // If obj.hasOwnProperty has been overridden, then calling\n      // obj.hasOwnProperty(prop) will break.\n      // See: https://github.com/joyent/node/issues/1707\n\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n\n      module.exports = function (qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n\n        if (typeof qs !== 'string' || qs.length === 0) {\n          return obj;\n        }\n\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n        var maxKeys = 1000;\n\n        if (options && typeof options.maxKeys === 'number') {\n          maxKeys = options.maxKeys;\n        }\n\n        var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n        if (maxKeys > 0 && len > maxKeys) {\n          len = maxKeys;\n        }\n\n        for (var i = 0; i < len; ++i) {\n          var x = qs[i].replace(regexp, '%20'),\n              idx = x.indexOf(eq),\n              kstr,\n              vstr,\n              k,\n              v;\n\n          if (idx >= 0) {\n            kstr = x.substr(0, idx);\n            vstr = x.substr(idx + 1);\n          } else {\n            kstr = x;\n            vstr = '';\n          }\n\n          k = decodeURIComponent(kstr);\n          v = decodeURIComponent(vstr);\n\n          if (!hasOwnProperty(obj, k)) {\n            obj[k] = v;\n          } else if (isArray(obj[k])) {\n            obj[k].push(v);\n          } else {\n            obj[k] = [obj[k], v];\n          }\n        }\n\n        return obj;\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n    }, {}],\n    72: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var stringifyPrimitive = function (v) {\n        switch (typeof v) {\n          case 'string':\n            return v;\n\n          case 'boolean':\n            return v ? 'true' : 'false';\n\n          case 'number':\n            return isFinite(v) ? v : '';\n\n          default:\n            return '';\n        }\n      };\n\n      module.exports = function (obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n\n        if (obj === null) {\n          obj = undefined;\n        }\n\n        if (typeof obj === 'object') {\n          return map(objectKeys(obj), function (k) {\n            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n            if (isArray(obj[k])) {\n              return map(obj[k], function (v) {\n                return ks + encodeURIComponent(stringifyPrimitive(v));\n              }).join(sep);\n            } else {\n              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n            }\n          }).join(sep);\n        }\n\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n      function map(xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n\n        for (var i = 0; i < xs.length; i++) {\n          res.push(f(xs[i], i));\n        }\n\n        return res;\n      }\n\n      var objectKeys = Object.keys || function (obj) {\n        var res = [];\n\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n        }\n\n        return res;\n      };\n    }, {}],\n    73: [function (require, module, exports) {\n      'use strict';\n\n      exports.decode = exports.parse = require('./decode');\n      exports.encode = exports.stringify = require('./encode');\n    }, {\n      \"./decode\": 71,\n      \"./encode\": 72\n    }],\n    74: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        (function () {\n          var nextTick = require('process/browser.js').nextTick;\n\n          var apply = Function.prototype.apply;\n          var slice = Array.prototype.slice;\n          var immediateIds = {};\n          var nextImmediateId = 0; // DOM APIs, for completeness\n\n          exports.setTimeout = function () {\n            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n          };\n\n          exports.setInterval = function () {\n            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n          };\n\n          exports.clearTimeout = exports.clearInterval = function (timeout) {\n            timeout.close();\n          };\n\n          function Timeout(id, clearFn) {\n            this._id = id;\n            this._clearFn = clearFn;\n          }\n\n          Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n          Timeout.prototype.close = function () {\n            this._clearFn.call(window, this._id);\n          }; // Does not start the time, just sets up the members needed.\n\n\n          exports.enroll = function (item, msecs) {\n            clearTimeout(item._idleTimeoutId);\n            item._idleTimeout = msecs;\n          };\n\n          exports.unenroll = function (item) {\n            clearTimeout(item._idleTimeoutId);\n            item._idleTimeout = -1;\n          };\n\n          exports._unrefActive = exports.active = function (item) {\n            clearTimeout(item._idleTimeoutId);\n            var msecs = item._idleTimeout;\n\n            if (msecs >= 0) {\n              item._idleTimeoutId = setTimeout(function onTimeout() {\n                if (item._onTimeout) item._onTimeout();\n              }, msecs);\n            }\n          }; // That's not how node.js implements it but the exposed api is the same.\n\n\n          exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n            var id = nextImmediateId++;\n            var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n            immediateIds[id] = true;\n            nextTick(function onNextTick() {\n              if (immediateIds[id]) {\n                // fn.call() is faster so we optimize for the common use-case\n                // @see http://jsperf.com/call-apply-segu\n                if (args) {\n                  fn.apply(null, args);\n                } else {\n                  fn.call(null);\n                } // Prevent ids from leaking\n\n\n                exports.clearImmediate(id);\n              }\n            });\n            return id;\n          };\n          exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n            delete immediateIds[id];\n          };\n        }).call(this);\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, {\n      \"process/browser.js\": 69,\n      \"timers\": 74\n    }],\n    75: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var punycode = require('punycode');\n\n      var util = require('./util');\n\n      exports.parse = urlParse;\n      exports.resolve = urlResolve;\n      exports.resolveObject = urlResolveObject;\n      exports.format = urlFormat;\n      exports.Url = Url;\n\n      function Url() {\n        this.protocol = null;\n        this.slashes = null;\n        this.auth = null;\n        this.host = null;\n        this.port = null;\n        this.hostname = null;\n        this.hash = null;\n        this.search = null;\n        this.query = null;\n        this.pathname = null;\n        this.path = null;\n        this.href = null;\n      } // Reference: RFC 3986, RFC 1808, RFC 2396\n      // define these here so at least they only have to be\n      // compiled once on the first module load.\n\n\n      var protocolPattern = /^([a-z0-9.+-]+:)/i,\n          portPattern = /:[0-9]*$/,\n          // Special case for a simple path URL\n      simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n          // RFC 2396: characters reserved for delimiting URLs.\n      // We actually just auto-escape these.\n      delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n          // RFC 2396: characters not allowed for various reasons.\n      unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n      autoEscape = ['\\''].concat(unwise),\n          // Characters that are never ever allowed in a hostname.\n      // Note that any invalid chars are also handled, but these\n      // are the ones that are *expected* to be seen, so we fast-path\n      // them.\n      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n          hostEndingChars = ['/', '?', '#'],\n          hostnameMaxLen = 255,\n          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n          // protocols that can allow \"unsafe\" and \"unwise\" chars.\n      unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true\n      },\n          // protocols that never have a hostname.\n      hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true\n      },\n          // protocols that always contain a // bit.\n      slashedProtocol = {\n        'http': true,\n        'https': true,\n        'ftp': true,\n        'gopher': true,\n        'file': true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true\n      },\n          querystring = require('querystring');\n\n      function urlParse(url, parseQueryString, slashesDenoteHost) {\n        if (url && util.isObject(url) && url instanceof Url) return url;\n        var u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n      }\n\n      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n        if (!util.isString(url)) {\n          throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n        } // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n        var queryIndex = url.indexOf('?'),\n            splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n            uSplit = url.split(splitter),\n            slashRegex = /\\\\/g;\n        uSplit[0] = uSplit[0].replace(slashRegex, '/');\n        url = uSplit.join(splitter);\n        var rest = url; // trim before proceeding.\n        // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n        rest = rest.trim();\n\n        if (!slashesDenoteHost && url.split('#').length === 1) {\n          // Try fast path regexp\n          var simplePath = simplePathPattern.exec(rest);\n\n          if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n\n            if (simplePath[2]) {\n              this.search = simplePath[2];\n\n              if (parseQueryString) {\n                this.query = querystring.parse(this.search.substr(1));\n              } else {\n                this.query = this.search.substr(1);\n              }\n            } else if (parseQueryString) {\n              this.search = '';\n              this.query = {};\n            }\n\n            return this;\n          }\n        }\n\n        var proto = protocolPattern.exec(rest);\n\n        if (proto) {\n          proto = proto[0];\n          var lowerProto = proto.toLowerCase();\n          this.protocol = lowerProto;\n          rest = rest.substr(proto.length);\n        } // figure out if it's got a host\n        // user@server is *always* interpreted as a hostname, and url\n        // resolution will treat //foo/bar as host=foo,path=bar because that's\n        // how the browser resolves relative URLs.\n\n\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n          var slashes = rest.substr(0, 2) === '//';\n\n          if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n          }\n        }\n\n        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n          // there's a hostname.\n          // the first instance of /, ?, ;, or # ends the host.\n          //\n          // If there is an @ in the hostname, then non-host chars *are* allowed\n          // to the left of the last @ sign, unless some host-ending character\n          // comes *before* the @-sign.\n          // URLs are obnoxious.\n          //\n          // ex:\n          // http://a@b@c/ => user:a@b host:c\n          // http://a@b?@c => user:a host:c path:/?@c\n          // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n          // Review our test case against browsers more comprehensively.\n          // find the first instance of any hostEndingChars\n          var hostEnd = -1;\n\n          for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          } // at this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n\n\n          var auth, atSign;\n\n          if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n          } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n          } // Now we have a portion which is definitely the auth.\n          // Pull that off.\n\n\n          if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n          } // the host is the remaining to the left of the first non-host char\n\n\n          hostEnd = -1;\n\n          for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          } // if we still have not hit it, then the entire thing is a host.\n\n\n          if (hostEnd === -1) hostEnd = rest.length;\n          this.host = rest.slice(0, hostEnd);\n          rest = rest.slice(hostEnd); // pull out port.\n\n          this.parseHost(); // we've indicated that there is a hostname,\n          // so even if it's empty, it has to be present.\n\n          this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n          // assume that it's an IPv6 address.\n\n          var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n          if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n              var part = hostparts[i];\n              if (!part) continue;\n\n              if (!part.match(hostnamePartPattern)) {\n                var newpart = '';\n\n                for (var j = 0, k = part.length; j < k; j++) {\n                  if (part.charCodeAt(j) > 127) {\n                    // we replace non-ASCII char with a temporary placeholder\n                    // we need this to make sure size of hostname is not\n                    // broken by replacing non-ASCII by nothing\n                    newpart += 'x';\n                  } else {\n                    newpart += part[j];\n                  }\n                } // we test again with ASCII char only\n\n\n                if (!newpart.match(hostnamePartPattern)) {\n                  var validParts = hostparts.slice(0, i);\n                  var notHost = hostparts.slice(i + 1);\n                  var bit = part.match(hostnamePartStart);\n\n                  if (bit) {\n                    validParts.push(bit[1]);\n                    notHost.unshift(bit[2]);\n                  }\n\n                  if (notHost.length) {\n                    rest = '/' + notHost.join('.') + rest;\n                  }\n\n                  this.hostname = validParts.join('.');\n                  break;\n                }\n              }\n            }\n          }\n\n          if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n          } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n          }\n\n          if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n          }\n\n          var p = this.port ? ':' + this.port : '';\n          var h = this.hostname || '';\n          this.host = h + p;\n          this.href += this.host; // strip [ and ] from the hostname\n          // the host field still retains them, though\n\n          if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n            if (rest[0] !== '/') {\n              rest = '/' + rest;\n            }\n          }\n        } // now rest is set to the post-host stuff.\n        // chop off any delim chars.\n\n\n        if (!unsafeProtocol[lowerProto]) {\n          // First, make 100% sure that any \"autoEscape\" chars get\n          // escaped, even if encodeURIComponent doesn't think they\n          // need to be.\n          for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1) continue;\n            var esc = encodeURIComponent(ae);\n\n            if (esc === ae) {\n              esc = escape(ae);\n            }\n\n            rest = rest.split(ae).join(esc);\n          }\n        } // chop off from the tail first.\n\n\n        var hash = rest.indexOf('#');\n\n        if (hash !== -1) {\n          // got a fragment string.\n          this.hash = rest.substr(hash);\n          rest = rest.slice(0, hash);\n        }\n\n        var qm = rest.indexOf('?');\n\n        if (qm !== -1) {\n          this.search = rest.substr(qm);\n          this.query = rest.substr(qm + 1);\n\n          if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n          }\n\n          rest = rest.slice(0, qm);\n        } else if (parseQueryString) {\n          // no query string, but parseQueryString still requested\n          this.search = '';\n          this.query = {};\n        }\n\n        if (rest) this.pathname = rest;\n\n        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n          this.pathname = '/';\n        } //to support http.request\n\n\n        if (this.pathname || this.search) {\n          var p = this.pathname || '';\n          var s = this.search || '';\n          this.path = p + s;\n        } // finally, reconstruct the href based on what has been validated.\n\n\n        this.href = this.format();\n        return this;\n      }; // format a parsed object into a url string\n\n\n      function urlFormat(obj) {\n        // ensure it's an object, and not a string url.\n        // If it's an obj, this is a no-op.\n        // this way, you can call url_format() on strings\n        // to clean up potentially wonky urls.\n        if (util.isString(obj)) obj = urlParse(obj);\n        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n        return obj.format();\n      }\n\n      Url.prototype.format = function () {\n        var auth = this.auth || '';\n\n        if (auth) {\n          auth = encodeURIComponent(auth);\n          auth = auth.replace(/%3A/i, ':');\n          auth += '@';\n        }\n\n        var protocol = this.protocol || '',\n            pathname = this.pathname || '',\n            hash = this.hash || '',\n            host = false,\n            query = '';\n\n        if (this.host) {\n          host = auth + this.host;\n        } else if (this.hostname) {\n          host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n\n          if (this.port) {\n            host += ':' + this.port;\n          }\n        }\n\n        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n          query = querystring.stringify(this.query);\n        }\n\n        var search = this.search || query && '?' + query || '';\n        if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n        // unless they had them to begin with.\n\n        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n          host = '//' + (host || '');\n          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n        } else if (!host) {\n          host = '';\n        }\n\n        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n        if (search && search.charAt(0) !== '?') search = '?' + search;\n        pathname = pathname.replace(/[?#]/g, function (match) {\n          return encodeURIComponent(match);\n        });\n        search = search.replace('#', '%23');\n        return protocol + host + pathname + search + hash;\n      };\n\n      function urlResolve(source, relative) {\n        return urlParse(source, false, true).resolve(relative);\n      }\n\n      Url.prototype.resolve = function (relative) {\n        return this.resolveObject(urlParse(relative, false, true)).format();\n      };\n\n      function urlResolveObject(source, relative) {\n        if (!source) return relative;\n        return urlParse(source, false, true).resolveObject(relative);\n      }\n\n      Url.prototype.resolveObject = function (relative) {\n        if (util.isString(relative)) {\n          var rel = new Url();\n          rel.parse(relative, false, true);\n          relative = rel;\n        }\n\n        var result = new Url();\n        var tkeys = Object.keys(this);\n\n        for (var tk = 0; tk < tkeys.length; tk++) {\n          var tkey = tkeys[tk];\n          result[tkey] = this[tkey];\n        } // hash is always overridden, no matter what.\n        // even href=\"\" will remove it.\n\n\n        result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.\n\n        if (relative.href === '') {\n          result.href = result.format();\n          return result;\n        } // hrefs like //foo/bar always cut to the protocol.\n\n\n        if (relative.slashes && !relative.protocol) {\n          // take everything except the protocol from relative\n          var rkeys = Object.keys(relative);\n\n          for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol') result[rkey] = relative[rkey];\n          } //urlParse appends trailing / to urls like http://www.example.com\n\n\n          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (relative.protocol && relative.protocol !== result.protocol) {\n          // if it's a known url protocol, then changing\n          // the protocol does weird things\n          // first, if it's not file:, then we MUST have a host,\n          // and if there was a path\n          // to begin with, then we MUST have a path.\n          // if it is file:, then the host is dropped,\n          // because that's known to be hostless.\n          // anything else is assumed to be absolute.\n          if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n\n            for (var v = 0; v < keys.length; v++) {\n              var k = keys[v];\n              result[k] = relative[k];\n            }\n\n            result.href = result.format();\n            return result;\n          }\n\n          result.protocol = relative.protocol;\n\n          if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n\n            while (relPath.length && !(relative.host = relPath.shift()));\n\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n          } else {\n            result.pathname = relative.pathname;\n          }\n\n          result.search = relative.search;\n          result.query = relative.query;\n          result.host = relative.host || '';\n          result.auth = relative.auth;\n          result.hostname = relative.hostname || relative.host;\n          result.port = relative.port; // to support http.request\n\n          if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n          }\n\n          result.slashes = result.slashes || relative.slashes;\n          result.href = result.format();\n          return result;\n        }\n\n        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n            isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n            mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n            removeAllDots = mustEndAbs,\n            srcPath = result.pathname && result.pathname.split('/') || [],\n            relPath = relative.pathname && relative.pathname.split('/') || [],\n            psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n        // links like ../.. should be able\n        // to crawl up to the hostname, as well.  This is strange.\n        // result.protocol has already been set by now.\n        // Later on, put the first path part into the host field.\n\n        if (psychotic) {\n          result.hostname = '';\n          result.port = null;\n\n          if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n          }\n\n          result.host = '';\n\n          if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n\n            if (relative.host) {\n              if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n            }\n\n            relative.host = null;\n          }\n\n          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n        }\n\n        if (isRelAbs) {\n          // it's absolute.\n          result.host = relative.host || relative.host === '' ? relative.host : result.host;\n          result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n          result.search = relative.search;\n          result.query = relative.query;\n          srcPath = relPath; // fall through to the dot-handling below.\n        } else if (relPath.length) {\n          // it's relative\n          // throw away the existing file, and take the new path instead.\n          if (!srcPath) srcPath = [];\n          srcPath.pop();\n          srcPath = srcPath.concat(relPath);\n          result.search = relative.search;\n          result.query = relative.query;\n        } else if (!util.isNullOrUndefined(relative.search)) {\n          // just pull out the search.\n          // like href='?foo'.\n          // Put this after the other two cases because it simplifies the booleans\n          if (psychotic) {\n            result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n            if (authInHost) {\n              result.auth = authInHost.shift();\n              result.host = result.hostname = authInHost.shift();\n            }\n          }\n\n          result.search = relative.search;\n          result.query = relative.query; //to support http.request\n\n          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (!srcPath.length) {\n          // no path at all.  easy.\n          // we've already handled the other stuff above.\n          result.pathname = null; //to support http.request\n\n          if (result.search) {\n            result.path = '/' + result.search;\n          } else {\n            result.path = null;\n          }\n\n          result.href = result.format();\n          return result;\n        } // if a url ENDs in . or .., then it must get a trailing slash.\n        // however, if it ends in anything else non-slashy,\n        // then it must NOT get a trailing slash.\n\n\n        var last = srcPath.slice(-1)[0];\n        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir\n        // if the path tries to go above the root, `up` ends up > 0\n\n        var up = 0;\n\n        for (var i = srcPath.length; i >= 0; i--) {\n          last = srcPath[i];\n\n          if (last === '.') {\n            srcPath.splice(i, 1);\n          } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n          } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (!mustEndAbs && !removeAllDots) {\n          for (; up--; up) {\n            srcPath.unshift('..');\n          }\n        }\n\n        if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n          srcPath.unshift('');\n        }\n\n        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n          srcPath.push('');\n        }\n\n        var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back\n\n        if (psychotic) {\n          result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n        if (mustEndAbs && !isAbsolute) {\n          srcPath.unshift('');\n        }\n\n        if (!srcPath.length) {\n          result.pathname = null;\n          result.path = null;\n        } else {\n          result.pathname = srcPath.join('/');\n        } //to support request.http\n\n\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n        }\n\n        result.auth = relative.auth || result.auth;\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      };\n\n      Url.prototype.parseHost = function () {\n        var host = this.host;\n        var port = portPattern.exec(host);\n\n        if (port) {\n          port = port[0];\n\n          if (port !== ':') {\n            this.port = port.substr(1);\n          }\n\n          host = host.substr(0, host.length - port.length);\n        }\n\n        if (host) this.hostname = host;\n      };\n    }, {\n      \"./util\": 76,\n      \"punycode\": 70,\n      \"querystring\": 73\n    }],\n    76: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isString: function (arg) {\n          return typeof arg === 'string';\n        },\n        isObject: function (arg) {\n          return typeof arg === 'object' && arg !== null;\n        },\n        isNull: function (arg) {\n          return arg === null;\n        },\n        isNullOrUndefined: function (arg) {\n          return arg == null;\n        }\n      };\n    }, {}]\n  }, {}, [15])(15);\n});","map":{"version":3,"sources":["E:/SLIIT/Y4/New folder/iVehicle-Web-/node_modules/mqtt-browser/mqtt.js"],"names":["f","exports","module","define","amd","g","window","global","self","mqtt","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","Uint8Array","Array","len","charCodeAt","getLens","b64","validLen","indexOf","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","Buffer","base64","ieee754","SlowBuffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","kMaxLength","TYPED_ARRAY_SUPPORT","typedArraySupport","console","error","__proto__","prototype","foo","Object","defineProperty","enumerable","get","isBuffer","undefined","buffer","byteOffset","createBuffer","RangeError","buf","arg","encodingOrOffset","TypeError","allocUnsafe","from","Symbol","species","value","configurable","writable","poolSize","fromString","ArrayBuffer","isView","fromArrayLike","isInstance","fromArrayBuffer","valueOf","b","fromObject","toPrimitive","assertSize","size","alloc","fill","encoding","checked","allocUnsafeSlow","string","isEncoding","actual","write","slice","array","obj","copy","numberIsNaN","type","isArray","data","toString","_isBuffer","compare","offset","x","y","Math","min","String","toLowerCase","concat","list","pos","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","swap16","swap32","swap64","apply","toLocaleString","equals","inspect","str","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","includes","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","isFinite","toJSON","_arr","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","fromCharCode","ret","out","toHex","bytes","newBuf","subarray","checkOffset","ext","readUIntLE","noAssert","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","checkInt","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","checkIEEE754","writeFloat","littleEndian","writeFloatLE","writeFloatBE","writeDouble","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","INVALID_BASE64_RE","base64clean","split","units","Infinity","leadSurrogate","byteArray","hi","lo","src","dst","constructor","name","R","Reflect","ReflectApply","receiver","args","Function","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","ProcessEmitWarning","warning","warn","NumberIsNaN","isNaN","EventEmitter","init","once","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","getPrototypeOf","create","setMaxListeners","_getMaxListeners","that","getMaxListeners","emit","doError","events","er","err","message","context","handler","listeners","arrayClone","_addListener","prepend","existing","newListener","unshift","warned","w","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","index","pop","Promise","resolve","reject","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","floor","log","LN2","isSlowBuffer","process","Store","mqttPacket","Writable","inherits","reInterval","validations","xtend","debug","nextTick","callback","setTimeout","setImmediate","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","random","sendPacket","client","packet","cb","result","writeToStream","stream","options","flush","queue","forEach","messageId","flushVolatile","volatile","storeAndSend","cbStorePut","cmd","outgoingStore","put","storedPacket","nop","MqttClient","streamBuilder","k","protocol","username","rejectUnauthorized","clientId","customHandleAcks","incomingStore","queueQoSZero","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","nextId","outgoing","_firstConnection","deliver","entry","_sendPacket","clearTimeout","clear","_setupReconnect","_setupStream","connectPacket","parser","completeParse","packets","_clearReconnect","nextTickWork","work","done","_handlePacket","_write","enc","parse","streamErrorHandler","pipe","properties","authenticationMethod","authenticationData","authPacket","reasonCode","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","topic","opts","defaultOpts","qos","retain","dup","payload","_nextId","topicAlias","topicAliasMaximum","_storePacket","subscribe","subs","invalidTopic","version","validateTopics","nl","rap","rh","hasOwnProperty","currentOpts","subscriptions","topics","granted","unsubscribe","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","_shiftPingInterval","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","validReasonCodes","handleMessage","response","pubackRC","pubrecRC","grantedI","comp","pub","id","getLastMessageId","_resubscribe","connack","_resubscribeTopicsKeys","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","storeDeliver","status","allProcessed","Transform","duplexify","my","proxy","isInitialized","buildProxy","chunk","next","sendSocketMessage","success","fail","_flush","socketEnd","closeSocket","setDefaultOpts","hostname","path","wsOptions","buildUrl","url","port","transformWsUrl","bindEventHandler","onSocketOpen","setReadable","setWritable","onSocketMessage","reader","FileReader","readAsArrayBuffer","onSocketClose","onSocketError","buildStream","host","websocketSubProtocol","connectSocket","protocols","net","createConnection","tls","buildBuilder","mqttClient","connection","servername","connect","authorized","handleTLSerrors","WS","WSS_OPTIONS","IS_BROWSER","title","__webpack_require__","prop","setDefaultBrowserOpts","document","URL","objectMode","binary","createWebSocket","socket","createBrowserWebSocket","WebSocket","binaryType","webSocketStream","createWebSocketStream","browserStreamBuilder","bufferSize","browserBufferSize","bufferTimeout","browserBufferTimeout","coerceToBuffer","socketWriteBrowser","socketEndBrowser","_writev","writev","eventListenerSupport","readyState","OPEN","onopen","onclose","onerror","onmessage","socketWrite","objectModeMode","event","chunks","buffers","bufferedAmount","send","socketTask","errMsg","onOpen","onMessage","onClose","onError","wx","_destroy","destroyRef","Readable","streamsOpts","defaultStoreOptions","_inflights","Map","destroyed","values","_read","delete","validateTopic","tcp","ssl","mqtts","wxs","ali","alis","ws","wss","parseAuthOptions","matches","auth","match","password","brokerUrl","query","cert","isSecure","filter","defaultProtocol","wrapper","servers","_reconnectCount","symbol","for","BufferList","_init","_bufs","append","_new","_offset","tot","_t","_reverseOffset","blOffset","bufferId","dstStart","srcStart","srcEnd","bufoff","l","shallowSlice","startOffset","endOffset","consume","trunc","duplicate","_appendBuffer","_isBufferList","appendBuffer","search","blIndex","buffOffset","buff","availableWindow","nativeSearchResult","revOffset","_match","searchOffset","methods","isBufferList","DuplexStream","Duplex","BufferListStream","_callback","piper","onPipe","onUnpipe","assign","objectToString","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","re","isObject","isDate","isError","isFunction","isPrimitive","formatArgs","save","load","useColors","storage","localstorage","colors","__nwjs","navigator","userAgent","documentElement","style","WebkitAppearance","firebug","exception","table","RegExp","$1","namespace","humanize","diff","color","splice","lastC","namespaces","setItem","removeItem","getItem","env","DEBUG","localStorage","formatters","v","JSON","stringify","setup","createDebug","default","coerce","disable","enable","enabled","names","skips","selectColor","hash","prevTime","enableOverride","curr","Date","ms","prev","format","formatter","logFn","extend","delimiter","newDebug","map","toNamespace","test","regexp","substring","stack","eos","SIGNAL_FLUSH","onuncork","fn","_corked","autoDestroy","_autoDestroy","destroyer","_ended","_writableState","finished","toStreams2","rs","highWaterMark","wrap","Duplexify","readable","_writable","_readable","_readable2","_forwardDestroy","_forwardEnd","_ondrain","_drained","_forwarding","_unwrite","_unread","cork","uncork","unend","ondrain","resume","onreadable","_forward","onend","_readableState","_finish","prefinished","ending","pna","objectKeys","util","method","allowHalfOpen","ended","onEndNT","PassThrough","_transform","ReadableState","EE","EElistenerCount","Stream","OurUint8Array","_uint8ArrayToBuffer","_isUint8Array","debugUtil","debuglog","destroyImpl","StringDecoder","kProxyEvents","isDuplex","readableObjectMode","hwm","readableHwm","readableHighWaterMark","defaultHwm","pipes","pipesCount","flowing","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","defaultEncoding","awaitDrain","readingMore","decoder","_undestroy","undestroy","skipChunkCheck","readableAddChunk","addToFront","onEofChunk","chunkInvalid","addChunk","maybeReadMore","needMoreData","emitReadable","isPaused","setEncoding","MAX_HWM","computeNewHighWaterMark","howMuchToRead","head","nOrig","endReadable","doRead","fromList","emitReadable_","flow","maybeReadMore_","dest","pipeOpts","doEnd","stdout","stderr","endFn","unpipe","onunpipe","unpipeInfo","hasUnpiped","cleanup","pipeOnDrain","cleanedUp","onfinish","ondata","needDrain","increasedAwaitDrain","pause","dests","ev","nReadingNextTick","resume_","_this","paused","_fromList","fromListPartial","hasStrings","copyFromBufferString","copyFromBuffer","nb","tail","endReadableNT","xs","afterTransform","ts","_transformState","transforming","writecb","writechunk","needTransform","writeencoding","transform","prefinish","_this2","err2","WriteReq","CorkedRequest","onCorkedFinish","asyncWrite","browser","WritableState","internalUtil","deprecate","writableObjectMode","writableHwm","writableHighWaterMark","finalCalled","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writelen","bufferedRequest","lastBufferedRequest","pendingcb","errorEmitted","bufferedRequestCount","corkedRequestsFree","getBuffer","current","_","realHasInstance","hasInstance","object","final","_final","writeAfterEnd","validChunk","valid","isBuf","writeOrBuffer","clearBuffer","setDefaultEncoding","decodeChunk","newChunk","last","doWrite","onwriteError","finishMaybe","onwriteStateUpdate","needFinish","afterWrite","onwriteDrain","holder","allBuffers","endWritable","callFinal","need","corkReq","_classCallCheck","instance","Constructor","copyBuffer","custom","readableDestroyed","writableDestroyed","emitErrorNT","copyProps","SafeBuffer","_normalizeEncoding","retried","normalizeEncoding","nenc","text","utf16Text","utf16End","fillLast","utf8FillLast","base64Text","base64End","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","utf8End","utf8Text","utf8CheckByte","byte","utf8CheckIncomplete","utf8CheckExtraBytes","total","noop","isRequest","setHeader","abort","isChildProcess","stdio","cancelled","onlegacyfinish","onexit","exitCode","onclosenexttick","onrequest","req","ctor","superCtor","super_","TempCtor","types","codes","CMD_SHIFT","CMD_MASK","DUP_MASK","QOS_MASK","QOS_SHIFT","RETAIN_MASK","VARBYTEINT_MASK","VARBYTEINT_FIN_MASK","VARBYTEINT_MAX","SESSIONPRESENT_MASK","SESSIONPRESENT_HEADER","CONNACK_HEADER","USERNAME_MASK","PASSWORD_MASK","WILL_RETAIN_MASK","WILL_QOS_MASK","WILL_QOS_SHIFT","WILL_FLAG_MASK","CLEAN_SESSION_MASK","CONNECT_HEADER","sessionExpiryInterval","willDelayInterval","receiveMaximum","requestResponseInformation","requestProblemInformation","userProperties","payloadFormatIndicator","messageExpiryInterval","contentType","responseTopic","correlationData","maximumQoS","retainAvailable","assignedClientIdentifier","wildcardSubscriptionAvailable","subscriptionIdentifiersAvailable","sharedSubscriptionAvailable","responseInformation","serverReference","subscriptionIdentifier","propertiesCodes","propertiesTypes","genHeader","PUBLISH_HEADER","SUBSCRIBE_HEADER","SUBSCRIBE_OPTIONS_QOS_MASK","SUBSCRIBE_OPTIONS_NL_MASK","SUBSCRIBE_OPTIONS_NL_SHIFT","SUBSCRIBE_OPTIONS_RAP_MASK","SUBSCRIBE_OPTIONS_RAP_SHIFT","SUBSCRIBE_OPTIONS_RH_MASK","SUBSCRIBE_OPTIONS_RH_SHIFT","SUBSCRIBE_OPTIONS_RH","SUBSCRIBE_OPTIONS_NL","SUBSCRIBE_OPTIONS_RAP","SUBSCRIBE_OPTIONS_QOS","UNSUBSCRIBE_HEADER","ACKS","unsuback","puback","pubcomp","pubrel","pubrec","SUBACK_HEADER","suback","VERSION3","VERSION4","VERSION5","VERSION131","VERSION132","QOS","EMPTY","pingreq","pingresp","disconnect","generate","Accumulator","_array","_i","lengths","cache","SubOk","generateBuffer","generateCache","genBufVariableByteInt","maxLength","digit","generate4ByteBuffer","generateNumber","Packet","bl","constants","Parser","opt","settings","_states","_resetState","_list","_stateCounter","_parseHeader","zero","_parseLength","_parseVarByteNum","_parsePayload","_pos","_parseConnect","_parseConnack","_parsePublish","_parseConfirmation","_parseSubscribe","_parseSuback","_parseUnsubscribe","_parseUnsuback","_parseDisconnect","_parseAuth","_emitError","_parseString","bridgeMode","will","_parseNum","_parseProperties","willProperties","_parseBuffer","_parseMessageId","subscription","_parseByte","maybeBuffer","_parseStringPair","_parse4ByteNum","fullInfoFlag","padding","_parseByType","currentUserProperty","currentValue","_newPacket","empty","zeroBuf","numbers","numCache","writeNumber","writeNumberCached","toGenerate","confirmation","emptyPacket","writeNumberGenerated","propertiesData","getProperties","providedUsername","isStringOrBuffer","writeVarByteInt","writeStringOrBuffer","writeString","getPropertiesByMaximumPacketSize","itopic","iqos","jtopic","jqos","jnl","jrap","jrh","joptions","unsubs","varByteIntCache","strlen","writeStringPair","number","generatedNumber","write4ByteNumber","generated4ByteBuffer","toWrite","writeProperties","propertiesLength","getLengthProperty","reduce","currentLength","propName","propLength","propValueLength","propValue","valueIndex","propertiesLengthLength","mayEmptyProps","currentMayEmptyProp","writeProperty","bufOrString","field","h","long","fmtLong","fmtShort","exec","parseFloat","msAbs","round","plural","isPlural","wrappy","strict","onceStrict","proto","called","onceError","arg1","arg2","arg3","afterTickOne","afterTickTwo","afterTickThree","afterTick","_inheritsLoose","subClass","superClass","createErrorType","Base","getMessage","NodeError","_Base","oneOf","expected","thing","startsWith","endsWith","this_len","determiner","msg","_require","getHighWaterMark","_require$codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","createReadableStreamAsyncIterator","errorOrDestroy","emitClose","content","pipeOnDrainFunctionResult","updateReadableListening","methodWrap","methodWrapReturnFunction","asyncIterator","first","wState","iterable","ERR_MULTIPLE_CALLBACK","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","writableStateBufferGetter","rState","_Object$setPrototypeO","_defineProperty","kLastResolve","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","readAndResolve","iter","onReadable","wrapForNext","lastPromise","then","AsyncIteratorPrototype","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","promise","_return","_Object$create","iterator","enumerableOnly","symbols","sym","getOwnPropertyDescriptor","_objectSpread","source","getOwnPropertyDescriptors","defineProperties","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_require2","_getString","_getBuffer","depth","customInspect","emitErrorAndCloseNT","emitCloseNT","ERR_STREAM_PREMATURE_CLOSE","_len","_key","writableEnded","readableEnded","ERR_MISSING_ARGS","closed","to","popCallback","streams","pipeline","destroys","ERR_INVALID_OPT_VALUE","highWaterMarkFrom","duplexKey","ReInterval","interval","_args","_interval","_duplexState","getStateLength","config","deprecated","trace","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","runClearTimeout","marker","draining","currentQueue","queueIndex","cleanUpNextTick","drainQueue","timeout","run","Item","argv","versions","binding","cwd","chdir","umask","root","freeExports","nodeType","freeModule","freeGlobal","punycode","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","regexPunycode","regexNonASCII","regexSeparators","baseMinusTMin","stringFromCharCode","mapDomain","labels","encoded","ucs2decode","counter","extra","ucs2encode","basicToDigit","digitToBasic","flag","adapt","delta","numPoints","firstTime","decode","input","inputLength","bias","basic","oldi","baseMinusT","encode","handledCPCount","basicLength","q","handledCPCountPlusOne","qMinusT","toUnicode","toASCII","qs","sep","eq","maxKeys","idx","kstr","vstr","decodeURIComponent","stringifyPrimitive","ks","encodeURIComponent","clearImmediate","immediateIds","nextImmediateId","Timeout","clearFn","_id","_clearFn","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","onTimeout","_onTimeout","onNextTick","urlParse","urlResolve","resolveObject","urlResolveObject","urlFormat","Url","slashes","pathname","href","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","hostlessProtocol","slashedProtocol","querystring","parseQueryString","slashesDenoteHost","queryIndex","splitter","uSplit","slashRegex","rest","simplePath","lowerProto","hostEnd","hec","atSign","parseHost","ipv6Hostname","hostparts","part","newpart","validParts","notHost","bit","ae","esc","escape","qm","charAt","relative","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","authInHost","hasTrailingSlash","up","isAbsolute"],"mappings":"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","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.mqtt = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n(function (Buffer){(function (){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"base64-js\":1,\"buffer\":3,\"ieee754\":5}],4:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n},{}],5:[function(require,module,exports){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],6:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],7:[function(require,module,exports){\n(function (process,global){(function (){\n'use strict'\n\n/**\n * Module dependencies\n */\nvar EventEmitter = require('events').EventEmitter\nvar Store = require('./store')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar debug = require('debug')('mqttjs:client')\nvar nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nvar socketErrors = [\n  'ECONNREFUSED',\n  'EADDRINUSE',\n  'ECONNRESET',\n  'ENOTFOUND'\n]\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet)\n  debug('sendPacket :: emitting `packetsend`')\n  client.emit('packetsend', packet)\n\n  debug('sendPacket :: writing to stream')\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options)\n  debug('sendPacket :: writeToStream result %s', result)\n  if (!result && cb) {\n    debug('sendPacket :: handle events on `drain` once through callback.')\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    debug('sendPacket :: invoking cb')\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!(queue))\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop (error) {\n  debug('nop ::', error)\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol)\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\n  debug('MqttClient :: options.username', options.username)\n  debug('MqttClient :: options.keepalive', options.keepalive)\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  debug('MqttClient :: clientId', this.options.clientId)\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      debug('deliver :: entry %o', entry)\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n      debug('deliver :: call _sendPacket for %o', packet)\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    debug('connect :: sending queued packets')\n    deliver()\n  })\n\n  this.on('close', function () {\n    debug('close :: connected set to `false`')\n    this.connected = false\n\n    debug('close :: clearing connackTimer')\n    clearTimeout(this.connackTimer)\n\n    debug('close :: clearing ping timer')\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n\n    debug('close :: calling _setupReconnect')\n    this._setupReconnect()\n  })\n  EventEmitter.call(this)\n\n  debug('MqttClient :: setting up stream')\n  this._setupStream()\n}\ninherits(MqttClient, EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  debug('_setupStream :: calling method to clear reconnect')\n  this._clearReconnect()\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.')\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      nextTick(work)\n    } else {\n      var done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    debug('work :: getting next packet in queue')\n    var packet = packets.shift()\n\n    if (packet) {\n      debug('work :: packet pulled from queue')\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      debug('work :: no packets in queue')\n      var done = completeParse\n      completeParse = null\n      debug('work :: done flag is %s', !!(done))\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    debug('writable stream :: parsing buffer')\n    parser.parse(buf)\n    work()\n  }\n\n  function streamErrorHandler (error) {\n    debug('streamErrorHandler :: error', error.message)\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error')\n      that.emit('error', error)\n    } else {\n      nop(error)\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream')\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId)\n    flushVolatile(that.outgoing)\n    debug('stream: emit close to MqttClient')\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`')\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() =>\n        this.emit('error', new Error('Packet has no Authentication Method')\n        ))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})\n    return this\n  }\n  debug('_handlePacket :: emitting packetreceive')\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic)\n  var packet\n  var options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties\n    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&\n      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||\n        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {\n      /*\n      if we are don`t setup topic alias or\n      topic alias maximum less than topic alias or\n      server don`t give topic alias maximum,\n      we are removing topic alias from packet\n      */\n      delete packet.properties.topicAlias\n    }\n  }\n\n  debug('publish :: qos', opts.qos)\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      }\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled')\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false\n        this._storePacket(packet, undefined, opts.cbStorePut)\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        this._sendPacket(packet, undefined, opts.cbStorePut)\n      }\n      break\n    default:\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled')\n        this._storePacket(packet, callback, opts.cbStorePut)\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        this._sendPacket(packet, callback, opts.cbStorePut)\n      }\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n  var version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true')\n    return this\n  }\n\n  var defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic)\n      if (!that._resubscribeTopics.hasOwnProperty(topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        debug('subscribe: object topic %s', k)\n        if (!that._resubscribeTopics.hasOwnProperty(k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          var currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    debug('subscribe :: resubscribe true')\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = { qos: sub.qos }\n        if (version === 5) {\n          topic.nl = sub.nl || false\n          topic.rap = sub.rap || false\n          topic.rh = sub.rh || 0\n          topic.properties = sub.properties\n        }\n        that._resubscribeTopics[sub.topic] = topic\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function (err, packet) {\n      if (!err) {\n        var granted = packet.granted\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i]\n        }\n      }\n\n      callback(err, subs)\n    }\n  }\n  debug('subscribe :: call _sendPacket')\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var topic = args.shift()\n  var callback = args.pop() || nop\n  var opts = args.pop()\n\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (Array.isArray(topic)) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  }\n\n  debug('unsubscribe: call _sendPacket')\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  var that = this\n\n  debug('end :: (%s)', this.options.clientId)\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  debug('end :: cb? %s', !!cb)\n  cb = cb || nop\n\n  function closeStores () {\n    debug('end :: closeStores: closing incoming and outgoing stores')\n    that.disconnected = true\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end')\n        that.emit('end')\n        if (cb) {\n          let err = e1 || e2\n          debug('end :: closeStores: invoking callback with args')\n          cb(err)\n        }\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores')\n      // var boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that))\n    }, opts)\n  }\n\n  if (this.disconnecting) {\n    cb()\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  delete this.outgoing[messageId]\n  this.outgoingStore.del({messageId: messageId}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect')\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client')\n  this.emit('reconnect')\n  if (this.connected) {\n    this.end(() => { this._setupStream() })\n    debug('client already connected. disconnecting first.')\n  } else {\n    debug('_reconnect: calling _setupStream')\n    this._setupStream()\n  }\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state')\n      this.emit('offline')\n      debug('_setupReconnect :: set `reconnecting` to `true`')\n      this.reconnecting = true\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!')\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  } else {\n    debug('_setupReconnect :: doing nothing...')\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer')\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2]\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close')\n    this.stream.on('close', done)\n  }\n\n  debug('_cleanUp :: forced? %s', forced)\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\n    this.stream.destroy()\n  } else {\n    var packet = xtend({ cmd: 'disconnect' }, opts)\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer')\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\n  cbStorePut = cbStorePut || nop\n\n  if (!this.connected) {\n    debug('_sendPacket :: client not connected. Storing packet offline.')\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\n}\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet)\n  debug('_storePacket :: cb? %s', !!cb)\n  cbStorePut = cbStorePut || nop\n\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n    this.queue.push({ packet: packet, cb: cb })\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...')\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true')\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack')\n  var options = this.options\n  var version = options.protocolVersion\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet)\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var messageId = packet.messageId\n  var that = this\n  var options = this.options\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n  debug('_handlePublish: qos %d', qos)\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({cmd: 'pubrec', messageId: messageId, reasonCode: code}, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({cmd: 'pubrec', messageId: messageId}, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({cmd: 'puback', messageId: messageId, reasonCode: code}, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.')\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var messageId = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  var that = this\n  var err\n\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type)\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      var pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[messageId]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      }\n      var pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    case 'suback':\n      delete this.outgoing[messageId]\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[messageId]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[messageId]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet')\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var messageId = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: messageId}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function (connack) {\n  debug('_resubscribe')\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5')\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  var that = this\n\n  this._setupPingTimer()\n  this._resubscribe(packet)\n\n  this.connected = true\n\n  function startStreamProcess () {\n    var outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      var packet = outStore.read(1)\n\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      var allProcessed = true\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nmodule.exports = MqttClient\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./store\":13,\"./validations\":14,\"_process\":69,\"debug\":19,\"events\":4,\"inherits\":34,\"mqtt-packet\":38,\"readable-stream\":60,\"reinterval\":61,\"xtend\":68}],8:[function(require,module,exports){\n(function (Buffer){(function (){\n'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\n\n/* global FileReader */\nvar my\nvar proxy\nvar stream\nvar isInitialized = false\n\nfunction buildProxy () {\n  var proxy = new Transform()\n  proxy._write = function (chunk, encoding, next) {\n    my.sendSocketMessage({\n      data: chunk.buffer,\n      success: function () {\n        next()\n      },\n      fail: function () {\n        next(new Error())\n      }\n    })\n  }\n  proxy._flush = function socketEnd (done) {\n    my.closeSocket({\n      success: function () {\n        done()\n      }\n    })\n  }\n\n  return proxy\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n}\n\nfunction buildUrl (opts, client) {\n  var protocol = opts.protocol === 'alis' ? 'wss' : 'ws'\n  var url = protocol + '://' + opts.hostname + opts.path\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  }\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction bindEventHandler () {\n  if (isInitialized) return\n\n  isInitialized = true\n\n  my.onSocketOpen(function () {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  })\n\n  my.onSocketMessage(function (res) {\n    if (typeof res.data === 'string') {\n      var buffer = Buffer.from(res.data, 'base64')\n      proxy.push(buffer)\n    } else {\n      var reader = new FileReader()\n      reader.addEventListener('load', function () {\n        var data = reader.result\n\n        if (data instanceof ArrayBuffer) data = Buffer.from(data)\n        else data = Buffer.from(data, 'utf8')\n        proxy.push(data)\n      })\n      reader.readAsArrayBuffer(res.data)\n    }\n  })\n\n  my.onSocketClose(function () {\n    stream.end()\n    stream.destroy()\n  })\n\n  my.onSocketError(function (res) {\n    stream.destroy(res)\n  })\n}\n\nfunction buildStream (client, opts) {\n  opts.hostname = opts.hostname || opts.host\n\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.')\n  }\n\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n\n  var url = buildUrl(opts, client)\n  my = opts.my\n  my.connectSocket({\n    url: url,\n    protocols: websocketSubProtocol\n  })\n\n  proxy = buildProxy()\n  stream = duplexify.obj()\n\n  bindEventHandler()\n\n  return stream\n}\n\nmodule.exports = buildStream\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":3,\"duplexify\":21,\"readable-stream\":60}],9:[function(require,module,exports){\n'use strict'\nvar net = require('net')\nvar debug = require('debug')('mqttjs:tcp')\n\n/*\n  variables port and host can be removed since\n  you have all required information in opts object\n*/\nfunction streamBuilder (client, opts) {\n  var port, host\n  opts.port = opts.port || 1883\n  opts.hostname = opts.hostname || opts.host || 'localhost'\n\n  port = opts.port\n  host = opts.hostname\n\n  debug('port %d and host %s', port, host)\n  return net.createConnection(port, host)\n}\n\nmodule.exports = streamBuilder\n\n},{\"debug\":19,\"net\":2}],10:[function(require,module,exports){\n'use strict'\nvar tls = require('tls')\nvar debug = require('debug')('mqttjs:tls')\n\nfunction buildBuilder (mqttClient, opts) {\n  var connection\n  opts.port = opts.port || 8883\n  opts.host = opts.hostname || opts.host || 'localhost'\n  opts.servername = opts.host\n\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\n\n  delete opts.path\n\n  debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized)\n\n  connection = tls.connect(opts)\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'))\n    } else {\n      connection.removeListener('error', handleTLSerrors)\n    }\n  })\n\n  function handleTLSerrors (err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err)\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end()\n  }\n\n  connection.on('error', handleTLSerrors)\n  return connection\n}\n\nmodule.exports = buildBuilder\n\n},{\"debug\":19,\"tls\":2}],11:[function(require,module,exports){\n(function (process,Buffer){(function (){\n'use strict'\n\nconst WS = require('ws')\nconst debug = require('debug')('mqttjs:ws')\nconst duplexify = require('duplexify')\nconst Transform = require('readable-stream').Transform\n\nlet WSS_OPTIONS = [\n  'rejectUnauthorized',\n  'ca',\n  'cert',\n  'key',\n  'pfx',\n  'passphrase'\n]\n// eslint-disable-next-line camelcase\nconst IS_BROWSER = (typeof process !== 'undefined' && process.title === 'browser') || typeof __webpack_require__ === 'function'\nfunction buildUrl (opts, client) {\n  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  let options = opts\n  if (!opts.hostname) {\n    options.hostname = 'localhost'\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      options.port = 443\n    } else {\n      options.port = 80\n    }\n  }\n  if (!opts.path) {\n    options.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    options.wsOptions = {}\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n        options.wsOptions[prop] = opts[prop]\n      }\n    })\n  }\n\n  return options\n}\n\nfunction setDefaultBrowserOpts (opts) {\n  let options = setDefaultOpts(opts)\n\n  if (!options.hostname) {\n    options.hostname = options.host\n  }\n\n  if (!options.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof (document) === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.')\n    }\n    const parsed = new URL(document.URL)\n    options.hostname = parsed.hostname\n\n    if (!options.port) {\n      options.port = parsed.port\n    }\n  }\n\n  // objectMode should be defined for logic\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  return options\n}\n\nfunction createWebSocket (client, url, opts) {\n  debug('createWebSocket')\n  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion)\n  const websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol)\n  let socket = new WS(url, [websocketSubProtocol], opts.wsOptions)\n  return socket\n}\n\nfunction createBrowserWebSocket (client, opts) {\n  const websocketSubProtocol =\n  (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n    ? 'mqttv3.1'\n    : 'mqtt'\n\n  let url = buildUrl(opts, client)\n  /* global WebSocket */\n  let socket = new WebSocket(url, [websocketSubProtocol])\n  socket.binaryType = 'arraybuffer'\n  return socket\n}\n\nfunction streamBuilder (client, opts) {\n  debug('streamBuilder')\n  let options = setDefaultOpts(opts)\n  const url = buildUrl(options, client)\n  let socket = createWebSocket(client, url, options)\n  let webSocketStream = WS.createWebSocketStream(socket, options.wsOptions)\n  webSocketStream.url = url\n  return webSocketStream\n}\n\nfunction browserStreamBuilder (client, opts) {\n  debug('browserStreamBuilder')\n  let stream\n  let options = setDefaultBrowserOpts(opts)\n  // sets the maximum socket buffer size before throttling\n  const bufferSize = options.browserBufferSize || 1024 * 512\n\n  const bufferTimeout = opts.browserBufferTimeout || 1000\n\n  const coerceToBuffer = !opts.objectMode\n\n  let socket = createBrowserWebSocket(client, opts)\n\n  let proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser)\n\n  if (!opts.objectMode) {\n    proxy._writev = writev\n  }\n  proxy.on('close', () => { socket.close() })\n\n  const eventListenerSupport = (typeof socket.addEventListener === 'undefined')\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else {\n    stream = stream = duplexify(undefined, undefined, opts)\n    if (!opts.objectMode) {\n      stream._writev = writev\n    }\n\n    if (eventListenerSupport) {\n      socket.addEventListener('open', onopen)\n    } else {\n      socket.onopen = onopen\n    }\n  }\n\n  stream.socket = socket\n\n  if (eventListenerSupport) {\n    socket.addEventListener('close', onclose)\n    socket.addEventListener('error', onerror)\n    socket.addEventListener('message', onmessage)\n  } else {\n    socket.onclose = onclose\n    socket.onerror = onerror\n    socket.onmessage = onmessage\n  }\n\n  // methods for browserStreamBuilder\n\n  function buildProxy (options, socketWrite, socketEnd) {\n    let proxy = new Transform({\n      objectModeMode: options.objectMode\n    })\n\n    proxy._write = socketWrite\n    proxy._flush = socketEnd\n\n    return proxy\n  }\n\n  function onopen () {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onclose () {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror (err) {\n    stream.destroy(err)\n  }\n\n  function onmessage (event) {\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    const buffers = new Array(chunks.length)\n    for (let i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  function socketWriteBrowser (chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      // throttle data until buffered amount is reduced.\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch (err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEndBrowser (done) {\n    socket.close()\n    done()\n  }\n\n  // end methods for browserStreamBuilder\n\n  return stream\n}\n\nif (IS_BROWSER) {\n  module.exports = browserStreamBuilder\n} else {\n  module.exports = streamBuilder\n}\n\n}).call(this)}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":69,\"buffer\":3,\"debug\":19,\"duplexify\":21,\"readable-stream\":60,\"ws\":67}],12:[function(require,module,exports){\n(function (Buffer){(function (){\n'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\n\n/* global wx */\nvar socketTask\nvar proxy\nvar stream\n\nfunction buildProxy () {\n  var proxy = new Transform()\n  proxy._write = function (chunk, encoding, next) {\n    socketTask.send({\n      data: chunk.buffer,\n      success: function () {\n        next()\n      },\n      fail: function (errMsg) {\n        next(new Error(errMsg))\n      }\n    })\n  }\n  proxy._flush = function socketEnd (done) {\n    socketTask.close({\n      success: function () {\n        done()\n      }\n    })\n  }\n\n  return proxy\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n}\n\nfunction buildUrl (opts, client) {\n  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'\n  var url = protocol + '://' + opts.hostname + opts.path\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  }\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction bindEventHandler () {\n  socketTask.onOpen(function () {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  })\n\n  socketTask.onMessage(function (res) {\n    var data = res.data\n\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  })\n\n  socketTask.onClose(function () {\n    stream.end()\n    stream.destroy()\n  })\n\n  socketTask.onError(function (res) {\n    stream.destroy(new Error(res.errMsg))\n  })\n}\n\nfunction buildStream (client, opts) {\n  opts.hostname = opts.hostname || opts.host\n\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.')\n  }\n\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n\n  var url = buildUrl(opts, client)\n  socketTask = wx.connectSocket({\n    url: url,\n    protocols: [websocketSubProtocol]\n  })\n\n  proxy = buildProxy()\n  stream = duplexify.obj()\n  stream._destroy = function (err, cb) {\n    socketTask.close({\n      success: function () {\n        cb && cb(err)\n      }\n    })\n  }\n\n  var destroyRef = stream.destroy\n  stream.destroy = function () {\n    stream.destroy = destroyRef\n\n    var self = this\n    setTimeout(function () {\n      socketTask.close({\n        fail: function () {\n          self._destroy(new Error())\n        }\n      })\n    }, 0)\n  }.bind(stream)\n\n  bindEventHandler()\n\n  return stream\n}\n\nmodule.exports = buildStream\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":3,\"duplexify\":21,\"readable-stream\":60}],13:[function(require,module,exports){\n'use strict'\n\n/**\n * Module dependencies\n */\nvar xtend = require('xtend')\n\nvar Readable = require('readable-stream').Readable\nvar streamsOpts = { objectMode: true }\nvar defaultStoreOptions = {\n  clean: true\n}\n\n/**\n * In-memory implementation of the message store\n * This can actually be saved into files.\n *\n * @param {Object} [options] - store options\n */\nfunction Store (options) {\n  if (!(this instanceof Store)) {\n    return new Store(options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  this.options = xtend(defaultStoreOptions, options)\n\n  this._inflights = new Map()\n}\n\n/**\n * Adds a packet to the store, a packet is\n * anything that has a messageId property.\n *\n */\nStore.prototype.put = function (packet, cb) {\n  this._inflights.set(packet.messageId, packet)\n\n  if (cb) {\n    cb()\n  }\n\n  return this\n}\n\n/**\n * Creates a stream with all the packets in the store\n *\n */\nStore.prototype.createStream = function () {\n  var stream = new Readable(streamsOpts)\n  var destroyed = false\n  var values = []\n  var i = 0\n\n  this._inflights.forEach(function (value, key) {\n    values.push(value)\n  })\n\n  stream._read = function () {\n    if (!destroyed && i < values.length) {\n      this.push(values[i++])\n    } else {\n      this.push(null)\n    }\n  }\n\n  stream.destroy = function () {\n    if (destroyed) {\n      return\n    }\n\n    var self = this\n\n    destroyed = true\n\n    setTimeout(function () {\n      self.emit('close')\n    }, 0)\n  }\n\n  return stream\n}\n\n/**\n * deletes a packet from the store.\n */\nStore.prototype.del = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    this._inflights.delete(packet.messageId)\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * get a packet from the store.\n */\nStore.prototype.get = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * Close the store\n */\nStore.prototype.close = function (cb) {\n  if (this.options.clean) {\n    this._inflights = null\n  }\n  if (cb) {\n    cb()\n  }\n}\n\nmodule.exports = Store\n\n},{\"readable-stream\":60,\"xtend\":68}],14:[function(require,module,exports){\n'use strict'\n\n/**\n * Validate a topic to see if it's valid or not.\n * A topic is valid if it follow below rules:\n * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n * - Rule #2: Part `#` must be located at the end of the mailbox\n *\n * @param {String} topic - A topic\n * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n */\nfunction validateTopic (topic) {\n  var parts = topic.split('/')\n\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] === '+') {\n      continue\n    }\n\n    if (parts[i] === '#') {\n      // for Rule #2\n      return i === parts.length - 1\n    }\n\n    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Validate an array of topics to see if any of them is valid or not\n  * @param {Array} topics - Array of topics\n * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n */\nfunction validateTopics (topics) {\n  if (topics.length === 0) {\n    return 'empty_topic_list'\n  }\n  for (var i = 0; i < topics.length; i++) {\n    if (!validateTopic(topics[i])) {\n      return topics[i]\n    }\n  }\n  return null\n}\n\nmodule.exports = {\n  validateTopics: validateTopics\n}\n\n},{}],15:[function(require,module,exports){\n(function (process){(function (){\n'use strict'\n\nvar MqttClient = require('../client')\nvar Store = require('../store')\nvar url = require('url')\nvar xtend = require('xtend')\nvar debug = require('debug')('mqttjs')\n\nvar protocols = {}\n\n// eslint-disable-next-line camelcase\nif ((typeof process !== 'undefined' && process.title !== 'browser') || typeof __webpack_require__ !== 'function') {\n  protocols.mqtt = require('./tcp')\n  protocols.tcp = require('./tcp')\n  protocols.ssl = require('./tls')\n  protocols.tls = require('./tls')\n  protocols.mqtts = require('./tls')\n} else {\n  protocols.wx = require('./wx')\n  protocols.wxs = require('./wx')\n\n  protocols.ali = require('./ali')\n  protocols.alis = require('./ali')\n}\n\nprotocols.ws = require('./ws')\nprotocols.wss = require('./ws')\n\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\nfunction parseAuthOptions (opts) {\n  var matches\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/)\n    if (matches) {\n      opts.username = matches[1]\n      opts.password = matches[2]\n    } else {\n      opts.username = opts.auth\n    }\n  }\n}\n\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\nfunction connect (brokerUrl, opts) {\n  debug('connecting to an MQTT broker...')\n  if ((typeof brokerUrl === 'object') && !opts) {\n    opts = brokerUrl\n    brokerUrl = null\n  }\n\n  opts = opts || {}\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true)\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port)\n    }\n\n    opts = xtend(parsed, opts)\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol')\n    }\n\n    opts.protocol = opts.protocol.replace(/:$/, '')\n  }\n\n  // merge in the auth options if supplied\n  parseAuthOptions(opts)\n\n  // support clientId passed in the query string of the url\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts'\n            break\n          case 'ws':\n            opts.protocol = 'wss'\n            break\n          case 'wx':\n            opts.protocol = 'wxs'\n            break\n          case 'ali':\n            opts.protocol = 'alis'\n            break\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!')\n        }\n      }\n    } else {\n      // A cert and key was provided, however no protocol was specified, so we will throw an error.\n      throw new Error('Missing secure protocol key')\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\n    opts.protocol = [\n      'mqtt',\n      'mqtts',\n      'ws',\n      'wss',\n      'wx',\n      'wxs',\n      'ali',\n      'alis'\n    ].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false\n      }\n      return (typeof protocols[key] === 'function')\n    })[0]\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients')\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol\n  }\n\n  function wrapper (client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host\n      opts.port = opts.servers[client._reconnectCount].port\n      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)\n      opts.hostname = opts.host\n\n      client._reconnectCount++\n    }\n\n    debug('calling streambuilder for', opts.protocol)\n    return protocols[opts.protocol](client, opts)\n  }\n  var client = new MqttClient(wrapper, opts)\n  client.on('error', function () { /* Automatically set up client error handling */ })\n  return client\n}\n\nmodule.exports = connect\nmodule.exports.connect = connect\nmodule.exports.MqttClient = MqttClient\nmodule.exports.Store = Store\n\n}).call(this)}).call(this,require('_process'))\n},{\"../client\":7,\"../store\":13,\"./ali\":8,\"./tcp\":9,\"./tls\":10,\"./ws\":11,\"./wx\":12,\"_process\":69,\"debug\":19,\"url\":75,\"xtend\":68}],16:[function(require,module,exports){\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst symbol = Symbol.for('BufferList')\n\nfunction BufferList (buf) {\n  if (!(this instanceof BufferList)) {\n    return new BufferList(buf)\n  }\n\n  BufferList._init.call(this, buf)\n}\n\nBufferList._init = function _init (buf) {\n  Object.defineProperty(this, symbol, { value: true })\n\n  this._bufs = []\n  this.length = 0\n\n  if (buf) {\n    this.append(buf)\n  }\n}\n\nBufferList.prototype._new = function _new (buf) {\n  return new BufferList(buf)\n}\n\nBufferList.prototype._offset = function _offset (offset) {\n  if (offset === 0) {\n    return [0, 0]\n  }\n\n  let tot = 0\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    const _t = tot + this._bufs[i].length\n    if (offset < _t || i === this._bufs.length - 1) {\n      return [i, offset - tot]\n    }\n    tot = _t\n  }\n}\n\nBufferList.prototype._reverseOffset = function (blOffset) {\n  const bufferId = blOffset[0]\n  let offset = blOffset[1]\n\n  for (let i = 0; i < bufferId; i++) {\n    offset += this._bufs[i].length\n  }\n\n  return offset\n}\n\nBufferList.prototype.get = function get (index) {\n  if (index > this.length || index < 0) {\n    return undefined\n  }\n\n  const offset = this._offset(index)\n\n  return this._bufs[offset[0]][offset[1]]\n}\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start === 'number' && start < 0) {\n    start += this.length\n  }\n\n  if (typeof end === 'number' && end < 0) {\n    end += this.length\n  }\n\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart !== 'number' || srcStart < 0) {\n    srcStart = 0\n  }\n\n  if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n    srcEnd = this.length\n  }\n\n  if (srcStart >= this.length) {\n    return dst || Buffer.alloc(0)\n  }\n\n  if (srcEnd <= 0) {\n    return dst || Buffer.alloc(0)\n  }\n\n  const copy = !!dst\n  const off = this._offset(srcStart)\n  const len = srcEnd - srcStart\n  let bytes = len\n  let bufoff = (copy && dstStart) || 0\n  let start = off[1]\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd === this.length) {\n    if (!copy) {\n      // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (let i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) {\n    // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n  }\n\n  for (let i = off[0]; i < this._bufs.length; i++) {\n    const l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start) {\n      start = 0\n    }\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = typeof end !== 'number' ? this.length : end\n\n  if (start < 0) {\n    start += this.length\n  }\n\n  if (end < 0) {\n    end += this.length\n  }\n\n  if (start === end) {\n    return this._new()\n  }\n\n  const startOffset = this._offset(start)\n  const endOffset = this._offset(end)\n  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] === 0) {\n    buffers.pop()\n  } else {\n    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])\n  }\n\n  if (startOffset[1] !== 0) {\n    buffers[0] = buffers[0].slice(startOffset[1])\n  }\n\n  return this._new(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n\n  return this\n}\n\nBufferList.prototype.duplicate = function duplicate () {\n  const copy = this._new()\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    copy.append(this._bufs[i])\n  }\n\n  return copy\n}\n\nBufferList.prototype.append = function append (buf) {\n  if (buf == null) {\n    return this\n  }\n\n  if (buf.buffer) {\n    // append a view of the underlying ArrayBuffer\n    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))\n  } else if (Array.isArray(buf)) {\n    for (let i = 0; i < buf.length; i++) {\n      this.append(buf[i])\n    }\n  } else if (this._isBufferList(buf)) {\n    // unwrap argument into individual BufferLists\n    for (let i = 0; i < buf._bufs.length; i++) {\n      this.append(buf._bufs[i])\n    }\n  } else {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf === 'number') {\n      buf = buf.toString()\n    }\n\n    this._appendBuffer(Buffer.from(buf))\n  }\n\n  return this\n}\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype.indexOf = function (search, offset, encoding) {\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n  }\n\n  if (typeof search === 'function' || Array.isArray(search)) {\n    throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.')\n  } else if (typeof search === 'number') {\n    search = Buffer.from([search])\n  } else if (typeof search === 'string') {\n    search = Buffer.from(search, encoding)\n  } else if (this._isBufferList(search)) {\n    search = search.slice()\n  } else if (Array.isArray(search.buffer)) {\n    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)\n  } else if (!Buffer.isBuffer(search)) {\n    search = Buffer.from(search)\n  }\n\n  offset = Number(offset || 0)\n\n  if (isNaN(offset)) {\n    offset = 0\n  }\n\n  if (offset < 0) {\n    offset = this.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0\n  }\n\n  if (search.length === 0) {\n    return offset > this.length ? this.length : offset\n  }\n\n  const blOffset = this._offset(offset)\n  let blIndex = blOffset[0] // index of which internal buffer we're working on\n  let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n\n  // scan over each buffer\n  for (; blIndex < this._bufs.length; blIndex++) {\n    const buff = this._bufs[blIndex]\n\n    while (buffOffset < buff.length) {\n      const availableWindow = buff.length - buffOffset\n\n      if (availableWindow >= search.length) {\n        const nativeSearchResult = buff.indexOf(search, buffOffset)\n\n        if (nativeSearchResult !== -1) {\n          return this._reverseOffset([blIndex, nativeSearchResult])\n        }\n\n        buffOffset = buff.length - search.length + 1 // end of native search window\n      } else {\n        const revOffset = this._reverseOffset([blIndex, buffOffset])\n\n        if (this._match(revOffset, search)) {\n          return revOffset\n        }\n\n        buffOffset++\n      }\n    }\n\n    buffOffset = 0\n  }\n\n  return -1\n}\n\nBufferList.prototype._match = function (offset, search) {\n  if (this.length - offset < search.length) {\n    return false\n  }\n\n  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n    if (this.get(offset + searchOffset) !== search[searchOffset]) {\n      return false\n    }\n  }\n  return true\n}\n\n;(function () {\n  const methods = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  }\n\n  for (const m in methods) {\n    (function (m) {\n      if (methods[m] === null) {\n        BufferList.prototype[m] = function (offset, byteLength) {\n          return this.slice(offset, offset + byteLength)[m](0, byteLength)\n        }\n      } else {\n        BufferList.prototype[m] = function (offset = 0) {\n          return this.slice(offset, offset + methods[m])[m](0)\n        }\n      }\n    }(m))\n  }\n}())\n\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferList || BufferList.isBufferList(b)\n}\n\nBufferList.isBufferList = function isBufferList (b) {\n  return b != null && b[symbol]\n}\n\nmodule.exports = BufferList\n\n},{\"buffer\":3}],17:[function(require,module,exports){\n'use strict'\n\nconst DuplexStream = require('readable-stream').Duplex\nconst inherits = require('inherits')\nconst BufferList = require('./BufferList')\n\nfunction BufferListStream (callback) {\n  if (!(this instanceof BufferListStream)) {\n    return new BufferListStream(callback)\n  }\n\n  if (typeof callback === 'function') {\n    this._callback = callback\n\n    const piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n\n    callback = null\n  }\n\n  BufferList._init.call(this, callback)\n  DuplexStream.call(this)\n}\n\ninherits(BufferListStream, DuplexStream)\nObject.assign(BufferListStream.prototype, BufferList.prototype)\n\nBufferListStream.prototype._new = function _new (callback) {\n  return new BufferListStream(callback)\n}\n\nBufferListStream.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback === 'function') {\n    callback()\n  }\n}\n\nBufferListStream.prototype._read = function _read (size) {\n  if (!this.length) {\n    return this.push(null)\n  }\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferListStream.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferListStream.prototype._destroy = function _destroy (err, cb) {\n  this._bufs.length = 0\n  this.length = 0\n  cb(err)\n}\n\nBufferListStream.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)\n}\n\nBufferListStream.isBufferList = BufferList.isBufferList\n\nmodule.exports = BufferListStream\nmodule.exports.BufferListStream = BufferListStream\nmodule.exports.BufferList = BufferList\n\n},{\"./BufferList\":16,\"inherits\":34,\"readable-stream\":60}],18:[function(require,module,exports){\n(function (Buffer){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this)}).call(this,{\"isBuffer\":require(\"../../../../is-buffer/index.js\")})\n},{\"../../../../is-buffer/index.js\":6}],19:[function(require,module,exports){\n(function (process){(function (){\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n}).call(this)}).call(this,require('_process'))\n},{\"./common\":20,\"_process\":69}],20:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n},{\"ms\":43}],21:[function(require,module,exports){\n(function (process,Buffer){(function (){\nvar stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n\n}).call(this)}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":69,\"buffer\":3,\"end-of-stream\":33,\"inherits\":34,\"readable-stream\":30,\"stream-shift\":63}],22:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n},{\"./_stream_readable\":24,\"./_stream_writable\":26,\"core-util-is\":18,\"inherits\":34,\"process-nextick-args\":45}],23:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":25,\"core-util-is\":18,\"inherits\":34}],24:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":22,\"./internal/streams/BufferList\":27,\"./internal/streams/destroy\":28,\"./internal/streams/stream\":29,\"_process\":69,\"core-util-is\":18,\"events\":4,\"inherits\":34,\"isarray\":35,\"process-nextick-args\":45,\"safe-buffer\":31,\"string_decoder/\":32,\"util\":2}],25:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":22,\"core-util-is\":18,\"inherits\":34}],26:[function(require,module,exports){\n(function (process,global,setImmediate){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"timers\").setImmediate)\n},{\"./_stream_duplex\":22,\"./internal/streams/destroy\":28,\"./internal/streams/stream\":29,\"_process\":69,\"core-util-is\":18,\"inherits\":34,\"process-nextick-args\":45,\"safe-buffer\":31,\"timers\":74,\"util-deprecate\":65}],27:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n},{\"safe-buffer\":31,\"util\":2}],28:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n},{\"process-nextick-args\":45}],29:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":4}],30:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":22,\"./lib/_stream_passthrough.js\":23,\"./lib/_stream_readable.js\":24,\"./lib/_stream_transform.js\":25,\"./lib/_stream_writable.js\":26}],31:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":3}],32:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":31}],33:[function(require,module,exports){\n(function (process){(function (){\nvar once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n\n}).call(this)}).call(this,require('_process'))\n},{\"_process\":69,\"once\":44}],34:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n},{}],35:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],36:[function(require,module,exports){\n(function (Buffer){(function (){\n/* Protocol - protocol constants */\nconst protocol = module.exports\n\n/* Command code => mnemonic */\nprotocol.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'auth'\n}\n\n/* Mnemonic => Command code */\nprotocol.codes = {}\nfor (const k in protocol.types) {\n  const v = protocol.types[k]\n  protocol.codes[v] = k\n}\n\n/* Header */\nprotocol.CMD_SHIFT = 4\nprotocol.CMD_MASK = 0xF0\nprotocol.DUP_MASK = 0x08\nprotocol.QOS_MASK = 0x03\nprotocol.QOS_SHIFT = 1\nprotocol.RETAIN_MASK = 0x01\n\n/* Length */\nprotocol.VARBYTEINT_MASK = 0x7F\nprotocol.VARBYTEINT_FIN_MASK = 0x80\nprotocol.VARBYTEINT_MAX = 268435455\n\n/* Connack */\nprotocol.SESSIONPRESENT_MASK = 0x01\nprotocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])\nprotocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT])\n\n/* Connect */\nprotocol.USERNAME_MASK = 0x80\nprotocol.PASSWORD_MASK = 0x40\nprotocol.WILL_RETAIN_MASK = 0x20\nprotocol.WILL_QOS_MASK = 0x18\nprotocol.WILL_QOS_SHIFT = 3\nprotocol.WILL_FLAG_MASK = 0x04\nprotocol.CLEAN_SESSION_MASK = 0x02\nprotocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT])\n\n/* Properties */\nprotocol.properties = {\n  sessionExpiryInterval: 17,\n  willDelayInterval: 24,\n  receiveMaximum: 33,\n  maximumPacketSize: 39,\n  topicAliasMaximum: 34,\n  requestResponseInformation: 25,\n  requestProblemInformation: 23,\n  userProperties: 38,\n  authenticationMethod: 21,\n  authenticationData: 22,\n  payloadFormatIndicator: 1,\n  messageExpiryInterval: 2,\n  contentType: 3,\n  responseTopic: 8,\n  correlationData: 9,\n  maximumQoS: 36,\n  retainAvailable: 37,\n  assignedClientIdentifier: 18,\n  reasonString: 31,\n  wildcardSubscriptionAvailable: 40,\n  subscriptionIdentifiersAvailable: 41,\n  sharedSubscriptionAvailable: 42,\n  serverKeepAlive: 19,\n  responseInformation: 26,\n  serverReference: 28,\n  topicAlias: 35,\n  subscriptionIdentifier: 11\n}\nprotocol.propertiesCodes = {}\nfor (const prop in protocol.properties) {\n  const id = protocol.properties[prop]\n  protocol.propertiesCodes[id] = prop\n}\nprotocol.propertiesTypes = {\n  sessionExpiryInterval: 'int32',\n  willDelayInterval: 'int32',\n  receiveMaximum: 'int16',\n  maximumPacketSize: 'int32',\n  topicAliasMaximum: 'int16',\n  requestResponseInformation: 'byte',\n  requestProblemInformation: 'byte',\n  userProperties: 'pair',\n  authenticationMethod: 'string',\n  authenticationData: 'binary',\n  payloadFormatIndicator: 'byte',\n  messageExpiryInterval: 'int32',\n  contentType: 'string',\n  responseTopic: 'string',\n  correlationData: 'binary',\n  maximumQoS: 'int8',\n  retainAvailable: 'byte',\n  assignedClientIdentifier: 'string',\n  reasonString: 'string',\n  wildcardSubscriptionAvailable: 'byte',\n  subscriptionIdentifiersAvailable: 'byte',\n  sharedSubscriptionAvailable: 'byte',\n  serverKeepAlive: 'int16',\n  responseInformation: 'string',\n  serverReference: 'string',\n  topicAlias: 'int16',\n  subscriptionIdentifier: 'var'\n}\n\nfunction genHeader (type) {\n  return [0, 1, 2].map(qos => {\n    return [0, 1].map(dup => {\n      return [0, 1].map(retain => {\n        const buf = Buffer.alloc(1)\n        buf.writeUInt8(\n          protocol.codes[type] << protocol.CMD_SHIFT |\n          (dup ? protocol.DUP_MASK : 0) |\n          qos << protocol.QOS_SHIFT | retain, 0, true)\n        return buf\n      })\n    })\n  })\n}\n\n/* Publish */\nprotocol.PUBLISH_HEADER = genHeader('publish')\n\n/* Subscribe */\nprotocol.SUBSCRIBE_HEADER = genHeader('subscribe')\nprotocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03\nprotocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01\nprotocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2\nprotocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01\nprotocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3\nprotocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03\nprotocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4\nprotocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20]\nprotocol.SUBSCRIBE_OPTIONS_NL = 0x04\nprotocol.SUBSCRIBE_OPTIONS_RAP = 0x08\nprotocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02]\n\n/* Unsubscribe */\nprotocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')\n\n/* Confirmations */\nprotocol.ACKS = {\n  unsuback: genHeader('unsuback'),\n  puback: genHeader('puback'),\n  pubcomp: genHeader('pubcomp'),\n  pubrel: genHeader('pubrel'),\n  pubrec: genHeader('pubrec')\n}\n\nprotocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT])\n\n/* Protocol versions */\nprotocol.VERSION3 = Buffer.from([3])\nprotocol.VERSION4 = Buffer.from([4])\nprotocol.VERSION5 = Buffer.from([5])\nprotocol.VERSION131 = Buffer.from([131])\nprotocol.VERSION132 = Buffer.from([132])\n\n/* QoS */\nprotocol.QOS = [0, 1, 2].map(qos => {\n  return Buffer.from([qos])\n})\n\n/* Empty packets */\nprotocol.EMPTY = {\n  pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),\n  pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),\n  disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":3}],37:[function(require,module,exports){\n(function (Buffer){(function (){\nconst writeToStream = require('./writeToStream')\nconst EventEmitter = require('events')\n\nfunction generate (packet, opts) {\n  const stream = new Accumulator()\n  writeToStream(packet, stream, opts)\n  return stream.concat()\n}\n\nclass Accumulator extends EventEmitter {\n  constructor () {\n    super()\n    this._array = new Array(20)\n    this._i = 0\n  }\n\n  write (chunk) {\n    this._array[this._i++] = chunk\n    return true\n  }\n\n  concat () {\n    let length = 0\n    const lengths = new Array(this._array.length)\n    const list = this._array\n    let pos = 0\n    let i\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') lengths[i] = list[i].length\n      else lengths[i] = Buffer.byteLength(list[i])\n\n      length += lengths[i]\n    }\n\n    const result = Buffer.allocUnsafe(length)\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') {\n        list[i].copy(result, pos)\n        pos += lengths[i]\n      } else {\n        result.write(list[i], pos)\n        pos += lengths[i]\n      }\n    }\n\n    return result\n  }\n}\n\nmodule.exports = generate\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"./writeToStream\":42,\"buffer\":3,\"events\":4}],38:[function(require,module,exports){\nexports.parser = require('./parser').parser\nexports.generate = require('./generate')\nexports.writeToStream = require('./writeToStream')\n\n},{\"./generate\":37,\"./parser\":41,\"./writeToStream\":42}],39:[function(require,module,exports){\n(function (Buffer){(function (){\nconst max = 65536\nconst cache = {}\n\n// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n// later versions return a Buffer\n// alternative is Buffer.slice but that creates a new buffer\n// creating new buffers takes time\n// SubOk is only false on node < 8\nconst SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1))\n\nfunction generateBuffer (i) {\n  const buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (let i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nfunction genBufVariableByteInt (num) {\n  const maxLength = 4 // max 4 bytes\n  let digit = 0\n  let pos = 0\n  const buffer = Buffer.allocUnsafe(maxLength)\n\n  do {\n    digit = num % 128 | 0\n    num = num / 128 | 0\n    if (num > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (num > 0 && pos < maxLength)\n\n  if (num > 0) {\n    pos = 0\n  }\n\n  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos)\n}\n\nfunction generate4ByteBuffer (num) {\n  const buffer = Buffer.allocUnsafe(4)\n  buffer.writeUInt32BE(num, 0)\n  return buffer\n}\n\nmodule.exports = {\n  cache,\n  generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt,\n  generate4ByteBuffer\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":3}],40:[function(require,module,exports){\nclass Packet {\n  constructor () {\n    this.cmd = null\n    this.retain = false\n    this.qos = 0\n    this.dup = false\n    this.length = -1\n    this.topic = null\n    this.payload = null\n  }\n}\n\nmodule.exports = Packet\n\n},{}],41:[function(require,module,exports){\nconst bl = require('bl')\nconst EventEmitter = require('events')\nconst Packet = require('./packet')\nconst constants = require('./constants')\nconst debug = require('debug')('mqtt-packet:parser')\n\nclass Parser extends EventEmitter {\n  constructor () {\n    super()\n    this.parser = this.constructor.parser\n  }\n\n  static parser (opt) {\n    if (!(this instanceof Parser)) return (new Parser()).parser(opt)\n\n    this.settings = opt || {}\n\n    this._states = [\n      '_parseHeader',\n      '_parseLength',\n      '_parsePayload',\n      '_newPacket'\n    ]\n\n    this._resetState()\n    return this\n  }\n\n  _resetState () {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter')\n    this.packet = new Packet()\n    this.error = null\n    this._list = bl()\n    this._stateCounter = 0\n  }\n\n  parse (buf) {\n    if (this.error) this._resetState()\n\n    this._list.append(buf)\n    debug('parse: current state: %s', this._states[this._stateCounter])\n    while ((this.packet.length !== -1 || this._list.length > 0) &&\n      this[this._states[this._stateCounter]]() &&\n      !this.error) {\n      this._stateCounter++\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)\n    return this._list.length\n  }\n\n  _parseHeader () {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0)\n    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0\n    debug('_parseHeader: packet: %o', this.packet)\n\n    this._list.consume(1)\n\n    return true\n  }\n\n  _parseLength () {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true)\n\n    if (result) {\n      this.packet.length = result.value\n      this._list.consume(result.bytes)\n    }\n    debug('_parseLength %d', result.value)\n    return !!result\n  }\n\n  _parsePayload () {\n    debug('_parsePayload: payload %O', this._list)\n    let result = false\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect()\n          break\n        case 'connack':\n          this._parseConnack()\n          break\n        case 'publish':\n          this._parsePublish()\n          break\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation()\n          break\n        case 'subscribe':\n          this._parseSubscribe()\n          break\n        case 'suback':\n          this._parseSuback()\n          break\n        case 'unsubscribe':\n          this._parseUnsubscribe()\n          break\n        case 'unsuback':\n          this._parseUnsuback()\n          break\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break\n        case 'disconnect':\n          this._parseDisconnect()\n          break\n        case 'auth':\n          this._parseAuth()\n          break\n        default:\n          this._emitError(new Error('Not supported'))\n      }\n\n      result = true\n    }\n    debug('_parsePayload complete result: %s', result)\n    return result\n  }\n\n  _parseConnect () {\n    debug('_parseConnect')\n    let topic // Will topic\n    let payload // Will payload\n    let password // Password\n    let username // Username\n    const flags = {}\n    const packet = this.packet\n\n    // Parse protocolId\n    const protocolId = this._parseString()\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'))\n    }\n\n    packet.protocolId = protocolId\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n    packet.protocolVersion = this._list.readUInt8(this._pos)\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true\n      packet.protocolVersion = packet.protocolVersion - 128\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'))\n    }\n\n    this._pos++\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'))\n    }\n\n    // Parse connect flags\n    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n    if (flags.will) {\n      packet.will = {}\n      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n      packet.will.qos = (this._list.readUInt8(this._pos) &\n        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n    this._pos++\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum()\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString()\n    if (clientId === null) return this._emitError(new Error('Packet too short'))\n    packet.clientId = clientId\n    debug('_parseConnect: packet.clientId: %s', packet.clientId)\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties()\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties\n        }\n      }\n      // Parse will topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n      packet.will.topic = topic\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)\n\n      // Parse will payload\n      payload = this._parseBuffer()\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n      packet.will.payload = payload\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString()\n      if (username === null) return this._emitError(new Error('Cannot parse username'))\n      packet.username = username\n      debug('_parseConnect: packet.username: %s', packet.username)\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer()\n      if (password === null) return this._emitError(new Error('Cannot parse password'))\n      packet.password = password\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet\n    debug('_parseConnect: complete')\n    return packet\n  }\n\n  _parseConnack () {\n    debug('_parseConnack')\n    const packet = this.packet\n\n    if (this._list.length < 1) return null\n    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++)\n      } else {\n        packet.reasonCode = 0\n      }\n    } else {\n      if (this._list.length < 2) return null\n      packet.returnCode = this._list.readUInt8(this._pos++)\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    debug('_parseConnack: complete')\n  }\n\n  _parsePublish () {\n    debug('_parsePublish')\n    const packet = this.packet\n    packet.topic = this._parseString()\n\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length)\n    debug('_parsePublish: payload from buffer list: %o', packet.payload)\n  }\n\n  _parseSubscribe () {\n    debug('_parseSubscribe')\n    const packet = this.packet\n    let topic\n    let options\n    let qos\n    let rh\n    let rap\n    let nl\n    let subscription\n\n    if (packet.qos !== 1) {\n      return this._emitError(new Error('Wrong subscribe header'))\n    }\n\n    packet.subscriptions = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n\n      options = this._parseByte()\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK\n      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0\n      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0\n      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK\n\n      subscription = { topic, qos }\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl\n        subscription.rap = rap\n        subscription.rh = rh\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0\n        subscription.rap = true\n        subscription.nl = true\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)\n      packet.subscriptions.push(subscription)\n    }\n  }\n\n  _parseSuback () {\n    debug('_parseSuback')\n    const packet = this.packet\n    this.packet.granted = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      this.packet.granted.push(this._list.readUInt8(this._pos++))\n    }\n  }\n\n  _parseUnsubscribe () {\n    debug('_parseUnsubscribe')\n    const packet = this.packet\n\n    packet.unsubscriptions = []\n\n    // Parse messageId\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)\n      packet.unsubscriptions.push(topic)\n    }\n  }\n\n  _parseUnsuback () {\n    debug('_parseUnsuback')\n    const packet = this.packet\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n      // Parse granted QoSes\n      packet.granted = []\n      while (this._pos < this.packet.length) {\n        this.packet.granted.push(this._list.readUInt8(this._pos++))\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation () {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)\n    const packet = this.packet\n\n    this._parseMessageId()\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte()\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)\n      } else {\n        packet.reasonCode = 0\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties()\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties\n        }\n      }\n    }\n\n    return true\n  }\n\n  // parse disconnect packet\n  _parseDisconnect () {\n    const packet = this.packet\n    debug('_parseDisconnect')\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte()\n      } else {\n        packet.reasonCode = 0\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    debug('_parseDisconnect result: true')\n    return true\n  }\n\n  // parse auth packet\n  _parseAuth () {\n    debug('_parseAuth')\n    const packet = this.packet\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'))\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte()\n    // properies mqtt 5\n    const properties = this._parseProperties()\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties\n    }\n\n    debug('_parseAuth: result: true')\n    return true\n  }\n\n  _parseMessageId () {\n    const packet = this.packet\n\n    packet.messageId = this._parseNum()\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'))\n      return false\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId)\n    return true\n  }\n\n  _parseString (maybeBuffer) {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.toString('utf8', this._pos, end)\n    this._pos += length\n    debug('_parseString: result: %s', result)\n    return result\n  }\n\n  _parseStringPair () {\n    debug('_parseStringPair')\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    }\n  }\n\n  _parseBuffer () {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.slice(this._pos, end)\n\n    this._pos += length\n    debug('_parseBuffer: result: %o', result)\n    return result\n  }\n\n  _parseNum () {\n    if (this._list.length - this._pos < 2) return -1\n\n    const result = this._list.readUInt16BE(this._pos)\n    this._pos += 2\n    debug('_parseNum: result: %s', result)\n    return result\n  }\n\n  _parse4ByteNum () {\n    if (this._list.length - this._pos < 4) return -1\n\n    const result = this._list.readUInt32BE(this._pos)\n    this._pos += 4\n    debug('_parse4ByteNum: result: %s', result)\n    return result\n  }\n\n  _parseVarByteNum (fullInfoFlag) {\n    debug('_parseVarByteNum')\n    const maxBytes = 4\n    let bytes = 0\n    let mul = 1\n    let value = 0\n    let result = false\n    let current\n    const padding = this._pos ? this._pos : 0\n\n    while (bytes < maxBytes && (padding + bytes) < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++)\n      value += mul * (current & constants.VARBYTEINT_MASK)\n      mul *= 0x80\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true\n        break\n      }\n      if (this._list.length <= bytes) {\n        break\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'))\n    }\n\n    if (padding) {\n      this._pos += bytes\n    }\n\n    result = result\n      ? fullInfoFlag ? {\n        bytes,\n        value\n      } : value\n      : false\n\n    debug('_parseVarByteNum: result: %o', result)\n    return result\n  }\n\n  _parseByte () {\n    let result\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos)\n      this._pos++\n    }\n    debug('_parseByte: result: %o', result)\n    return result\n  }\n\n  _parseByType (type) {\n    debug('_parseByType: type: %s', type)\n    switch (type) {\n      case 'byte': {\n        return this._parseByte() !== 0\n      }\n      case 'int8': {\n        return this._parseByte()\n      }\n      case 'int16': {\n        return this._parseNum()\n      }\n      case 'int32': {\n        return this._parse4ByteNum()\n      }\n      case 'var': {\n        return this._parseVarByteNum()\n      }\n      case 'string': {\n        return this._parseString()\n      }\n      case 'pair': {\n        return this._parseStringPair()\n      }\n      case 'binary': {\n        return this._parseBuffer()\n      }\n    }\n  }\n\n  _parseProperties () {\n    debug('_parseProperties')\n    const length = this._parseVarByteNum()\n    const start = this._pos\n    const end = start + length\n    const result = {}\n    while (this._pos < end) {\n      const type = this._parseByte()\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'))\n        return false\n      }\n      const name = constants.propertiesCodes[type]\n      if (!name) {\n        this._emitError(new Error('Unknown property'))\n        return false\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null)\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          } else {\n            const currentValue = result[name][currentUserProperty.name]\n            result[name][currentUserProperty.name] = [currentValue]\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value\n        }\n        continue\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        } else {\n          result[name] = [result[name]]\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name])\n      }\n    }\n    return result\n  }\n\n  _newPacket () {\n    debug('_newPacket')\n    if (this.packet) {\n      this._list.consume(this.packet.length)\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)\n      this.emit('packet', this.packet)\n    }\n    debug('_newPacket: new packet')\n    this.packet = new Packet()\n\n    this._pos = 0\n\n    return true\n  }\n\n  _emitError (err) {\n    debug('_emitError')\n    this.error = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Parser\n\n},{\"./constants\":36,\"./packet\":40,\"bl\":17,\"debug\":19,\"events\":4}],42:[function(require,module,exports){\n(function (Buffer){(function (){\nconst protocol = require('./constants')\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = require('./numbers')\nconst nextTick = require('process-nextick-args').nextTick\nconst debug = require('debug')('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  let protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    var willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128\n  }\n\n  stream.write(\n    protocolVersion === 131\n      ? protocol.VERSION131\n      : protocolVersion === 132\n        ? protocol.VERSION132\n        : protocolVersion === 4\n          ? protocol.VERSION4\n          : protocolVersion === 5\n            ? protocol.VERSION5\n            : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n},{\"./constants\":36,\"./numbers\":39,\"buffer\":3,\"debug\":19,\"process-nextick-args\":45}],43:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n},{}],44:[function(require,module,exports){\nvar wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n},{\"wrappy\":66}],45:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n}).call(this)}).call(this,require('_process'))\n},{\"_process\":69}],46:[function(require,module,exports){\n'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n},{}],47:[function(require,module,exports){\n(function (process){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n}).call(this)}).call(this,require('_process'))\n},{\"./_stream_readable\":49,\"./_stream_writable\":51,\"_process\":69,\"inherits\":34}],48:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":50,\"inherits\":34}],49:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../errors\":46,\"./_stream_duplex\":47,\"./internal/streams/async_iterator\":52,\"./internal/streams/buffer_list\":53,\"./internal/streams/destroy\":54,\"./internal/streams/from\":56,\"./internal/streams/state\":58,\"./internal/streams/stream\":59,\"_process\":69,\"buffer\":3,\"events\":4,\"inherits\":34,\"string_decoder/\":64,\"util\":2}],50:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n},{\"../errors\":46,\"./_stream_duplex\":47,\"inherits\":34}],51:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../errors\":46,\"./_stream_duplex\":47,\"./internal/streams/destroy\":54,\"./internal/streams/state\":58,\"./internal/streams/stream\":59,\"_process\":69,\"buffer\":3,\"inherits\":34,\"util-deprecate\":65}],52:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n}).call(this)}).call(this,require('_process'))\n},{\"./end-of-stream\":55,\"_process\":69}],53:[function(require,module,exports){\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n},{\"buffer\":3,\"util\":2}],54:[function(require,module,exports){\n(function (process){(function (){\n'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n}).call(this)}).call(this,require('_process'))\n},{\"_process\":69}],55:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n},{\"../../../errors\":46}],56:[function(require,module,exports){\nmodule.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n},{}],57:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n},{\"../../../errors\":46,\"./end-of-stream\":55}],58:[function(require,module,exports){\n'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n},{\"../../../errors\":46}],59:[function(require,module,exports){\narguments[4][29][0].apply(exports,arguments)\n},{\"dup\":29,\"events\":4}],60:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n\n},{\"./lib/_stream_duplex.js\":47,\"./lib/_stream_passthrough.js\":48,\"./lib/_stream_readable.js\":49,\"./lib/_stream_transform.js\":50,\"./lib/_stream_writable.js\":51,\"./lib/internal/streams/end-of-stream.js\":55,\"./lib/internal/streams/pipeline.js\":57}],61:[function(require,module,exports){\n'use strict'\n\nfunction ReInterval (callback, interval, args) {\n  var self = this;\n\n  this._callback = callback;\n  this._args = args;\n\n  this._interval = setInterval(callback, interval, this._args);\n\n  this.reschedule = function (interval) {\n    // if no interval entered, use the interval passed in on creation\n    if (!interval)\n      interval = self._interval;\n\n    if (self._interval)\n      clearInterval(self._interval);\n    self._interval = setInterval(self._callback, interval, self._args);\n  };\n\n  this.clear = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n      self._interval = undefined;\n    }\n  };\n  \n  this.destroy = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n    }\n    self._callback = undefined;\n    self._interval = undefined;\n    self._args = undefined;\n  };\n}\n\nfunction reInterval () {\n  if (typeof arguments[0] !== 'function')\n    throw new Error('callback needed');\n  if (typeof arguments[1] !== 'number')\n    throw new Error('interval needed');\n\n  var args;\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2];\n    }\n  }\n\n  return new ReInterval(arguments[0], arguments[1], args);\n}\n\nmodule.exports = reInterval;\n\n},{}],62:[function(require,module,exports){\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":3}],63:[function(require,module,exports){\nmodule.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n\n},{}],64:[function(require,module,exports){\narguments[4][32][0].apply(exports,arguments)\n},{\"dup\":32,\"safe-buffer\":62}],65:[function(require,module,exports){\n(function (global){(function (){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],66:[function(require,module,exports){\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n},{}],67:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n},{}],68:[function(require,module,exports){\nmodule.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],69:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],70:[function(require,module,exports){\n(function (global){(function (){\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],71:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],72:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],73:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":71,\"./encode\":72}],74:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n},{\"process/browser.js\":69,\"timers\":74}],75:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n},{\"./util\":76,\"punycode\":70,\"querystring\":73}],76:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n},{}]},{},[15])(15)\n});\n"]},"metadata":{},"sourceType":"script"}